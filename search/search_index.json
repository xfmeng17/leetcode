{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LeetCode Solutions Getting Started In this repository, I'll work on solutions to all LeetCode problems by C++, Java, and Python. Coding Style I believe messy code is costing you. C++ code is formatted by clang-format following the Google C++ Style Guide . You can see the configuration here . Java code is formatted by Language Support for Java(TM) by Red Hat Python code is formatted by PEP 8 -- Style Guide for Python Code . More Information The repository is still under construction, and the goal is to keep up with the growth of LeetCode problems by Aug 2020! For more information, please visit my GitHub . By Egg Meng on Jan 19, 2020 COPY from https://github.com/walkccc/LeetCode . Revised on Dec 25, 2019.","title":"Preface"},{"location":"#leetcode-solutions","text":"","title":"LeetCode Solutions"},{"location":"#getting-started","text":"In this repository, I'll work on solutions to all LeetCode problems by C++, Java, and Python.","title":"Getting Started"},{"location":"#coding-style","text":"I believe messy code is costing you. C++ code is formatted by clang-format following the Google C++ Style Guide . You can see the configuration here . Java code is formatted by Language Support for Java(TM) by Red Hat Python code is formatted by PEP 8 -- Style Guide for Python Code .","title":"Coding Style"},{"location":"#more-information","text":"The repository is still under construction, and the goal is to keep up with the growth of LeetCode problems by Aug 2020! For more information, please visit my GitHub . By Egg Meng on Jan 19, 2020 COPY from https://github.com/walkccc/LeetCode . Revised on Dec 25, 2019.","title":"More Information"},{"location":"cpp/","text":"LeetCode in C++","title":"Preface"},{"location":"cpp/#leetcode-in-c","text":"","title":"LeetCode in C++"},{"location":"cpp/0001-0100/0001-0010/","text":"1. Two Sum $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( map . count ( nums [ i ])) return { map [ nums [ i ]], i }; map [ target - nums [ i ]] = i ; } throw ; } }; 2. Add Two Numbers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; int carry = 0 ; while ( carry || l1 || l2 ) { carry += ( l1 ? l1 -> val : 0 ) + ( l2 ? l2 -> val : 0 ); curr -> next = new ListNode ( carry % 10 ); curr = curr -> next ; carry /= 10 ; if ( l1 ) l1 = l1 -> next ; if ( l2 ) l2 = l2 -> next ; } return dummy . next ; } }; 3. Longest Substring Without Repeating Characters $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int lengthOfLongestSubstring ( string s ) { int ans = 0 ; unordered_map < char , int > map ; int j = 0 ; for ( int i = 0 ; i < s . size (); ++ i ) { char c = s [ i ]; if ( map . count ( c )) j = max ( j , map [ c ]); ans = max ( ans , i - j + 1 ); map [ c ] = i + 1 ; } return ans ; } }; 4. Median of Two Sorted Arrays $\\star\\star\\star$ 2\u4e2asorted\u6570\u7ec4\uff0c\u53d6\u7b2cK\u5927\u7684\u6570 \u7528left_k\uff0cright_k\uff08left_k + 1\uff09\u7684trick\u89e3\u51b3\u5947\u5076\u957f\u5ea6\u7684\u95ee\u9898 \u6bcf\u6b21\u53d6\u7b2ck/2\u4f4d\u7f6e\u7684\u5143\u7d20 val1\uff0cval2 \u6bd4\u8f83\uff0c\u5982\u679c val1 < val2 \uff0c\u5219\u6709 k/2 \u53ef\u4ee5\u6392\u9664\u4e86\uff0c arr1 \u8d77\u70b9 + k/2 \uff0c\u9012\u5f52\u67e5\u627e\u7b2c k-k/2 \u5927\u7684\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { int lk = ( nums1 . size () + nums2 . size () + 1 ) / 2 ; int rk = ( nums1 . size () + nums2 . size () + 2 ) / 2 ; double lret = findKth ( nums1 , 0 , nums2 , 0 , lk ); double rret = findKth ( nums1 , 0 , nums2 , 0 , rk ); return ( lret + rret ) / 2 ; } double findKth ( vector < int >& nums1 , int i , vector < int >& nums2 , int j , int k ) { if ( i >= nums1 . size ()) { return nums2 [ j + k - 1 ]; } if ( j >= nums2 . size ()) { return nums1 [ i + k - 1 ]; } if ( k == 1 ) { return min ( nums1 [ i ], nums2 [ j ]); } int val1 = ( i + k / 2 - 1 < nums1 . size ()) ? nums1 [ i + k / 2 - 1 ] : INT_MAX ; int val2 = ( j + k / 2 - 1 < nums2 . size ()) ? nums2 [ j + k / 2 - 1 ] : INT_MAX ; if ( val1 < val2 ) { return findKth ( nums1 , i + k / 2 , nums2 , j , k - k / 2 ); } else { return findKth ( nums1 , i , nums2 , j + k / 2 , k - k / 2 ); } } }; 5. Longest Palindromic Substring $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : string longestPalindrome ( string s ) { const int length = s . length () * 2 + 3 ; // Manacher's Algorithm string T ( length , '#' ); T [ 0 ] = '$' ; T [ length - 1 ] = '@' ; for ( int i = 2 ; i < length - 2 ; i += 2 ) T [ i ] = s [ i / 2 - 1 ]; int center = 1 ; int right = 1 ; vector < int > P ( length , 0 ); for ( int i = 1 ; i < length - 1 ; ++ i ) { int mirr = 2 * center - i ; if ( i < right ) P [ i ] = min ( P [ mirr ], right - i ); while ( T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]) ++ P [ i ]; if ( i + P [ i ] > right ) { center = i ; right = i + P [ i ]; } } // find max and the center; int max = 0 ; int c = 0 ; for ( int i = 0 ; i < length ; ++ i ) if ( P [ i ] > max ) { max = P [ i ]; c = i ; } // omit '#' and get the string desired string ans ( max , '#' ); int i = 0 ; for ( int j = c - max + 1 ; j < c + max ; j += 2 ) { ans [ i ] = T [ j ]; ++ i ; } return ans ; } }; 6. ZigZag Conversion $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string convert ( string s , int numRows ) { string ans ( s ); vector < vector < char >> rows ( numRows ); int k = 0 ; int direction = ( numRows == 1 ) - 1 ; for ( char c : s ) { rows [ k ]. push_back ( c ); if ( k == 0 || k == numRows - 1 ) direction *= - 1 ; k += direction ; } k = 0 ; for ( int i = 0 ; i < numRows ; ++ i ) for ( int j = 0 ; j < rows [ i ]. size (); ++ j ) ans [ k ++ ] = rows [ i ][ j ]; return ans ; } }; 7. Reverse Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int reverse ( int x ) { long ans = 0 ; while ( x ) { ans = ans * 10 + x % 10 ; x /= 10 ; } if ( ans < INT_MIN || ans > INT_MAX ) return 0 ; return ans ; } }; 8. String to Integer (atoi) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int myAtoi ( string str ) { long long ans = 0 ; bool isNegative = false ; int j = 0 ; while ( j < str . size () && str [ j ] == ' ' ) ++ j ; if ( j == str . size ()) return 0 ; if ( str [ j ] == '-' ) { isNegative = true ; ++ j ; } else if ( str [ j ] == '+' ) { ++ j ; } for ( int i = j ; i < str . size (); ++ i ) { if ( str [ i ] < '0' || str [ i ] > '9' ) break ; else { ans = ans * 10 + ( str [ i ] - '0' ); if ( isNegative && - ans <= INT_MIN ) return INT_MIN ; if ( ! isNegative && ans >= INT_MAX ) return INT_MAX ; } } return isNegative ? - ans : ans ; } }; 9. Palindrome Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ans == x ; } }; 10. Regular Expression Matching $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isMatch ( string s , string p ) { if ( p . empty ()) return s . empty (); bool isFirstMatch = ( ! s . empty () && ( p [ 0 ] == s [ 0 ] || p [ 0 ] == '.' )); if ( p . length () >= 2 && p [ 1 ] == '*' ) return ( isMatch ( s , p . substr ( 2 )) || ( isFirstMatch && isMatch ( s . substr ( 1 ), p ))); return isFirstMatch && isMatch ( s . substr ( 1 ), p . substr ( 1 )); } };","title":"0001-0010"},{"location":"cpp/0001-0100/0001-0010/#1-two-sum-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( map . count ( nums [ i ])) return { map [ nums [ i ]], i }; map [ target - nums [ i ]] = i ; } throw ; } };","title":"1. Two Sum $\\star$"},{"location":"cpp/0001-0100/0001-0010/#2-add-two-numbers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; int carry = 0 ; while ( carry || l1 || l2 ) { carry += ( l1 ? l1 -> val : 0 ) + ( l2 ? l2 -> val : 0 ); curr -> next = new ListNode ( carry % 10 ); curr = curr -> next ; carry /= 10 ; if ( l1 ) l1 = l1 -> next ; if ( l2 ) l2 = l2 -> next ; } return dummy . next ; } };","title":"2. Add Two Numbers $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#3-longest-substring-without-repeating-characters-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int lengthOfLongestSubstring ( string s ) { int ans = 0 ; unordered_map < char , int > map ; int j = 0 ; for ( int i = 0 ; i < s . size (); ++ i ) { char c = s [ i ]; if ( map . count ( c )) j = max ( j , map [ c ]); ans = max ( ans , i - j + 1 ); map [ c ] = i + 1 ; } return ans ; } };","title":"3. Longest Substring Without Repeating Characters $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#4-median-of-two-sorted-arrays-starstarstar","text":"2\u4e2asorted\u6570\u7ec4\uff0c\u53d6\u7b2cK\u5927\u7684\u6570 \u7528left_k\uff0cright_k\uff08left_k + 1\uff09\u7684trick\u89e3\u51b3\u5947\u5076\u957f\u5ea6\u7684\u95ee\u9898 \u6bcf\u6b21\u53d6\u7b2ck/2\u4f4d\u7f6e\u7684\u5143\u7d20 val1\uff0cval2 \u6bd4\u8f83\uff0c\u5982\u679c val1 < val2 \uff0c\u5219\u6709 k/2 \u53ef\u4ee5\u6392\u9664\u4e86\uff0c arr1 \u8d77\u70b9 + k/2 \uff0c\u9012\u5f52\u67e5\u627e\u7b2c k-k/2 \u5927\u7684\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { int lk = ( nums1 . size () + nums2 . size () + 1 ) / 2 ; int rk = ( nums1 . size () + nums2 . size () + 2 ) / 2 ; double lret = findKth ( nums1 , 0 , nums2 , 0 , lk ); double rret = findKth ( nums1 , 0 , nums2 , 0 , rk ); return ( lret + rret ) / 2 ; } double findKth ( vector < int >& nums1 , int i , vector < int >& nums2 , int j , int k ) { if ( i >= nums1 . size ()) { return nums2 [ j + k - 1 ]; } if ( j >= nums2 . size ()) { return nums1 [ i + k - 1 ]; } if ( k == 1 ) { return min ( nums1 [ i ], nums2 [ j ]); } int val1 = ( i + k / 2 - 1 < nums1 . size ()) ? nums1 [ i + k / 2 - 1 ] : INT_MAX ; int val2 = ( j + k / 2 - 1 < nums2 . size ()) ? nums2 [ j + k / 2 - 1 ] : INT_MAX ; if ( val1 < val2 ) { return findKth ( nums1 , i + k / 2 , nums2 , j , k - k / 2 ); } else { return findKth ( nums1 , i , nums2 , j + k / 2 , k - k / 2 ); } } };","title":"4. Median of Two Sorted Arrays $\\star\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#5-longest-palindromic-substring-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : string longestPalindrome ( string s ) { const int length = s . length () * 2 + 3 ; // Manacher's Algorithm string T ( length , '#' ); T [ 0 ] = '$' ; T [ length - 1 ] = '@' ; for ( int i = 2 ; i < length - 2 ; i += 2 ) T [ i ] = s [ i / 2 - 1 ]; int center = 1 ; int right = 1 ; vector < int > P ( length , 0 ); for ( int i = 1 ; i < length - 1 ; ++ i ) { int mirr = 2 * center - i ; if ( i < right ) P [ i ] = min ( P [ mirr ], right - i ); while ( T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]) ++ P [ i ]; if ( i + P [ i ] > right ) { center = i ; right = i + P [ i ]; } } // find max and the center; int max = 0 ; int c = 0 ; for ( int i = 0 ; i < length ; ++ i ) if ( P [ i ] > max ) { max = P [ i ]; c = i ; } // omit '#' and get the string desired string ans ( max , '#' ); int i = 0 ; for ( int j = c - max + 1 ; j < c + max ; j += 2 ) { ans [ i ] = T [ j ]; ++ i ; } return ans ; } };","title":"5. Longest Palindromic Substring $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#6-zigzag-conversion-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string convert ( string s , int numRows ) { string ans ( s ); vector < vector < char >> rows ( numRows ); int k = 0 ; int direction = ( numRows == 1 ) - 1 ; for ( char c : s ) { rows [ k ]. push_back ( c ); if ( k == 0 || k == numRows - 1 ) direction *= - 1 ; k += direction ; } k = 0 ; for ( int i = 0 ; i < numRows ; ++ i ) for ( int j = 0 ; j < rows [ i ]. size (); ++ j ) ans [ k ++ ] = rows [ i ][ j ]; return ans ; } };","title":"6. ZigZag Conversion $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#7-reverse-integer-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int reverse ( int x ) { long ans = 0 ; while ( x ) { ans = ans * 10 + x % 10 ; x /= 10 ; } if ( ans < INT_MIN || ans > INT_MAX ) return 0 ; return ans ; } };","title":"7. Reverse Integer $\\star$"},{"location":"cpp/0001-0100/0001-0010/#8-string-to-integer-atoi-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int myAtoi ( string str ) { long long ans = 0 ; bool isNegative = false ; int j = 0 ; while ( j < str . size () && str [ j ] == ' ' ) ++ j ; if ( j == str . size ()) return 0 ; if ( str [ j ] == '-' ) { isNegative = true ; ++ j ; } else if ( str [ j ] == '+' ) { ++ j ; } for ( int i = j ; i < str . size (); ++ i ) { if ( str [ i ] < '0' || str [ i ] > '9' ) break ; else { ans = ans * 10 + ( str [ i ] - '0' ); if ( isNegative && - ans <= INT_MIN ) return INT_MIN ; if ( ! isNegative && ans >= INT_MAX ) return INT_MAX ; } } return isNegative ? - ans : ans ; } };","title":"8. String to Integer (atoi) $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#9-palindrome-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ans == x ; } };","title":"9. Palindrome Number $\\star$"},{"location":"cpp/0001-0100/0001-0010/#10-regular-expression-matching-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isMatch ( string s , string p ) { if ( p . empty ()) return s . empty (); bool isFirstMatch = ( ! s . empty () && ( p [ 0 ] == s [ 0 ] || p [ 0 ] == '.' )); if ( p . length () >= 2 && p [ 1 ] == '*' ) return ( isMatch ( s , p . substr ( 2 )) || ( isFirstMatch && isMatch ( s . substr ( 1 ), p ))); return isFirstMatch && isMatch ( s . substr ( 1 ), p . substr ( 1 )); } };","title":"10. Regular Expression Matching $\\star\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/","text":"11. Container With Most Water $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxArea ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; while ( l < r ) { int h = min ( height [ l ], height [ r ]); ans = max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) ++ l ; while ( height [ r ] <= h && l < r ) -- r ; } return ans ; } }; 12. Integer to Roman $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : string intToRoman ( int num ) { string M [ 4 ] = { \"\" , \"M\" , \"MM\" , \"MMM\" }; string C [ 10 ] = { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; string X [ 10 ] = { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; string I [ 10 ] = { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ]; } }; 13. Roman to Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int romanToInt ( string s ) { int ans = 0 ; unordered_map < char , int > map = {{ 'I' , 1 }, { 'V' , 5 }, { 'X' , 10 }, { 'L' , 50 }, { 'C' , 100 }, { 'D' , 500 }, { 'M' , 1000 }}; for ( int i = 0 ; i < s . size (); ++ i ) { if ( map [ s [ i ]] < map [ s [ i + 1 ]]) ans -= map [ s [ i ]]; else ans += map [ s [ i ]]; } return ans ; } }; 14. Longest Common Prefix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { if ( strs . size () == 0 ) return \"\" ; if ( strs . size () == 1 ) return strs [ 0 ]; string ans ; int min = strs [ 0 ]. length (); bool isMatch = true ; for ( int i = 1 ; i < strs . size (); ++ i ) min = std :: min ( min , ( int ) strs [ i ]. length ()); for ( int i = 0 ; i < min ; ++ i ) { char c = strs [ 0 ][ i ]; for ( int j = 1 ; j < strs . size (); ++ j ) if ( c != strs [ j ][ i ]) { isMatch = false ; break ; } if ( ! isMatch ) break ; ans += c ; } return ans ; } }; 15. 3Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { vector < vector < int >> ans ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == 0 ) { ans . push_back ({ nums [ i ], nums [ l ], nums [ r ]}); ++ l ; -- r ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; while ( nums [ r ] == nums [ r + 1 ] && l < r ) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } }; 16. 3Sum Closest $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ]; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == target ) return sum ; if ( abs ( sum - target ) < abs ( ans - target )) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } }; 17. Letter Combinations of a Phone Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > letterCombinations ( string digits ) { if ( digits . empty ()) return {}; vector < string > ans = { \"\" }; unordered_map < char , string > map = { { '2' , \"abc\" }, { '3' , \"def\" }, { '4' , \"ghi\" }, { '5' , \"jkl\" }, { '6' , \"mno\" }, { '7' , \"pqrs\" }, { '8' , \"tuv\" }, { '9' , \"wxyz\" }}; for ( char i : digits ) { vector < string > tmp ; for ( string & j : ans ) for ( char k : map [ i ]) tmp . push_back ( j + k ); ans = tmp ; } return ans ; } }; 18. 4Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( nums . begin (), nums . end ()); nSum ( nums , target , 0 , nums . size () - 1 , 4 , path , ans ); return ans ; } private : void nSum ( vector < int >& nums , int target , int l , int r , int n , vector < int >& path , vector < vector < int >>& ans ) { if ( r - l + 1 < n || n < 2 || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == target ) { path . push_back ( nums [ l ]); path . push_back ( nums [ r ]); ans . push_back ( path ); path . pop_back (); path . pop_back (); ++ l ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); nSum ( nums , target - nums [ i ], i + 1 , r , n - 1 , path , ans ); path . pop_back (); } } }; 19. Remove Nth Node From End of List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { auto slow = head ; auto fast = head ; while ( n -- ) fast = fast -> next ; if ( ! fast ) return head -> next ; while ( fast -> next ) { slow = slow -> next ; fast = fast -> next ; } slow -> next = slow -> next -> next ; return head ; } }; 20. Valid Parentheses $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool isValid ( string s ) { stack < char > stack ; for ( char c : s ) { if ( c == '(' || c == '{' || c == '[' ) { stack . push ( c ); } else { if ( stack . empty () || ( c == ')' && stack . top () != '(' ) || ( c == '}' && stack . top () != '{' ) || ( c == ']' && stack . top () != '[' )) return false ; stack . pop (); } } return stack . empty (); } };","title":"0011-0020"},{"location":"cpp/0001-0100/0011-0020/#11-container-with-most-water-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxArea ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; while ( l < r ) { int h = min ( height [ l ], height [ r ]); ans = max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) ++ l ; while ( height [ r ] <= h && l < r ) -- r ; } return ans ; } };","title":"11. Container With Most Water $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#12-integer-to-roman-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : string intToRoman ( int num ) { string M [ 4 ] = { \"\" , \"M\" , \"MM\" , \"MMM\" }; string C [ 10 ] = { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; string X [ 10 ] = { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; string I [ 10 ] = { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ]; } };","title":"12. Integer to Roman $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#13-roman-to-integer-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int romanToInt ( string s ) { int ans = 0 ; unordered_map < char , int > map = {{ 'I' , 1 }, { 'V' , 5 }, { 'X' , 10 }, { 'L' , 50 }, { 'C' , 100 }, { 'D' , 500 }, { 'M' , 1000 }}; for ( int i = 0 ; i < s . size (); ++ i ) { if ( map [ s [ i ]] < map [ s [ i + 1 ]]) ans -= map [ s [ i ]]; else ans += map [ s [ i ]]; } return ans ; } };","title":"13. Roman to Integer $\\star$"},{"location":"cpp/0001-0100/0011-0020/#14-longest-common-prefix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { if ( strs . size () == 0 ) return \"\" ; if ( strs . size () == 1 ) return strs [ 0 ]; string ans ; int min = strs [ 0 ]. length (); bool isMatch = true ; for ( int i = 1 ; i < strs . size (); ++ i ) min = std :: min ( min , ( int ) strs [ i ]. length ()); for ( int i = 0 ; i < min ; ++ i ) { char c = strs [ 0 ][ i ]; for ( int j = 1 ; j < strs . size (); ++ j ) if ( c != strs [ j ][ i ]) { isMatch = false ; break ; } if ( ! isMatch ) break ; ans += c ; } return ans ; } };","title":"14. Longest Common Prefix $\\star$"},{"location":"cpp/0001-0100/0011-0020/#15-3sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { vector < vector < int >> ans ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == 0 ) { ans . push_back ({ nums [ i ], nums [ l ], nums [ r ]}); ++ l ; -- r ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; while ( nums [ r ] == nums [ r + 1 ] && l < r ) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } };","title":"15. 3Sum $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#16-3sum-closest-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ]; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == target ) return sum ; if ( abs ( sum - target ) < abs ( ans - target )) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } };","title":"16. 3Sum Closest $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#17-letter-combinations-of-a-phone-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > letterCombinations ( string digits ) { if ( digits . empty ()) return {}; vector < string > ans = { \"\" }; unordered_map < char , string > map = { { '2' , \"abc\" }, { '3' , \"def\" }, { '4' , \"ghi\" }, { '5' , \"jkl\" }, { '6' , \"mno\" }, { '7' , \"pqrs\" }, { '8' , \"tuv\" }, { '9' , \"wxyz\" }}; for ( char i : digits ) { vector < string > tmp ; for ( string & j : ans ) for ( char k : map [ i ]) tmp . push_back ( j + k ); ans = tmp ; } return ans ; } };","title":"17. Letter Combinations of a Phone Number $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#18-4sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( nums . begin (), nums . end ()); nSum ( nums , target , 0 , nums . size () - 1 , 4 , path , ans ); return ans ; } private : void nSum ( vector < int >& nums , int target , int l , int r , int n , vector < int >& path , vector < vector < int >>& ans ) { if ( r - l + 1 < n || n < 2 || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == target ) { path . push_back ( nums [ l ]); path . push_back ( nums [ r ]); ans . push_back ( path ); path . pop_back (); path . pop_back (); ++ l ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); nSum ( nums , target - nums [ i ], i + 1 , r , n - 1 , path , ans ); path . pop_back (); } } };","title":"18. 4Sum $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#19-remove-nth-node-from-end-of-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { auto slow = head ; auto fast = head ; while ( n -- ) fast = fast -> next ; if ( ! fast ) return head -> next ; while ( fast -> next ) { slow = slow -> next ; fast = fast -> next ; } slow -> next = slow -> next -> next ; return head ; } };","title":"19. Remove Nth Node From End of List $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#20-valid-parentheses-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool isValid ( string s ) { stack < char > stack ; for ( char c : s ) { if ( c == '(' || c == '{' || c == '[' ) { stack . push ( c ); } else { if ( stack . empty () || ( c == ')' && stack . top () != '(' ) || ( c == '}' && stack . top () != '{' ) || ( c == ']' && stack . top () != '[' )) return false ; stack . pop (); } } return stack . empty (); } };","title":"20. Valid Parentheses $\\star$"},{"location":"cpp/0001-0100/0021-0030/","text":"21. Merge Two Sorted Lists $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( ! l1 || ! l2 ) return l1 ? l1 : l2 ; if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); l1 -> next = mergeTwoLists ( l1 -> next , l2 ); return l1 ; } }; 22. Generate Parentheses $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > ans ; helper ( \"\" , n , n , ans ); return ans ; } private : void helper ( string str , int l , int r , vector < string >& ans ) { if ( l == 0 && r == 0 ) ans . push_back ( str ); if ( l > 0 ) helper ( str + '(' , l - 1 , r , ans ); if ( l < r ) helper ( str + ')' , l , r - 1 , ans ); } }; 23. Merge k Sorted Lists $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; priority_queue < ListNode * , vector < ListNode *> , compareListNode > pq ; for ( auto list : lists ) if ( list ) pq . push ( list ); while ( ! pq . empty ()) { curr -> next = pq . top (); pq . pop (); curr = curr -> next ; if ( curr -> next ) pq . push ( curr -> next ); } return dummy . next ; } private : struct compareListNode { bool operator ()( const ListNode * l1 , const ListNode * l2 ) { return l1 -> val > l2 -> val ; } }; }; 24. Swap Nodes in Pairs $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; auto prev = & dummy ; auto curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { auto next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; prev = curr ; curr = curr -> next ; } return dummy . next ; } }; 25. Reverse Nodes in k-Group $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; auto prev = & dummy ; auto curr = head ; for ( int i = 0 ; i < length / k ; ++ i ) { for ( int j = 0 ; j < k - 1 ; ++ j ) { auto next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; } prev = curr ; curr = curr -> next ; } return dummy . next ; } }; 26. Remove Duplicates from Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int removeDuplicates ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int j = 0 ; for ( int i = 1 ; i < nums . size (); ++ i ) if ( nums [ i ] != nums [ j ]) nums [ ++ j ] = nums [ i ]; return j + 1 ; } }; 27. Remove Element $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int removeElement ( vector < int >& nums , int val ) { int i = 0 ; for ( int num : nums ) if ( num != val ) nums [ i ++ ] = num ; return i ; } }; 28. Implement strStr() $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int strStr ( string haystack , string needle ) { const int m = haystack . length (); const int n = needle . length (); for ( int i = 0 ; i < m - n + 1 ; i ++ ) if ( haystack . substr ( i , n ) == needle ) return i ; return - 1 ; } }; 29. Divide Two Integers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int divide ( int dividend , int divisor ) { if ( dividend == INT_MIN && divisor == - 1 ) return INT_MAX ; long ans = 0 ; long dvd = labs ( dividend ); long dvs = labs ( divisor ); int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; while ( dvd >= dvs ) { long m = 1 ; long temp = dvs ; while ( temp << 1 <= dvd ) { m <<= 1 ; temp <<= 1 ; } dvd -= temp ; ans += m ; } return sign * ans ; } }; 30. Substring with Concatenation of All Words $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { if ( s . empty () || words . empty ()) return {}; const int m = s . length (); const int n = words [ 0 ]. length (); vector < int > ans ; unordered_map < string , int > map ; for ( string & word : words ) ++ map [ word ]; for ( int i = 0 ; i < n ; ++ i ) { int index = i ; int count = 0 ; unordered_map < string , int > tempMap ; for ( int j = i ; j <= m - n ; j += n ) { string str = s . substr ( j , n ); if ( map . count ( str )) { ++ tempMap [ str ]; ++ count ; while ( tempMap [ str ] > map [ str ]) { -- tempMap [ s . substr ( index , n )]; -- count ; index += n ; } if ( count == words . size ()) { ans . push_back ( index ); -- tempMap [ s . substr ( index , n )]; -- count ; index += n ; } } else { tempMap . clear (); count = 0 ; index = j + n ; } } } return ans ; } };","title":"0021-0030"},{"location":"cpp/0001-0100/0021-0030/#21-merge-two-sorted-lists-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( ! l1 || ! l2 ) return l1 ? l1 : l2 ; if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); l1 -> next = mergeTwoLists ( l1 -> next , l2 ); return l1 ; } };","title":"21. Merge Two Sorted Lists $\\star$"},{"location":"cpp/0001-0100/0021-0030/#22-generate-parentheses-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > ans ; helper ( \"\" , n , n , ans ); return ans ; } private : void helper ( string str , int l , int r , vector < string >& ans ) { if ( l == 0 && r == 0 ) ans . push_back ( str ); if ( l > 0 ) helper ( str + '(' , l - 1 , r , ans ); if ( l < r ) helper ( str + ')' , l , r - 1 , ans ); } };","title":"22. Generate Parentheses $\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#23-merge-k-sorted-lists-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; priority_queue < ListNode * , vector < ListNode *> , compareListNode > pq ; for ( auto list : lists ) if ( list ) pq . push ( list ); while ( ! pq . empty ()) { curr -> next = pq . top (); pq . pop (); curr = curr -> next ; if ( curr -> next ) pq . push ( curr -> next ); } return dummy . next ; } private : struct compareListNode { bool operator ()( const ListNode * l1 , const ListNode * l2 ) { return l1 -> val > l2 -> val ; } }; };","title":"23. Merge k Sorted Lists $\\star\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#24-swap-nodes-in-pairs-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; auto prev = & dummy ; auto curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { auto next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; prev = curr ; curr = curr -> next ; } return dummy . next ; } };","title":"24. Swap Nodes in Pairs $\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#25-reverse-nodes-in-k-group-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; auto prev = & dummy ; auto curr = head ; for ( int i = 0 ; i < length / k ; ++ i ) { for ( int j = 0 ; j < k - 1 ; ++ j ) { auto next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; } prev = curr ; curr = curr -> next ; } return dummy . next ; } };","title":"25. Reverse Nodes in k-Group $\\star\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#26-remove-duplicates-from-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int removeDuplicates ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int j = 0 ; for ( int i = 1 ; i < nums . size (); ++ i ) if ( nums [ i ] != nums [ j ]) nums [ ++ j ] = nums [ i ]; return j + 1 ; } };","title":"26. Remove Duplicates from Sorted Array $\\star$"},{"location":"cpp/0001-0100/0021-0030/#27-remove-element-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int removeElement ( vector < int >& nums , int val ) { int i = 0 ; for ( int num : nums ) if ( num != val ) nums [ i ++ ] = num ; return i ; } };","title":"27. Remove Element $\\star$"},{"location":"cpp/0001-0100/0021-0030/#28-implement-strstr-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int strStr ( string haystack , string needle ) { const int m = haystack . length (); const int n = needle . length (); for ( int i = 0 ; i < m - n + 1 ; i ++ ) if ( haystack . substr ( i , n ) == needle ) return i ; return - 1 ; } };","title":"28. Implement strStr() $\\star$"},{"location":"cpp/0001-0100/0021-0030/#29-divide-two-integers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int divide ( int dividend , int divisor ) { if ( dividend == INT_MIN && divisor == - 1 ) return INT_MAX ; long ans = 0 ; long dvd = labs ( dividend ); long dvs = labs ( divisor ); int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; while ( dvd >= dvs ) { long m = 1 ; long temp = dvs ; while ( temp << 1 <= dvd ) { m <<= 1 ; temp <<= 1 ; } dvd -= temp ; ans += m ; } return sign * ans ; } };","title":"29. Divide Two Integers $\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#30-substring-with-concatenation-of-all-words-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { if ( s . empty () || words . empty ()) return {}; const int m = s . length (); const int n = words [ 0 ]. length (); vector < int > ans ; unordered_map < string , int > map ; for ( string & word : words ) ++ map [ word ]; for ( int i = 0 ; i < n ; ++ i ) { int index = i ; int count = 0 ; unordered_map < string , int > tempMap ; for ( int j = i ; j <= m - n ; j += n ) { string str = s . substr ( j , n ); if ( map . count ( str )) { ++ tempMap [ str ]; ++ count ; while ( tempMap [ str ] > map [ str ]) { -- tempMap [ s . substr ( index , n )]; -- count ; index += n ; } if ( count == words . size ()) { ans . push_back ( index ); -- tempMap [ s . substr ( index , n )]; -- count ; index += n ; } } else { tempMap . clear (); count = 0 ; index = j + n ; } } } return ans ; } };","title":"30. Substring with Concatenation of All Words $\\star\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/","text":"31. Next Permutation $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : void nextPermutation ( vector < int >& nums ) { int i ; for ( i = nums . size () - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = nums . size () - 1 ; j >= 0 ; -- j ) if ( nums [ j ] > nums [ i ]) break ; swap ( nums [ i ], nums [ j ]); } reverse ( nums , i + 1 , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } }; 32. Longest Valid Parentheses $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : int longestValidParentheses ( string s ) { int ans = 0 ; int l = 0 ; int r = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { if ( s [ i ] == '(' ) ++ l ; else ++ r ; if ( l == r ) ans = max ( ans , 2 * r ); else if ( r > l ) { l = 0 ; r = 0 ; } } l = 0 ; r = 0 ; for ( int i = s . length () - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == '(' ) ++ l ; else ++ r ; if ( l == r ) ans = max ( ans , 2 * l ); else if ( l > r ) { l = 0 ; r = 0 ; } } return ans ; } }; 33. Search in Rotated Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } }; 34. Find First and Last Position of Element in Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { int leftIndex = find ( nums , target , true ); if ( leftIndex == nums . size () || nums [ leftIndex ] != target ) return { - 1 , - 1 }; return { leftIndex , find ( nums , target , false ) - 1 }; } private : int find ( vector < int >& nums , int target , bool isLeft ) { int l = 0 ; int r = nums . size (); while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > target || ( isLeft && nums [ m ] == target )) r = m ; else l = m + 1 ; } return l ; } }; 35. Search Insert Position $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size (); while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } }; 36. Valid Sudoku $\\star\\star$ 37. Sudoku Solver $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { dfs ( 0 , board ); } private : bool dfs ( int s , vector < vector < char >>& board ) { if ( s == 81 ) return true ; int i = s / 9 ; int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( s + 1 , board ); for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( i , j , c , board )) { board [ i ][ j ] = c ; if ( dfs ( s + 1 , board )) return true ; board [ i ][ j ] = '.' ; } return false ; } bool isValid ( int row , int col , char c , vector < vector < char >>& board ) { for ( int i = 0 ; i < 9 ; ++ i ) { if ( board [ i ][ col ] != '.' && board [ i ][ col ] == c ) return false ; if ( board [ row ][ i ] != '.' && board [ row ][ i ] == c ) return false ; if ( board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] != '.' && board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; } return true ; } }; 38. Count and Say $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : string countAndSay ( int n ) { unordered_map < int , string > map = { { 1 , \"1\" }, { 2 , \"11\" }, { 3 , \"21\" }, { 4 , \"1211\" }, { 5 , \"111221\" }}; if ( n <= 5 ) return map [ n ]; for ( int i = 6 ; i < n + 1 ; ++ i ) { string s ; int j = 0 ; while ( j <= map [ i - 1 ]. size () - 2 ) { int count = 1 ; while ( j <= map [ i - 1 ]. size () - 2 && map [ i - 1 ][ j ] == map [ i - 1 ][ j + 1 ]) { ++ count ; ++ j ; } s += to_string ( count ) + map [ i - 1 ][ j ]; ++ j ; } if ( j == map [ i - 1 ]. size () - 1 ) s += to_string ( 1 ) + map [ i - 1 ][ j ]; map [ i ] = s ; } return map [ n ]; } }; 39. Combination Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( candidates . begin (), candidates . end ()); dfs ( candidates , target , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& candidates , int target , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { path . push_back ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i , path , ans ); path . pop_back (); } } }; 40. Combination Sum II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( candidates . begin (), candidates . end ()); dfs ( candidates , target , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& candidates , int target , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ]) continue ; path . push_back ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i + 1 , path , ans ); path . pop_back (); } } };","title":"0031-0040"},{"location":"cpp/0001-0100/0031-0040/#31-next-permutation-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : void nextPermutation ( vector < int >& nums ) { int i ; for ( i = nums . size () - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = nums . size () - 1 ; j >= 0 ; -- j ) if ( nums [ j ] > nums [ i ]) break ; swap ( nums [ i ], nums [ j ]); } reverse ( nums , i + 1 , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } };","title":"31. Next Permutation $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#32-longest-valid-parentheses-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : int longestValidParentheses ( string s ) { int ans = 0 ; int l = 0 ; int r = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { if ( s [ i ] == '(' ) ++ l ; else ++ r ; if ( l == r ) ans = max ( ans , 2 * r ); else if ( r > l ) { l = 0 ; r = 0 ; } } l = 0 ; r = 0 ; for ( int i = s . length () - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == '(' ) ++ l ; else ++ r ; if ( l == r ) ans = max ( ans , 2 * l ); else if ( l > r ) { l = 0 ; r = 0 ; } } return ans ; } };","title":"32. Longest Valid Parentheses $\\star\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#33-search-in-rotated-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } };","title":"33. Search in Rotated Sorted Array $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#34-find-first-and-last-position-of-element-in-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { int leftIndex = find ( nums , target , true ); if ( leftIndex == nums . size () || nums [ leftIndex ] != target ) return { - 1 , - 1 }; return { leftIndex , find ( nums , target , false ) - 1 }; } private : int find ( vector < int >& nums , int target , bool isLeft ) { int l = 0 ; int r = nums . size (); while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > target || ( isLeft && nums [ m ] == target )) r = m ; else l = m + 1 ; } return l ; } };","title":"34. Find First and Last Position of Element in Sorted Array $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#35-search-insert-position-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size (); while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } };","title":"35. Search Insert Position $\\star$"},{"location":"cpp/0001-0100/0031-0040/#36-valid-sudoku-starstar","text":"","title":"36. Valid Sudoku $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#37-sudoku-solver-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { dfs ( 0 , board ); } private : bool dfs ( int s , vector < vector < char >>& board ) { if ( s == 81 ) return true ; int i = s / 9 ; int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( s + 1 , board ); for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( i , j , c , board )) { board [ i ][ j ] = c ; if ( dfs ( s + 1 , board )) return true ; board [ i ][ j ] = '.' ; } return false ; } bool isValid ( int row , int col , char c , vector < vector < char >>& board ) { for ( int i = 0 ; i < 9 ; ++ i ) { if ( board [ i ][ col ] != '.' && board [ i ][ col ] == c ) return false ; if ( board [ row ][ i ] != '.' && board [ row ][ i ] == c ) return false ; if ( board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] != '.' && board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; } return true ; } };","title":"37. Sudoku Solver $\\star\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#38-count-and-say-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : string countAndSay ( int n ) { unordered_map < int , string > map = { { 1 , \"1\" }, { 2 , \"11\" }, { 3 , \"21\" }, { 4 , \"1211\" }, { 5 , \"111221\" }}; if ( n <= 5 ) return map [ n ]; for ( int i = 6 ; i < n + 1 ; ++ i ) { string s ; int j = 0 ; while ( j <= map [ i - 1 ]. size () - 2 ) { int count = 1 ; while ( j <= map [ i - 1 ]. size () - 2 && map [ i - 1 ][ j ] == map [ i - 1 ][ j + 1 ]) { ++ count ; ++ j ; } s += to_string ( count ) + map [ i - 1 ][ j ]; ++ j ; } if ( j == map [ i - 1 ]. size () - 1 ) s += to_string ( 1 ) + map [ i - 1 ][ j ]; map [ i ] = s ; } return map [ n ]; } };","title":"38. Count and Say $\\star$"},{"location":"cpp/0001-0100/0031-0040/#39-combination-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( candidates . begin (), candidates . end ()); dfs ( candidates , target , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& candidates , int target , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { path . push_back ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i , path , ans ); path . pop_back (); } } };","title":"39. Combination Sum $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#40-combination-sum-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( candidates . begin (), candidates . end ()); dfs ( candidates , target , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& candidates , int target , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ]) continue ; path . push_back ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i + 1 , path , ans ); path . pop_back (); } } };","title":"40. Combination Sum II $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/","text":"41. First Missing Positive $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int firstMissingPositive ( vector < int >& nums ) { if ( nums . empty ()) return 1 ; const int n = nums . size (); for ( int i = 0 ; i < nums . size (); ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ]) swap ( nums [ i ], nums [ nums [ i ] - 1 ]); for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } }; 42. Trapping Rain Water $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int trap ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; int maxLeft = 0 ; int maxRight = 0 ; while ( l < r ) { if ( height [ l ] < height [ r ]) { maxLeft = max ( maxLeft , height [ l ]); ans += maxLeft - height [ l ]; ++ l ; } else { maxRight = max ( maxRight , height [ r ]); ans += maxRight - height [ r ]; -- r ; } } return ans ; } }; 43. Multiply Strings $\\star\\star$ 44. Wildcard Matching $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool isMatch ( string s , string p ) { const int m = s . length (); const int n = p . length (); vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) { if ( i == 0 && j == 0 ) dp [ i ][ j ] = true ; else if ( i == 0 ) dp [ i ][ j ] = dp [ i ][ j - 1 ] && p [ j - 1 ] == '*' ; else if ( j == 0 ) dp [ i ][ j ] = dp [ i - 1 ][ j ] && s [ i - 1 ] == '*' ; else dp [ i ][ j ] = ( dp [ i - 1 ][ j ] || dp [ i ][ j - 1 ] || dp [ i - 1 ][ j - 1 ]) && ( s [ i - 1 ] == '*' || p [ j - 1 ] == '*' ) || ( dp [ i - 1 ][ j - 1 ]) && ( s [ i - 1 ] == '?' || p [ j - 1 ] == '?' || s [ i - 1 ] == p [ j - 1 ]); } return dp [ m ][ n ]; } }; 45. Jump Game II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int jump ( vector < int >& nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } }; 46. Permutations $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } }; 47. Permutations II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); sort ( nums . begin (), nums . end ()); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ] || i > 0 && used [ i - 1 ] && nums [ i ] == nums [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } }; 48. Rotate Image $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : void rotate ( vector < vector < int >>& matrix ) { for ( int min = 0 ; min < matrix . size () / 2 ; ++ min ) { int max = matrix . size () - min - 1 ; for ( int i = min ; i < max ; ++ i ) { int offset = i - min ; int top = matrix [ min ][ i ]; matrix [ min ][ i ] = matrix [ max - offset ][ min ]; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ]; matrix [ max ][ max - offset ] = matrix [ i ][ max ]; matrix [ i ][ max ] = top ; } } } }; 49. Group Anagrams $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> map ; for ( string & str : strs ) { string s = str ; sort ( s . begin (), s . end ()); map [ s ]. push_back ( str ); } for ( auto & [ key , value ] : map ) { vector < string > s = value ; sort ( s . begin (), s . end ()); ans . push_back ( s ); } return ans ; } }; 50. Pow(x, n) $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution { public : double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n % 2 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } };","title":"0041-0050"},{"location":"cpp/0001-0100/0041-0050/#41-first-missing-positive-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int firstMissingPositive ( vector < int >& nums ) { if ( nums . empty ()) return 1 ; const int n = nums . size (); for ( int i = 0 ; i < nums . size (); ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ]) swap ( nums [ i ], nums [ nums [ i ] - 1 ]); for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } };","title":"41. First Missing Positive $\\star\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#42-trapping-rain-water-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int trap ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; int maxLeft = 0 ; int maxRight = 0 ; while ( l < r ) { if ( height [ l ] < height [ r ]) { maxLeft = max ( maxLeft , height [ l ]); ans += maxLeft - height [ l ]; ++ l ; } else { maxRight = max ( maxRight , height [ r ]); ans += maxRight - height [ r ]; -- r ; } } return ans ; } };","title":"42. Trapping Rain Water $\\star\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#43-multiply-strings-starstar","text":"","title":"43. Multiply Strings $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#44-wildcard-matching-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool isMatch ( string s , string p ) { const int m = s . length (); const int n = p . length (); vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) { if ( i == 0 && j == 0 ) dp [ i ][ j ] = true ; else if ( i == 0 ) dp [ i ][ j ] = dp [ i ][ j - 1 ] && p [ j - 1 ] == '*' ; else if ( j == 0 ) dp [ i ][ j ] = dp [ i - 1 ][ j ] && s [ i - 1 ] == '*' ; else dp [ i ][ j ] = ( dp [ i - 1 ][ j ] || dp [ i ][ j - 1 ] || dp [ i - 1 ][ j - 1 ]) && ( s [ i - 1 ] == '*' || p [ j - 1 ] == '*' ) || ( dp [ i - 1 ][ j - 1 ]) && ( s [ i - 1 ] == '?' || p [ j - 1 ] == '?' || s [ i - 1 ] == p [ j - 1 ]); } return dp [ m ][ n ]; } };","title":"44. Wildcard Matching $\\star\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#45-jump-game-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int jump ( vector < int >& nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } };","title":"45. Jump Game II $\\star\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#46-permutations-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } };","title":"46. Permutations $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#47-permutations-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); sort ( nums . begin (), nums . end ()); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ] || i > 0 && used [ i - 1 ] && nums [ i ] == nums [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } };","title":"47. Permutations II $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#48-rotate-image-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : void rotate ( vector < vector < int >>& matrix ) { for ( int min = 0 ; min < matrix . size () / 2 ; ++ min ) { int max = matrix . size () - min - 1 ; for ( int i = min ; i < max ; ++ i ) { int offset = i - min ; int top = matrix [ min ][ i ]; matrix [ min ][ i ] = matrix [ max - offset ][ min ]; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ]; matrix [ max ][ max - offset ] = matrix [ i ][ max ]; matrix [ i ][ max ] = top ; } } } };","title":"48. Rotate Image $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#49-group-anagrams-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> map ; for ( string & str : strs ) { string s = str ; sort ( s . begin (), s . end ()); map [ s ]. push_back ( str ); } for ( auto & [ key , value ] : map ) { vector < string > s = value ; sort ( s . begin (), s . end ()); ans . push_back ( s ); } return ans ; } };","title":"49. Group Anagrams $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#50-powx-n-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution { public : double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n % 2 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } };","title":"50. Pow(x, n) $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/","text":"51. N-Queens $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; vector < string > board ( n , string ( n , '.' )); vector < bool > cols ( n , false ); vector < bool > diag1 ( 2 * n - 1 , false ); vector < bool > diag2 ( 2 * n - 1 , false ); dfs ( 0 , cols , diag1 , diag2 , board , ans ); return ans ; } private : void dfs ( int y , vector < bool >& cols , vector < bool >& diag1 , vector < bool >& diag2 , vector < string >& board , vector < vector < string >>& ans ) { if ( y == cols . size ()) { ans . push_back ( board ); return ; } for ( int x = 0 ; x < cols . size (); ++ x ) { if ( ! cols [ x ] && ! diag1 [ x + y ] && ! diag2 [ x - y + cols . size () - 1 ]) { board [ y ][ x ] = 'Q' ; cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = true ; dfs ( y + 1 , cols , diag1 , diag2 , board , ans ); cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = false ; board [ y ][ x ] = '.' ; } } } }; 52. N-Queens II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; vector < bool > cols ( n , false ); vector < bool > diag1 ( 2 * n - 1 , false ); vector < bool > diag2 ( 2 * n - 1 , false ); dfs ( 0 , cols , diag1 , diag2 , ans ); return ans ; } private : void dfs ( int y , vector < bool >& cols , vector < bool >& diag1 , vector < bool >& diag2 , int & ans ) { if ( y == cols . size ()) { ++ ans ; return ; } for ( int x = 0 ; x < cols . size (); ++ x ) { if ( ! cols [ x ] && ! diag1 [ x + y ] && ! diag2 [ x - y + cols . size () - 1 ]) { cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = true ; dfs ( y + 1 , cols , diag1 , diag2 , ans ); cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = false ; } } } }; 53. Maximum Subarray $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxSubArray ( vector < int >& nums ) { int ans = INT_MIN ; int sum = 0 ; for ( int num : nums ) { sum += num ; ans = max ( ans , sum ); sum = max ( sum , 0 ); } return ans ; } }; 54. Spiral Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; vector < int > ans ; int r1 = 0 ; int c1 = 0 ; int r2 = matrix . size () - 1 ; int c2 = matrix [ 0 ]. size () - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; ++ c ) ans . push_back ( matrix [ r1 ][ c ]); for ( int r = r1 + 1 ; r <= r2 ; ++ r ) ans . push_back ( matrix [ r ][ c2 ]); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; -- c ) ans . push_back ( matrix [ r2 ][ c ]); for ( int r = r2 ; r > r1 ; -- r ) ans . push_back ( matrix [ r ][ c1 ]); } ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } }; 55. Jump Game $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool canJump ( vector < int >& nums ) { int goal = nums . size () - 1 ; for ( int i = goal ; i >= 0 ; -- i ) if ( i + nums [ i ] >= goal ) goal = i ; return goal == 0 ; } }; 56. Merge Intervals $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; sort ( intervals . begin (), intervals . end (), compare ); for ( vector < int >& interval : intervals ) { if ( ans . empty () || ans . back ()[ 1 ] < interval [ 0 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); } return ans ; } private : bool static compare ( const vector < int >& a , const vector < int >& b ) { return a [ 0 ] < b [ 0 ]; } }; 57. Insert Interval $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> ans ; auto it = intervals . begin (); for (; it != intervals . end (); ++ it ) if (( * it )[ 0 ] >= newInterval [ 0 ]) break ; intervals . insert ( it , newInterval ); for ( vector < int >& interval : intervals ) { if ( ans . empty () || interval [ 0 ] > ans . back ()[ 1 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); } return ans ; } }; 58. Length of Last Word $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int lengthOfLastWord ( string s ) { int ans = 0 ; int i = s . size () - 1 ; while ( i >= 0 && s [ i ] == ' ' ) -- i ; while ( i >= 0 && s [ i ] != ' ' ) { -- i ; ++ ans ; } return ans ; } }; 59. Spiral Matrix II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n )); int count = 1 ; for ( int min = 0 , max = n - min - 1 ; min < n / 2 ; ++ min , -- max ) { for ( int i = min ; i < max ; ++ i ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ][ min ] = count ++ ; } if ( n & 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } }; 60. Permutation Sequence $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getPermutation ( int n , int k ) { string ans ; vector < int > nums ( n ); vector < int > fact ( n , 1 ); for ( int i = 0 ; i < n ; ++ i ) nums [ i ] = i + 1 ; for ( int i = 1 ; i < n ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; -- k ; for ( int i = n ; i >= 1 ; -- i ) { int j = k / fact [ i - 1 ]; k %= fact [ i - 1 ]; ans . append ( to_string ( nums [ j ])); nums . erase ( nums . begin () + j ); } return ans ; } };","title":"0051-0060"},{"location":"cpp/0001-0100/0051-0060/#51-n-queens-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; vector < string > board ( n , string ( n , '.' )); vector < bool > cols ( n , false ); vector < bool > diag1 ( 2 * n - 1 , false ); vector < bool > diag2 ( 2 * n - 1 , false ); dfs ( 0 , cols , diag1 , diag2 , board , ans ); return ans ; } private : void dfs ( int y , vector < bool >& cols , vector < bool >& diag1 , vector < bool >& diag2 , vector < string >& board , vector < vector < string >>& ans ) { if ( y == cols . size ()) { ans . push_back ( board ); return ; } for ( int x = 0 ; x < cols . size (); ++ x ) { if ( ! cols [ x ] && ! diag1 [ x + y ] && ! diag2 [ x - y + cols . size () - 1 ]) { board [ y ][ x ] = 'Q' ; cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = true ; dfs ( y + 1 , cols , diag1 , diag2 , board , ans ); cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = false ; board [ y ][ x ] = '.' ; } } } };","title":"51. N-Queens $\\star\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#52-n-queens-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; vector < bool > cols ( n , false ); vector < bool > diag1 ( 2 * n - 1 , false ); vector < bool > diag2 ( 2 * n - 1 , false ); dfs ( 0 , cols , diag1 , diag2 , ans ); return ans ; } private : void dfs ( int y , vector < bool >& cols , vector < bool >& diag1 , vector < bool >& diag2 , int & ans ) { if ( y == cols . size ()) { ++ ans ; return ; } for ( int x = 0 ; x < cols . size (); ++ x ) { if ( ! cols [ x ] && ! diag1 [ x + y ] && ! diag2 [ x - y + cols . size () - 1 ]) { cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = true ; dfs ( y + 1 , cols , diag1 , diag2 , ans ); cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = false ; } } } };","title":"52. N-Queens II $\\star\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#53-maximum-subarray-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxSubArray ( vector < int >& nums ) { int ans = INT_MIN ; int sum = 0 ; for ( int num : nums ) { sum += num ; ans = max ( ans , sum ); sum = max ( sum , 0 ); } return ans ; } };","title":"53. Maximum Subarray $\\star$"},{"location":"cpp/0001-0100/0051-0060/#54-spiral-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; vector < int > ans ; int r1 = 0 ; int c1 = 0 ; int r2 = matrix . size () - 1 ; int c2 = matrix [ 0 ]. size () - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; ++ c ) ans . push_back ( matrix [ r1 ][ c ]); for ( int r = r1 + 1 ; r <= r2 ; ++ r ) ans . push_back ( matrix [ r ][ c2 ]); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; -- c ) ans . push_back ( matrix [ r2 ][ c ]); for ( int r = r2 ; r > r1 ; -- r ) ans . push_back ( matrix [ r ][ c1 ]); } ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } };","title":"54. Spiral Matrix $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#55-jump-game-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool canJump ( vector < int >& nums ) { int goal = nums . size () - 1 ; for ( int i = goal ; i >= 0 ; -- i ) if ( i + nums [ i ] >= goal ) goal = i ; return goal == 0 ; } };","title":"55. Jump Game $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#56-merge-intervals-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; sort ( intervals . begin (), intervals . end (), compare ); for ( vector < int >& interval : intervals ) { if ( ans . empty () || ans . back ()[ 1 ] < interval [ 0 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); } return ans ; } private : bool static compare ( const vector < int >& a , const vector < int >& b ) { return a [ 0 ] < b [ 0 ]; } };","title":"56. Merge Intervals $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#57-insert-interval-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> ans ; auto it = intervals . begin (); for (; it != intervals . end (); ++ it ) if (( * it )[ 0 ] >= newInterval [ 0 ]) break ; intervals . insert ( it , newInterval ); for ( vector < int >& interval : intervals ) { if ( ans . empty () || interval [ 0 ] > ans . back ()[ 1 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); } return ans ; } };","title":"57. Insert Interval $\\star\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#58-length-of-last-word-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int lengthOfLastWord ( string s ) { int ans = 0 ; int i = s . size () - 1 ; while ( i >= 0 && s [ i ] == ' ' ) -- i ; while ( i >= 0 && s [ i ] != ' ' ) { -- i ; ++ ans ; } return ans ; } };","title":"58. Length of Last Word $\\star$"},{"location":"cpp/0001-0100/0051-0060/#59-spiral-matrix-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n )); int count = 1 ; for ( int min = 0 , max = n - min - 1 ; min < n / 2 ; ++ min , -- max ) { for ( int i = min ; i < max ; ++ i ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ][ min ] = count ++ ; } if ( n & 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } };","title":"59. Spiral Matrix II $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#60-permutation-sequence-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getPermutation ( int n , int k ) { string ans ; vector < int > nums ( n ); vector < int > fact ( n , 1 ); for ( int i = 0 ; i < n ; ++ i ) nums [ i ] = i + 1 ; for ( int i = 1 ; i < n ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; -- k ; for ( int i = n ; i >= 1 ; -- i ) { int j = k / fact [ i - 1 ]; k %= fact [ i - 1 ]; ans . append ( to_string ( nums [ j ])); nums . erase ( nums . begin () + j ); } return ans ; } };","title":"60. Permutation Sequence $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/","text":"61. Rotate List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( ! head || ! head -> next || k == 0 ) return head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; k %= length ; if ( k == 0 ) return head ; auto slow = head ; auto fast = head ; while ( k -- ) fast = fast -> next ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next ; } auto ans = slow -> next ; slow -> next = NULL ; fast -> next = head ; return ans ; } }; 62. Unique Paths $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int uniquePaths ( int m , int n ) { vector < int > dp ( n , 1 ); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ j ] += dp [ j - 1 ]; return dp [ n - 1 ]; } }; 63. Unique Paths II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int uniquePathsWithObstacles ( vector < vector < int >>& obstacleGrid ) { const int m = obstacleGrid . size (); const int n = obstacleGrid [ 0 ]. size (); vector < long > dp ( n , 0 ); dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( obstacleGrid [ i ][ j ]) dp [ j ] = 0 ; else if ( j > 0 ) dp [ j ] += dp [ j - 1 ]; } return dp [ n - 1 ]; } }; 64. Minimum Path Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int minPathSum ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); for ( int i = 1 ; i < m ; ++ i ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ]; for ( int j = 1 ; j < n ; ++ j ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ]; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]); return grid [ m - 1 ][ n - 1 ]; } }; 65. Valid Number $\\star\\star\\star$ 66. Plus One $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > plusOne ( vector < int >& digits ) { const int n = digits . size (); for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( digits [ i ] < 9 ) { ++ digits [ i ]; return digits ; } digits [ i ] = 0 ; } vector < int > ans ( n + 1 ); ans [ 0 ] = 1 ; return ans ; } }; 67. Add Binary $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string addBinary ( string a , string b ) { string ans ; int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( i >= 0 || j >= 0 || carry == 1 ) { if ( i >= 0 ) carry += a [ i -- ] - '0' ; if ( j >= 0 ) carry += b [ j -- ] - '0' ; ans = char ( carry % 2 + '0' ) + ans ; carry >>= 1 ; } return ans ; } }; 68. Text Justification $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < string > fullJustify ( vector < string >& words , int maxWidth ) { vector < string > ans ; vector < string > curr ; int numOfLetters = 0 ; for ( string & word : words ) { if ( numOfLetters + ( int ) curr . size () + ( int ) word . length () > maxWidth ) { for ( int i = 0 ; i < maxWidth - numOfLetters ; ++ i ) { curr . size () - 1 == 0 ? curr [ 0 ]. append ( \" \" ) : curr [ i % ( curr . size () - 1 )]. append ( \" \" ); } ans . push_back ( join ( curr , \"\" )); curr . clear (); numOfLetters = 0 ; } curr . push_back ( word ); numOfLetters += word . length (); } ans . push_back ( ljust ( join ( curr , \" \" ), maxWidth )); return ans ; } private : string join ( vector < string >& v , string c ) { string s ; for ( auto p = v . begin (); p != v . end (); ++ p ) { s += * p ; if ( p != v . end () - 1 ) s += c ; } return s ; } string ljust ( string s , int width ) { for ( int i = 0 ; i < s . length () - width ; ++ i ) s += \" \" ; return s ; } }; 69. Sqrt(x) $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int mySqrt ( int x ) { unsigned l = 1 ; unsigned r = x + 1u ; while ( l < r ) { unsigned m = ( l + r ) >> 1 ; if ( m > x / m ) r = m ; else l = m + 1 ; } return l - 1 ; } }; 70. Climbing Stairs $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int climbStairs ( int n ) { if ( n == 1 ) return 1 ; vector < int > dp ( n + 1 ); dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; ++ i ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]; return dp [ n ]; } };","title":"0061-0070"},{"location":"cpp/0001-0100/0061-0070/#61-rotate-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( ! head || ! head -> next || k == 0 ) return head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; k %= length ; if ( k == 0 ) return head ; auto slow = head ; auto fast = head ; while ( k -- ) fast = fast -> next ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next ; } auto ans = slow -> next ; slow -> next = NULL ; fast -> next = head ; return ans ; } };","title":"61. Rotate List $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#62-unique-paths-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int uniquePaths ( int m , int n ) { vector < int > dp ( n , 1 ); for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) dp [ j ] += dp [ j - 1 ]; return dp [ n - 1 ]; } };","title":"62. Unique Paths $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#63-unique-paths-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int uniquePathsWithObstacles ( vector < vector < int >>& obstacleGrid ) { const int m = obstacleGrid . size (); const int n = obstacleGrid [ 0 ]. size (); vector < long > dp ( n , 0 ); dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( obstacleGrid [ i ][ j ]) dp [ j ] = 0 ; else if ( j > 0 ) dp [ j ] += dp [ j - 1 ]; } return dp [ n - 1 ]; } };","title":"63. Unique Paths II $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#64-minimum-path-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int minPathSum ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); for ( int i = 1 ; i < m ; ++ i ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ]; for ( int j = 1 ; j < n ; ++ j ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ]; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]); return grid [ m - 1 ][ n - 1 ]; } };","title":"64. Minimum Path Sum $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#65-valid-number-starstarstar","text":"","title":"65. Valid Number $\\star\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#66-plus-one-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > plusOne ( vector < int >& digits ) { const int n = digits . size (); for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( digits [ i ] < 9 ) { ++ digits [ i ]; return digits ; } digits [ i ] = 0 ; } vector < int > ans ( n + 1 ); ans [ 0 ] = 1 ; return ans ; } };","title":"66. Plus One $\\star$"},{"location":"cpp/0001-0100/0061-0070/#67-add-binary-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string addBinary ( string a , string b ) { string ans ; int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( i >= 0 || j >= 0 || carry == 1 ) { if ( i >= 0 ) carry += a [ i -- ] - '0' ; if ( j >= 0 ) carry += b [ j -- ] - '0' ; ans = char ( carry % 2 + '0' ) + ans ; carry >>= 1 ; } return ans ; } };","title":"67. Add Binary $\\star$"},{"location":"cpp/0001-0100/0061-0070/#68-text-justification-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < string > fullJustify ( vector < string >& words , int maxWidth ) { vector < string > ans ; vector < string > curr ; int numOfLetters = 0 ; for ( string & word : words ) { if ( numOfLetters + ( int ) curr . size () + ( int ) word . length () > maxWidth ) { for ( int i = 0 ; i < maxWidth - numOfLetters ; ++ i ) { curr . size () - 1 == 0 ? curr [ 0 ]. append ( \" \" ) : curr [ i % ( curr . size () - 1 )]. append ( \" \" ); } ans . push_back ( join ( curr , \"\" )); curr . clear (); numOfLetters = 0 ; } curr . push_back ( word ); numOfLetters += word . length (); } ans . push_back ( ljust ( join ( curr , \" \" ), maxWidth )); return ans ; } private : string join ( vector < string >& v , string c ) { string s ; for ( auto p = v . begin (); p != v . end (); ++ p ) { s += * p ; if ( p != v . end () - 1 ) s += c ; } return s ; } string ljust ( string s , int width ) { for ( int i = 0 ; i < s . length () - width ; ++ i ) s += \" \" ; return s ; } };","title":"68. Text Justification $\\star\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#69-sqrtx-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int mySqrt ( int x ) { unsigned l = 1 ; unsigned r = x + 1u ; while ( l < r ) { unsigned m = ( l + r ) >> 1 ; if ( m > x / m ) r = m ; else l = m + 1 ; } return l - 1 ; } };","title":"69. Sqrt(x) $\\star$"},{"location":"cpp/0001-0100/0061-0070/#70-climbing-stairs-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int climbStairs ( int n ) { if ( n == 1 ) return 1 ; vector < int > dp ( n + 1 ); dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; ++ i ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]; return dp [ n ]; } };","title":"70. Climbing Stairs $\\star$"},{"location":"cpp/0001-0100/0071-0080/","text":"71. Simplify Path $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string simplifyPath ( string path ) { string ans ; string temp ; stringstream ss ( path ); vector < string > stack ; while ( getline ( ss , temp , '/' )) { if ( temp == \"\" || temp == \".\" ) continue ; if ( temp == \"..\" ) { if ( ! stack . empty ()) stack . pop_back (); } else { stack . push_back ( temp ); } } for ( auto str : stack ) ans += \"/\" + str ; return ans . empty () ? \"/\" : ans ; } }; 72. Edit Distance $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int minDistance ( string word1 , string word2 ) { const int m = word1 . length (); const int n = word2 . length (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) { if ( i == 0 ) dp [ i ][ j ] = j ; else if ( j == 0 ) dp [ i ][ j ] = i ; else dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ] + ( word1 [ i - 1 ] == word2 [ j - 1 ] ? 0 : 1 ), min ( dp [ i - 1 ][ j ] + 1 , dp [ i ][ j - 1 ] + 1 )); } return dp [ m ][ n ]; } }; 73. Set Matrix Zeroes $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); bool isFirstRow = false ; bool isFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ][ j ] == 0 ) isFirstRow = true ; for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ][ 0 ] == 0 ) isFirstCol = true ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( isFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ][ j ] = 0 ; if ( isFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ][ 0 ] = 0 ; } }; 74. Search a 2D Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int l = 0 ; int r = m * n ; while ( l < r ) { int mid = l + ( r - l ) / 2 ; int i = mid / n ; int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } }; 75. Sort Colors $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void sortColors ( vector < int >& nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( int num : nums ) { if ( num == 0 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; nums [ ++ zero ] = 0 ; } else if ( num == 1 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; } else { nums [ ++ two ] = 2 ; } } } }; 76. Minimum Window Substring $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : string minWindow ( string s , string t ) { if ( s . empty () || t . empty ()) return \"\" ; unordered_map < char , int > map ; for ( char c : t ) ++ map [ c ]; int l = 0 ; int r = 0 ; int bestLeft = 0 ; int bestRight = 0 ; int required = map . size (); int windowLength = s . length () + 1 ; for ( int r = 0 ; r < s . length (); ++ r ) { if ( map . count ( s [ r ])) if ( -- map [ s [ r ]] == 0 ) -- required ; while ( required == 0 && l <= r ) { if ( r - l + 1 < windowLength ) { windowLength = r - l + 1 ; bestLeft = l ; bestRight = r ; } if ( map . count ( s [ l ])) if ( ++ map [ s [ l ]] > 0 ) ++ required ; ++ l ; } } return windowLength == s . length () + 1 ? \"\" : s . substr ( bestLeft , windowLength ); } }; 77. Combinations $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; vector < int > path ; dfs ( n , k , 1 , path , ans ); return ans ; } private : void dfs ( int n , int k , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( k == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i <= n ; ++ i ) { path . push_back ( i ); dfs ( n , k - 1 , i + 1 , path , ans ); path . pop_back (); } } }; 78. Subsets $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { ans . push_back ( path ); if ( s == nums . size ()) return ; for ( int i = s ; i < nums . size (); ++ i ) { path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } }; 79. Word Search $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { if ( board . empty ()) return false ; for ( int i = 0 ; i < board . size (); ++ i ) for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) if ( dfs ( board , word , i , j , 0 )) return true ; return false ; } private : bool dfs ( vector < vector < char >>& board , string & word , int i , int j , int pos ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] != word [ pos ] || board [ i ][ j ] == '*' ) return false ; if ( pos == word . length () - 1 ) return true ; char c = board [ i ][ j ]; board [ i ][ j ] = '*' ; bool flag = dfs ( board , word , i + 1 , j , pos + 1 ) || dfs ( board , word , i - 1 , j , pos + 1 ) || dfs ( board , word , i , j + 1 , pos + 1 ) || dfs ( board , word , i , j - 1 , pos + 1 ); board [ i ][ j ] = c ; return flag ; } }; 80. Remove Duplicates from Sorted Array II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( int num : nums ) if ( i < 2 || num != nums [ i - 2 ]) nums [ i ++ ] = num ; return i ; } };","title":"0071-0080"},{"location":"cpp/0001-0100/0071-0080/#71-simplify-path-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string simplifyPath ( string path ) { string ans ; string temp ; stringstream ss ( path ); vector < string > stack ; while ( getline ( ss , temp , '/' )) { if ( temp == \"\" || temp == \".\" ) continue ; if ( temp == \"..\" ) { if ( ! stack . empty ()) stack . pop_back (); } else { stack . push_back ( temp ); } } for ( auto str : stack ) ans += \"/\" + str ; return ans . empty () ? \"/\" : ans ; } };","title":"71. Simplify Path $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#72-edit-distance-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int minDistance ( string word1 , string word2 ) { const int m = word1 . length (); const int n = word2 . length (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) { if ( i == 0 ) dp [ i ][ j ] = j ; else if ( j == 0 ) dp [ i ][ j ] = i ; else dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ] + ( word1 [ i - 1 ] == word2 [ j - 1 ] ? 0 : 1 ), min ( dp [ i - 1 ][ j ] + 1 , dp [ i ][ j - 1 ] + 1 )); } return dp [ m ][ n ]; } };","title":"72. Edit Distance $\\star\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#73-set-matrix-zeroes-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); bool isFirstRow = false ; bool isFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ][ j ] == 0 ) isFirstRow = true ; for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ][ 0 ] == 0 ) isFirstCol = true ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( isFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ][ j ] = 0 ; if ( isFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ][ 0 ] = 0 ; } };","title":"73. Set Matrix Zeroes $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#74-search-a-2d-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int l = 0 ; int r = m * n ; while ( l < r ) { int mid = l + ( r - l ) / 2 ; int i = mid / n ; int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } };","title":"74. Search a 2D Matrix $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#75-sort-colors-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void sortColors ( vector < int >& nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( int num : nums ) { if ( num == 0 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; nums [ ++ zero ] = 0 ; } else if ( num == 1 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; } else { nums [ ++ two ] = 2 ; } } } };","title":"75. Sort Colors $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#76-minimum-window-substring-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : string minWindow ( string s , string t ) { if ( s . empty () || t . empty ()) return \"\" ; unordered_map < char , int > map ; for ( char c : t ) ++ map [ c ]; int l = 0 ; int r = 0 ; int bestLeft = 0 ; int bestRight = 0 ; int required = map . size (); int windowLength = s . length () + 1 ; for ( int r = 0 ; r < s . length (); ++ r ) { if ( map . count ( s [ r ])) if ( -- map [ s [ r ]] == 0 ) -- required ; while ( required == 0 && l <= r ) { if ( r - l + 1 < windowLength ) { windowLength = r - l + 1 ; bestLeft = l ; bestRight = r ; } if ( map . count ( s [ l ])) if ( ++ map [ s [ l ]] > 0 ) ++ required ; ++ l ; } } return windowLength == s . length () + 1 ? \"\" : s . substr ( bestLeft , windowLength ); } };","title":"76. Minimum Window Substring $\\star\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#77-combinations-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; vector < int > path ; dfs ( n , k , 1 , path , ans ); return ans ; } private : void dfs ( int n , int k , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( k == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i <= n ; ++ i ) { path . push_back ( i ); dfs ( n , k - 1 , i + 1 , path , ans ); path . pop_back (); } } };","title":"77. Combinations $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#78-subsets-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { ans . push_back ( path ); if ( s == nums . size ()) return ; for ( int i = s ; i < nums . size (); ++ i ) { path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } };","title":"78. Subsets $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#79-word-search-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { if ( board . empty ()) return false ; for ( int i = 0 ; i < board . size (); ++ i ) for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) if ( dfs ( board , word , i , j , 0 )) return true ; return false ; } private : bool dfs ( vector < vector < char >>& board , string & word , int i , int j , int pos ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] != word [ pos ] || board [ i ][ j ] == '*' ) return false ; if ( pos == word . length () - 1 ) return true ; char c = board [ i ][ j ]; board [ i ][ j ] = '*' ; bool flag = dfs ( board , word , i + 1 , j , pos + 1 ) || dfs ( board , word , i - 1 , j , pos + 1 ) || dfs ( board , word , i , j + 1 , pos + 1 ) || dfs ( board , word , i , j - 1 , pos + 1 ); board [ i ][ j ] = c ; return flag ; } };","title":"79. Word Search $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#80-remove-duplicates-from-sorted-array-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( int num : nums ) if ( i < 2 || num != nums [ i - 2 ]) nums [ i ++ ] = num ; return i ; } };","title":"80. Remove Duplicates from Sorted Array II $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/","text":"81. Search in Rotated Sorted Array II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ]) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return false ; } }; 82. Remove Duplicates from Sorted List II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; while ( head ) { while ( head -> next && head -> val == head -> next -> val ) head = head -> next ; if ( prev -> next == head ) prev = prev -> next ; else prev -> next = head -> next ; head = head -> next ; } return dummy . next ; } }; 83. Remove Duplicates from Sorted List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode * curr = head ; while ( curr ) { while ( curr -> next && curr -> val == curr -> next -> val ) curr -> next = curr -> next -> next ; curr = curr -> next ; } return head ; } }; 84. Largest Rectangle in Histogram $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ i ] < heights [ stack . top ()])) { int h = heights [ stack . top ()]; stack . pop (); int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } }; 85. Maximal Rectangle $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; int ans = 0 ; vector < int > temp ( matrix [ 0 ]. size ()); for ( int i = 0 ; i < matrix . size (); ++ i ) { for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) temp [ j ] = matrix [ i ][ j ] == '0' ? 0 : temp [ j ] + 1 ; ans = max ( ans , largestRectangleArea ( temp )); } return ans ; } private : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ i ] < heights [ stack . top ()])) { int h = heights [ stack . top ()]; stack . pop (); int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } }; 86. Partition List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode beforeHead ( 0 ); ListNode afterHead ( 0 ); ListNode * before = & beforeHead ; ListNode * after = & afterHead ; while ( head ) { if ( head -> val < x ) { before -> next = head ; before = before -> next ; } else { after -> next = head ; after = after -> next ; } head = head -> next ; } after -> next = NULL ; before -> next = afterHead . next ; return beforeHead . next ; }; }; 87. Scramble String $\\star\\star\\star$ 88. Merge Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int k = m + n ; while ( n > 0 ) { if ( m > 0 && nums1 [ m - 1 ] > nums2 [ n - 1 ]) nums1 [ -- k ] = nums1 [ -- m ]; else nums1 [ -- k ] = nums2 [ -- n ]; } } }; 89. Gray Code $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > grayCode ( int n ) { vector < int > ans = { 0 }; for ( int i = 0 ; i < n ; ++ i ) for ( int j = ans . size () - 1 ; j >= 0 ; -- j ) ans . push_back ( ans [ j ] | 1 << i ); return ans ; } }; 90. Subsets II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; sort ( nums . begin (), nums . end ()); dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { ans . push_back ( path ); if ( s == nums . size ()) return ; for ( int i = s ; i < nums . size (); ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } };","title":"0081-0090"},{"location":"cpp/0001-0100/0081-0090/#81-search-in-rotated-sorted-array-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ]) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return false ; } };","title":"81. Search in Rotated Sorted Array II $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#82-remove-duplicates-from-sorted-list-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; while ( head ) { while ( head -> next && head -> val == head -> next -> val ) head = head -> next ; if ( prev -> next == head ) prev = prev -> next ; else prev -> next = head -> next ; head = head -> next ; } return dummy . next ; } };","title":"82. Remove Duplicates from Sorted List II $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#83-remove-duplicates-from-sorted-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode * curr = head ; while ( curr ) { while ( curr -> next && curr -> val == curr -> next -> val ) curr -> next = curr -> next -> next ; curr = curr -> next ; } return head ; } };","title":"83. Remove Duplicates from Sorted List $\\star$"},{"location":"cpp/0001-0100/0081-0090/#84-largest-rectangle-in-histogram-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ i ] < heights [ stack . top ()])) { int h = heights [ stack . top ()]; stack . pop (); int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } };","title":"84. Largest Rectangle in Histogram $\\star\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#85-maximal-rectangle-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; int ans = 0 ; vector < int > temp ( matrix [ 0 ]. size ()); for ( int i = 0 ; i < matrix . size (); ++ i ) { for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) temp [ j ] = matrix [ i ][ j ] == '0' ? 0 : temp [ j ] + 1 ; ans = max ( ans , largestRectangleArea ( temp )); } return ans ; } private : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ i ] < heights [ stack . top ()])) { int h = heights [ stack . top ()]; stack . pop (); int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } };","title":"85. Maximal Rectangle $\\star\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#86-partition-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode beforeHead ( 0 ); ListNode afterHead ( 0 ); ListNode * before = & beforeHead ; ListNode * after = & afterHead ; while ( head ) { if ( head -> val < x ) { before -> next = head ; before = before -> next ; } else { after -> next = head ; after = after -> next ; } head = head -> next ; } after -> next = NULL ; before -> next = afterHead . next ; return beforeHead . next ; }; };","title":"86. Partition List $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#87-scramble-string-starstarstar","text":"","title":"87. Scramble String $\\star\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#88-merge-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int k = m + n ; while ( n > 0 ) { if ( m > 0 && nums1 [ m - 1 ] > nums2 [ n - 1 ]) nums1 [ -- k ] = nums1 [ -- m ]; else nums1 [ -- k ] = nums2 [ -- n ]; } } };","title":"88. Merge Sorted Array $\\star$"},{"location":"cpp/0001-0100/0081-0090/#89-gray-code-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > grayCode ( int n ) { vector < int > ans = { 0 }; for ( int i = 0 ; i < n ; ++ i ) for ( int j = ans . size () - 1 ; j >= 0 ; -- j ) ans . push_back ( ans [ j ] | 1 << i ); return ans ; } };","title":"89. Gray Code $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#90-subsets-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; sort ( nums . begin (), nums . end ()); dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { ans . push_back ( path ); if ( s == nums . size ()) return ; for ( int i = s ; i < nums . size (); ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } };","title":"90. Subsets II $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/","text":"91. Decode Ways $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int numDecodings ( string s ) { if ( s . empty () || s [ 0 ] == '0' ) return 0 ; if ( s . length () == 1 ) return 1 ; int dp1 = 1 ; int dp2 = 1 ; for ( int i = 1 ; i < s . length (); ++ i ) { int dp = 0 ; if ( ! isValid ( s [ i ]) && ! isValid ( s [ i - 1 ], s [ i ])) return 0 ; if ( isValid ( s [ i ])) dp += dp1 ; if ( isValid ( s [ i - 1 ], s [ i ])) dp += dp2 ; dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : bool isValid ( char c ) { return c != '0' ; } bool isValid ( char c1 , char c2 ) { return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } }; 92. Reverse Linked List II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { if ( ! head ) return NULL ; ListNode * prev = NULL ; ListNode * curr = head ; for ( int i = 0 ; i < m - 1 ; ++ i ) { prev = curr ; curr = curr -> next ; } ListNode * conn = prev ; ListNode * tail = curr ; for ( int i = 0 ; i < n - m + 1 ; ++ i ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } if ( conn ) conn -> next = prev ; else head = prev ; tail -> next = curr ; return head ; } }; 93. Restore IP Addresses $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < string > restoreIpAddresses ( string s ) { vector < string > ans ; vector < string > path ( 4 ); dfs ( s , 0 , 0 , path , ans ); return ans ; } void dfs ( string s , int depth , int index , vector < string >& path , vector < string >& ans ) { if ( depth == 4 && index == s . length ()) { ans . push_back ( path [ 0 ] + \".\" + path [ 1 ] + \".\" + path [ 2 ] + \".\" + path [ 3 ]); return ; } if ( depth == 4 || index == s . length ()) return ; for ( int i = 1 ; i <= 3 ; ++ i ) { if ( index + i > s . length ()) return ; if ( i > 1 && s [ index ] == '0' ) return ; string temp = s . substr ( index , i ); if ( stoi ( temp ) > 255 ) return ; path [ depth ] = temp ; dfs ( s , depth + 1 , index + i , path , ans ); path [ depth ] = \"\" ; } } }; 94. Binary Tree Inorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > ans ; stack < TreeNode *> stack ; TreeNode * curr = root ; while ( curr || ! stack . empty ()) { while ( curr ) { stack . push ( curr ); curr = curr -> left ; } curr = stack . top (); stack . pop (); ans . push_back ( curr -> val ); curr = curr -> right ; } return ans ; } }; 95. Unique Binary Search Trees II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < TreeNode *> generateTrees ( int n ) { if ( n == 0 ) return {}; return helper ( 1 , n ); } private : vector < TreeNode *> helper ( int min , int max ) { vector < TreeNode *> ans ; if ( min > max ) { ans . push_back ( NULL ); return ans ; } for ( int i = min ; i <= max ; ++ i ) { vector < TreeNode *> leftTree = helper ( min , i - 1 ); vector < TreeNode *> rightTree = helper ( i + 1 , max ); for ( TreeNode * left : leftTree ) for ( TreeNode * right : rightTree ) { TreeNode * root = new TreeNode ( i ); root -> left = left ; root -> right = right ; ans . push_back ( root ); } } return ans ; } }; 96. Unique Binary Search Trees $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int numTrees ( int n ) { vector < int > G ( n + 1 ); G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ]; return G [ n ]; } }; 97. Interleaving String $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { if ( s1 . length () + s2 . length () != s3 . length ()) return false ; vector < bool > dp ( s2 . length () + 1 ); for ( int i = 0 ; i <= s1 . length (); ++ i ) for ( int j = 0 ; j <= s2 . length (); ++ j ) { if ( i == 0 && j == 0 ) dp [ j ] = true ; else if ( i == 0 ) dp [ j ] = dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]; else if ( j == 0 ) dp [ j ] = dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]; else dp [ j ] = ( dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]) || ( dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]); } return dp [ s2 . length ()]; } }; 98. Validate Binary Search Tree $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isValidBST ( TreeNode * root ) { return helper ( root , NULL , NULL ); } private : bool helper ( TreeNode * root , TreeNode * minNode , TreeNode * maxNode ) { if ( ! root ) return true ; if ( minNode && root -> val <= minNode -> val || maxNode && root -> val >= maxNode -> val ) return false ; return helper ( root -> left , minNode , root ) && helper ( root -> right , root , maxNode ); } }; 99. Recover Binary Search Tree $\\star\\star\\star$ 100. Same Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } };","title":"0091-0100"},{"location":"cpp/0001-0100/0091-0100/#91-decode-ways-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int numDecodings ( string s ) { if ( s . empty () || s [ 0 ] == '0' ) return 0 ; if ( s . length () == 1 ) return 1 ; int dp1 = 1 ; int dp2 = 1 ; for ( int i = 1 ; i < s . length (); ++ i ) { int dp = 0 ; if ( ! isValid ( s [ i ]) && ! isValid ( s [ i - 1 ], s [ i ])) return 0 ; if ( isValid ( s [ i ])) dp += dp1 ; if ( isValid ( s [ i - 1 ], s [ i ])) dp += dp2 ; dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : bool isValid ( char c ) { return c != '0' ; } bool isValid ( char c1 , char c2 ) { return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } };","title":"91. Decode Ways $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#92-reverse-linked-list-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { if ( ! head ) return NULL ; ListNode * prev = NULL ; ListNode * curr = head ; for ( int i = 0 ; i < m - 1 ; ++ i ) { prev = curr ; curr = curr -> next ; } ListNode * conn = prev ; ListNode * tail = curr ; for ( int i = 0 ; i < n - m + 1 ; ++ i ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } if ( conn ) conn -> next = prev ; else head = prev ; tail -> next = curr ; return head ; } };","title":"92. Reverse Linked List II $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#93-restore-ip-addresses-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < string > restoreIpAddresses ( string s ) { vector < string > ans ; vector < string > path ( 4 ); dfs ( s , 0 , 0 , path , ans ); return ans ; } void dfs ( string s , int depth , int index , vector < string >& path , vector < string >& ans ) { if ( depth == 4 && index == s . length ()) { ans . push_back ( path [ 0 ] + \".\" + path [ 1 ] + \".\" + path [ 2 ] + \".\" + path [ 3 ]); return ; } if ( depth == 4 || index == s . length ()) return ; for ( int i = 1 ; i <= 3 ; ++ i ) { if ( index + i > s . length ()) return ; if ( i > 1 && s [ index ] == '0' ) return ; string temp = s . substr ( index , i ); if ( stoi ( temp ) > 255 ) return ; path [ depth ] = temp ; dfs ( s , depth + 1 , index + i , path , ans ); path [ depth ] = \"\" ; } } };","title":"93. Restore IP Addresses $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#94-binary-tree-inorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > ans ; stack < TreeNode *> stack ; TreeNode * curr = root ; while ( curr || ! stack . empty ()) { while ( curr ) { stack . push ( curr ); curr = curr -> left ; } curr = stack . top (); stack . pop (); ans . push_back ( curr -> val ); curr = curr -> right ; } return ans ; } };","title":"94. Binary Tree Inorder Traversal $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#95-unique-binary-search-trees-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < TreeNode *> generateTrees ( int n ) { if ( n == 0 ) return {}; return helper ( 1 , n ); } private : vector < TreeNode *> helper ( int min , int max ) { vector < TreeNode *> ans ; if ( min > max ) { ans . push_back ( NULL ); return ans ; } for ( int i = min ; i <= max ; ++ i ) { vector < TreeNode *> leftTree = helper ( min , i - 1 ); vector < TreeNode *> rightTree = helper ( i + 1 , max ); for ( TreeNode * left : leftTree ) for ( TreeNode * right : rightTree ) { TreeNode * root = new TreeNode ( i ); root -> left = left ; root -> right = right ; ans . push_back ( root ); } } return ans ; } };","title":"95. Unique Binary Search Trees II $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#96-unique-binary-search-trees-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int numTrees ( int n ) { vector < int > G ( n + 1 ); G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ]; return G [ n ]; } };","title":"96. Unique Binary Search Trees $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#97-interleaving-string-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { if ( s1 . length () + s2 . length () != s3 . length ()) return false ; vector < bool > dp ( s2 . length () + 1 ); for ( int i = 0 ; i <= s1 . length (); ++ i ) for ( int j = 0 ; j <= s2 . length (); ++ j ) { if ( i == 0 && j == 0 ) dp [ j ] = true ; else if ( i == 0 ) dp [ j ] = dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]; else if ( j == 0 ) dp [ j ] = dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]; else dp [ j ] = ( dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]) || ( dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]); } return dp [ s2 . length ()]; } };","title":"97. Interleaving String $\\star\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#98-validate-binary-search-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isValidBST ( TreeNode * root ) { return helper ( root , NULL , NULL ); } private : bool helper ( TreeNode * root , TreeNode * minNode , TreeNode * maxNode ) { if ( ! root ) return true ; if ( minNode && root -> val <= minNode -> val || maxNode && root -> val >= maxNode -> val ) return false ; return helper ( root -> left , minNode , root ) && helper ( root -> right , root , maxNode ); } };","title":"98. Validate Binary Search Tree $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#99-recover-binary-search-tree-starstarstar","text":"","title":"99. Recover Binary Search Tree $\\star\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#100-same-tree-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } };","title":"100. Same Tree $\\star$"},{"location":"cpp/0101-0200/0101-0110/","text":"101. Symmetric Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isSymmetric ( TreeNode * root ) { return helper ( root , root ); } private : bool helper ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && helper ( p -> left , q -> right ) && helper ( p -> right , q -> left ); } }; 102. Binary Tree Level Order Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode * node = queue . front (); queue . pop (); currLevel . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } ans . push_back ( currLevel ); } return ans ; } }; 103. Binary Tree Zigzag Level Order Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; deque < TreeNode *> deque ; deque . push_back ( root ); bool isLeftToRight = true ; while ( ! deque . empty ()) { vector < int > currLevel ; for ( int i = deque . size (); i > 0 ; -- i ) { if ( isLeftToRight ) { TreeNode * node = deque . front (); deque . pop_front (); currLevel . push_back ( node -> val ); if ( node -> left ) deque . push_back ( node -> left ); if ( node -> right ) deque . push_back ( node -> right ); } else { TreeNode * node = deque . back (); deque . pop_back (); currLevel . push_back ( node -> val ); if ( node -> right ) deque . push_front ( node -> right ); if ( node -> left ) deque . push_front ( node -> left ); } } ans . push_back ( currLevel ); isLeftToRight = ! isLeftToRight ; } return ans ; } }; 104. Maximum Depth of Binary Tree $\\star$ 1 2 3 4 5 6 7 8 class Solution { public : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } }; 105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { unordered_map < int , int > map ; for ( int i = 0 ; i < inorder . size (); ++ i ) map [ inorder [ i ]] = i ; return helper ( preorder , 0 , preorder . size () - 1 , inorder , 0 , inorder . size () - 1 , map ); } TreeNode * helper ( vector < int >& preorder , int pLeft , int pRight , vector < int >& inorder , int iLeft , int iRight , unordered_map < int , int >& map ) { if ( pLeft > pRight || iLeft > iRight ) return nullptr ; int i = map [ preorder [ pLeft ]]; TreeNode * curr = new TreeNode ( preorder [ pLeft ]); curr -> left = helper ( preorder , pLeft + 1 , pLeft + i - iLeft , inorder , iLeft , i - 1 , map ); curr -> right = helper ( preorder , pLeft + i - iLeft + 1 , pRight , inorder , i + 1 , iRight , map ); return curr ; } }; 106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { unordered_map < int , int > map ; for ( int i = 0 ; i < inorder . size (); ++ i ) map [ inorder [ i ]] = i ; return helper ( inorder , 0 , inorder . size () - 1 , postorder , 0 , postorder . size () - 1 , map ); } TreeNode * helper ( vector < int >& inorder , int iLeft , int iRight , vector < int >& postorder , int pLeft , int pRight , unordered_map < int , int >& map ) { if ( iLeft > iRight || pLeft > pRight ) return nullptr ; int i = map [ postorder [ pRight ]]; TreeNode * curr = new TreeNode ( postorder [ pRight ]); curr -> left = helper ( inorder , iLeft , i - 1 , postorder , pLeft , pLeft + i - iLeft - 1 , map ); curr -> right = helper ( inorder , i + 1 , iRight , postorder , pLeft + i - iLeft , pRight - 1 , map ); return curr ; } }; 107. Binary Tree Level Order Traversal II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> levelOrderBottom ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode * node = queue . front (); queue . pop (); currLevel . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } ans . insert ( ans . begin (), currLevel ); } return ans ; } }; 108. Convert Sorted Array to Binary Search Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : TreeNode * sortedArrayToBST ( vector < int >& nums ) { return helper ( nums , 0 , nums . size () - 1 ); } private : TreeNode * helper ( vector < int >& nums , int l , int r ) { if ( l > r ) return NULL ; int mid = ( l + r ) >> 1 ; TreeNode * root = new TreeNode ( nums [ mid ]); root -> left = helper ( nums , l , mid - 1 ); root -> right = helper ( nums , mid + 1 , r ); return root ; } }; 109. Convert Sorted List to Binary Search Tree $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : TreeNode * sortedListToBST ( ListNode * head ) { int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; this -> head = head ; return helper ( 0 , length - 1 ); } private : ListNode * head ; TreeNode * helper ( int l , int r ) { if ( l > r ) return NULL ; int mid = ( l + r ) >> 1 ; TreeNode * left = helper ( l , mid - 1 ); TreeNode * node = new TreeNode ( head -> val ); head = head -> next ; node -> left = left ; node -> right = helper ( mid + 1 , r ); return node ; } }; 110. Balanced Binary Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isBalanced ( TreeNode * root ) { if ( ! root ) return true ; return abs ( maxDepth ( root -> left ) - maxDepth ( root -> right )) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ); } private : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } };","title":"0101-0110"},{"location":"cpp/0101-0200/0101-0110/#101-symmetric-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isSymmetric ( TreeNode * root ) { return helper ( root , root ); } private : bool helper ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && helper ( p -> left , q -> right ) && helper ( p -> right , q -> left ); } };","title":"101. Symmetric Tree $\\star$"},{"location":"cpp/0101-0200/0101-0110/#102-binary-tree-level-order-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode * node = queue . front (); queue . pop (); currLevel . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } ans . push_back ( currLevel ); } return ans ; } };","title":"102. Binary Tree Level Order Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#103-binary-tree-zigzag-level-order-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; deque < TreeNode *> deque ; deque . push_back ( root ); bool isLeftToRight = true ; while ( ! deque . empty ()) { vector < int > currLevel ; for ( int i = deque . size (); i > 0 ; -- i ) { if ( isLeftToRight ) { TreeNode * node = deque . front (); deque . pop_front (); currLevel . push_back ( node -> val ); if ( node -> left ) deque . push_back ( node -> left ); if ( node -> right ) deque . push_back ( node -> right ); } else { TreeNode * node = deque . back (); deque . pop_back (); currLevel . push_back ( node -> val ); if ( node -> right ) deque . push_front ( node -> right ); if ( node -> left ) deque . push_front ( node -> left ); } } ans . push_back ( currLevel ); isLeftToRight = ! isLeftToRight ; } return ans ; } };","title":"103. Binary Tree Zigzag Level Order Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#104-maximum-depth-of-binary-tree-star","text":"1 2 3 4 5 6 7 8 class Solution { public : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } };","title":"104. Maximum Depth of Binary Tree $\\star$"},{"location":"cpp/0101-0200/0101-0110/#105-construct-binary-tree-from-preorder-and-inorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { unordered_map < int , int > map ; for ( int i = 0 ; i < inorder . size (); ++ i ) map [ inorder [ i ]] = i ; return helper ( preorder , 0 , preorder . size () - 1 , inorder , 0 , inorder . size () - 1 , map ); } TreeNode * helper ( vector < int >& preorder , int pLeft , int pRight , vector < int >& inorder , int iLeft , int iRight , unordered_map < int , int >& map ) { if ( pLeft > pRight || iLeft > iRight ) return nullptr ; int i = map [ preorder [ pLeft ]]; TreeNode * curr = new TreeNode ( preorder [ pLeft ]); curr -> left = helper ( preorder , pLeft + 1 , pLeft + i - iLeft , inorder , iLeft , i - 1 , map ); curr -> right = helper ( preorder , pLeft + i - iLeft + 1 , pRight , inorder , i + 1 , iRight , map ); return curr ; } };","title":"105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#106-construct-binary-tree-from-inorder-and-postorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { unordered_map < int , int > map ; for ( int i = 0 ; i < inorder . size (); ++ i ) map [ inorder [ i ]] = i ; return helper ( inorder , 0 , inorder . size () - 1 , postorder , 0 , postorder . size () - 1 , map ); } TreeNode * helper ( vector < int >& inorder , int iLeft , int iRight , vector < int >& postorder , int pLeft , int pRight , unordered_map < int , int >& map ) { if ( iLeft > iRight || pLeft > pRight ) return nullptr ; int i = map [ postorder [ pRight ]]; TreeNode * curr = new TreeNode ( postorder [ pRight ]); curr -> left = helper ( inorder , iLeft , i - 1 , postorder , pLeft , pLeft + i - iLeft - 1 , map ); curr -> right = helper ( inorder , i + 1 , iRight , postorder , pLeft + i - iLeft , pRight - 1 , map ); return curr ; } };","title":"106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#107-binary-tree-level-order-traversal-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> levelOrderBottom ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode * node = queue . front (); queue . pop (); currLevel . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } ans . insert ( ans . begin (), currLevel ); } return ans ; } };","title":"107. Binary Tree Level Order Traversal II $\\star$"},{"location":"cpp/0101-0200/0101-0110/#108-convert-sorted-array-to-binary-search-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : TreeNode * sortedArrayToBST ( vector < int >& nums ) { return helper ( nums , 0 , nums . size () - 1 ); } private : TreeNode * helper ( vector < int >& nums , int l , int r ) { if ( l > r ) return NULL ; int mid = ( l + r ) >> 1 ; TreeNode * root = new TreeNode ( nums [ mid ]); root -> left = helper ( nums , l , mid - 1 ); root -> right = helper ( nums , mid + 1 , r ); return root ; } };","title":"108. Convert Sorted Array to Binary Search Tree $\\star$"},{"location":"cpp/0101-0200/0101-0110/#109-convert-sorted-list-to-binary-search-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : TreeNode * sortedListToBST ( ListNode * head ) { int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; this -> head = head ; return helper ( 0 , length - 1 ); } private : ListNode * head ; TreeNode * helper ( int l , int r ) { if ( l > r ) return NULL ; int mid = ( l + r ) >> 1 ; TreeNode * left = helper ( l , mid - 1 ); TreeNode * node = new TreeNode ( head -> val ); head = head -> next ; node -> left = left ; node -> right = helper ( mid + 1 , r ); return node ; } };","title":"109. Convert Sorted List to Binary Search Tree $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#110-balanced-binary-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isBalanced ( TreeNode * root ) { if ( ! root ) return true ; return abs ( maxDepth ( root -> left ) - maxDepth ( root -> right )) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ); } private : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } };","title":"110. Balanced Binary Tree $\\star$"},{"location":"cpp/0101-0200/0111-0120/","text":"111. Minimum Depth of Binary Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { ++ ans ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode * node = queue . front (); queue . pop (); if ( ! node -> left && ! node -> right ) return ans ; if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } } return - 1 ; } }; 112. Path Sum $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; if ( root -> val == sum && ! root -> left && ! root -> right ) return true ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ); } }; 113. Path Sum II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int sum ) { vector < vector < int >> ans ; vector < int > path ; dfs ( root , sum , path , ans ); return ans ; } private : void dfs ( TreeNode * root , int sum , vector < int >& path , vector < vector < int >>& ans ) { if ( ! root ) return ; if ( sum == root -> val && ! root -> left && ! root -> right ) { path . push_back ( root -> val ); ans . push_back ( path ); path . pop_back (); return ; } path . push_back ( root -> val ); dfs ( root -> left , sum - root -> val , path , ans ); dfs ( root -> right , sum - root -> val , path , ans ); path . pop_back (); } }; 114. Flatten Binary Tree to Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : void flatten ( TreeNode * root ) { if ( ! root ) return ; flatten ( root -> right ); flatten ( root -> left ); root -> right = next ; root -> left = NULL ; next = root ; } private : TreeNode * next = NULL ; }; 115. Distinct Subsequences $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int numDistinct ( string s , string t ) { const int m = s . length (); const int n = t . length (); vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) { if ( j == 0 ) dp [ i ][ j ] = 1 ; else if ( i == 0 ) dp [ i ][ j ] = 0 ; else dp [ i ][ j ] = dp [ i - 1 ][ j ] + ( s [ i - 1 ] == t [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] : 0 ); } return dp [ m ][ n ]; } }; 116. Populating Next Right Pointers in Each Node $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; while ( node && node -> left ) { Node * next = node -> left ; while ( node ) { node -> left -> next = node -> right ; node -> right -> next = node -> next ? node -> next -> left : NULL ; node = node -> next ; } node = next ; } return root ; } }; 117. Populating Next Right Pointers in Each Node II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; Node * curr = new Node ( NULL ); Node * prev = curr ; while ( node ) { while ( node ) { curr -> next = node -> left ; if ( curr -> next ) curr = curr -> next ; curr -> next = node -> right ; if ( curr -> next ) curr = curr -> next ; node = node -> next ; } node = prev -> next ; curr = prev ; } return root ; } }; 118. Pascal's Triangle $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> ans ; for ( int i = 0 ; i < numRows ; ++ i ) ans . push_back ( vector < int > ( i + 1 , 1 )); for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans [ i ]. size () - 1 ; ++ j ) ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ]; return ans ; } }; 119. Pascal's Triangle II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > ans ( rowIndex + 1 , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ]; return ans ; } }; 120. Triangle $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int minimumTotal ( vector < vector < int >>& triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]); return triangle [ 0 ][ 0 ]; } };","title":"0111-0120"},{"location":"cpp/0101-0200/0111-0120/#111-minimum-depth-of-binary-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { ++ ans ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode * node = queue . front (); queue . pop (); if ( ! node -> left && ! node -> right ) return ans ; if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } } return - 1 ; } };","title":"111. Minimum Depth of Binary Tree $\\star$"},{"location":"cpp/0101-0200/0111-0120/#112-path-sum-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; if ( root -> val == sum && ! root -> left && ! root -> right ) return true ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ); } };","title":"112. Path Sum $\\star$"},{"location":"cpp/0101-0200/0111-0120/#113-path-sum-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int sum ) { vector < vector < int >> ans ; vector < int > path ; dfs ( root , sum , path , ans ); return ans ; } private : void dfs ( TreeNode * root , int sum , vector < int >& path , vector < vector < int >>& ans ) { if ( ! root ) return ; if ( sum == root -> val && ! root -> left && ! root -> right ) { path . push_back ( root -> val ); ans . push_back ( path ); path . pop_back (); return ; } path . push_back ( root -> val ); dfs ( root -> left , sum - root -> val , path , ans ); dfs ( root -> right , sum - root -> val , path , ans ); path . pop_back (); } };","title":"113. Path Sum II $\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#114-flatten-binary-tree-to-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : void flatten ( TreeNode * root ) { if ( ! root ) return ; flatten ( root -> right ); flatten ( root -> left ); root -> right = next ; root -> left = NULL ; next = root ; } private : TreeNode * next = NULL ; };","title":"114. Flatten Binary Tree to Linked List $\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#115-distinct-subsequences-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int numDistinct ( string s , string t ) { const int m = s . length (); const int n = t . length (); vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) { if ( j == 0 ) dp [ i ][ j ] = 1 ; else if ( i == 0 ) dp [ i ][ j ] = 0 ; else dp [ i ][ j ] = dp [ i - 1 ][ j ] + ( s [ i - 1 ] == t [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] : 0 ); } return dp [ m ][ n ]; } };","title":"115. Distinct Subsequences $\\star\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#116-populating-next-right-pointers-in-each-node-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; while ( node && node -> left ) { Node * next = node -> left ; while ( node ) { node -> left -> next = node -> right ; node -> right -> next = node -> next ? node -> next -> left : NULL ; node = node -> next ; } node = next ; } return root ; } };","title":"116. Populating Next Right Pointers in Each Node $\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#117-populating-next-right-pointers-in-each-node-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; Node * curr = new Node ( NULL ); Node * prev = curr ; while ( node ) { while ( node ) { curr -> next = node -> left ; if ( curr -> next ) curr = curr -> next ; curr -> next = node -> right ; if ( curr -> next ) curr = curr -> next ; node = node -> next ; } node = prev -> next ; curr = prev ; } return root ; } };","title":"117. Populating Next Right Pointers in Each Node II $\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#118-pascals-triangle-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> ans ; for ( int i = 0 ; i < numRows ; ++ i ) ans . push_back ( vector < int > ( i + 1 , 1 )); for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans [ i ]. size () - 1 ; ++ j ) ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ]; return ans ; } };","title":"118. Pascal's Triangle $\\star$"},{"location":"cpp/0101-0200/0111-0120/#119-pascals-triangle-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > ans ( rowIndex + 1 , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ]; return ans ; } };","title":"119. Pascal's Triangle II $\\star$"},{"location":"cpp/0101-0200/0111-0120/#120-triangle-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int minimumTotal ( vector < vector < int >>& triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]); return triangle [ 0 ][ 0 ]; } };","title":"120. Triangle $\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/","text":"121. Best Time to Buy and Sell Stock $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellOne = 0 ; int holdOne = INT_MIN ; for ( int price : prices ) { sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellOne ; } }; 122. Best Time to Buy and Sell Stock II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } }; 123. Best Time to Buy and Sell Stock III $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellTwo = 0 ; int holdTwo = INT_MIN ; int sellOne = 0 ; int holdOne = INT_MIN ; for ( int price : prices ) { sellTwo = max ( sellTwo , holdTwo + price ); holdTwo = max ( holdTwo , sellOne - price ); sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellTwo ; } }; 124. Binary Tree Maximum Path Sum $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int maxPathSum ( TreeNode * root ) { helper ( root ); return ans ; } private : int ans = INT_MIN ; int helper ( TreeNode * root ) { if ( ! root ) return 0 ; int left = max ( helper ( root -> left ), 0 ); int right = max ( helper ( root -> right ), 0 ); ans = max ( ans , root -> val + left + right ); return root -> val + max ( left , right ); } }; 125. Valid Palindrome $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isPalindrome ( string s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! isalnum ( s [ l ])) ++ l ; while ( l < r && ! isalnum ( s [ r ])) -- r ; if ( tolower ( s [ l ]) != tolower ( s [ r ])) return false ; ++ l ; -- r ; } return true ; } }; 126. Word Ladder II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> ans ; unordered_set < string > set ( wordList . begin (), wordList . end ()); if ( ! set . count ( endWord )) return ans ; unordered_set < string > set1 = { beginWord }; unordered_map < string , vector < string >> map ; bool isFound = false ; while ( ! set1 . empty () && ! isFound ) { for ( const string & word : set1 ) set . erase ( word ); unordered_set < string > tempSet ; for ( const string & parent : set1 ) { string word = parent ; for ( int i = 0 ; i < word . length (); ++ i ) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; ++ j ) { word [ i ] = j ; if ( word == endWord ) { map [ parent ]. push_back ( word ); isFound = true ; } else if ( set . count ( word ) && ! isFound ) { tempSet . insert ( word ); map [ parent ]. push_back ( word ); } } word [ i ] = c ; } } swap ( set1 , tempSet ); } if ( isFound ) { vector < string > path = { beginWord }; dfs ( map , beginWord , endWord , path , ans ); } return ans ; } private : void dfs ( const unordered_map < string , vector < string >>& map , const string & word , const string & endWord , vector < string >& path , vector < vector < string >>& ans ) { if ( word == endWord ) { ans . push_back ( path ); return ; } if ( map . find ( word ) == map . cend ()) return ; for ( const string & child : map . at ( word )) { path . push_back ( child ); dfs ( map , child , endWord , path , ans ); path . pop_back (); } } }; 127. Word Ladder $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > set ( wordList . begin (), wordList . end ()); if ( ! set . count ( endWord )) return 0 ; int ans = 0 ; unordered_set < string > set1 = { beginWord }; unordered_set < string > set2 = { endWord }; while ( ! set1 . empty () && ! set2 . empty ()) { ++ ans ; if ( set1 . size () > set2 . size ()) swap ( set1 , set2 ); unordered_set < string > tempSet ; for ( string word : set1 ) for ( int i = 0 ; i < word . length (); ++ i ) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; ++ j ) { word [ i ] = j ; if ( set2 . count ( word )) return ans + 1 ; if ( ! set . count ( word )) continue ; set . erase ( word ); tempSet . insert ( word ); } word [ i ] = c ; } swap ( set1 , tempSet ); } return 0 ; } }; 128. Longest Consecutive Sequence $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int longestConsecutive ( vector < int >& nums ) { int ans = 0 ; unordered_set < int > set ( nums . begin (), nums . end ()); for ( long num : nums ) if ( ! set . count ( num - 1 )) { int length = 0 ; while ( set . count ( num ++ )) ++ length ; ans = max ( ans , length ); } return ans ; } }; 129. Sum Root to Leaf Numbers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int sumNumbers ( TreeNode * root ) { int ans = 0 ; int path = 0 ; dfs ( root , path , ans ); return ans ; } private : void dfs ( TreeNode * root , int & path , int & ans ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { path = path * 10 + root -> val ; ans += path ; path = ( path - root -> val ) / 10 ; return ; } path = path * 10 + root -> val ; dfs ( root -> left , path , ans ); dfs ( root -> right , path , ans ); path = ( path - root -> val ) / 10 ; } }; 130. Surrounded Regions $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : void solve ( vector < vector < char >>& board ) { if ( board . empty ()) return ; const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) { dfs ( board , i , 0 ); dfs ( board , i , n - 1 ); } for ( int j = 1 ; j < n - 1 ; ++ j ) { dfs ( board , 0 , j ); dfs ( board , m - 1 , j ); } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] = board [ i ][ j ] == '.' ? 'O' : 'X' ; } private : void dfs ( vector < vector < char >>& board , int i , int j ) { if ( i < 0 || j < 0 || i >= board . size () || j >= board [ 0 ]. size () || board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '.' ; dfs ( board , i , j + 1 ); dfs ( board , i , j - 1 ); dfs ( board , i + 1 , j ); dfs ( board , i - 1 , j ); } };","title":"0121-0130"},{"location":"cpp/0101-0200/0121-0130/#121-best-time-to-buy-and-sell-stock-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellOne = 0 ; int holdOne = INT_MIN ; for ( int price : prices ) { sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellOne ; } };","title":"121. Best Time to Buy and Sell Stock $\\star$"},{"location":"cpp/0101-0200/0121-0130/#122-best-time-to-buy-and-sell-stock-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } };","title":"122. Best Time to Buy and Sell Stock II $\\star$"},{"location":"cpp/0101-0200/0121-0130/#123-best-time-to-buy-and-sell-stock-iii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellTwo = 0 ; int holdTwo = INT_MIN ; int sellOne = 0 ; int holdOne = INT_MIN ; for ( int price : prices ) { sellTwo = max ( sellTwo , holdTwo + price ); holdTwo = max ( holdTwo , sellOne - price ); sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellTwo ; } };","title":"123. Best Time to Buy and Sell Stock III $\\star\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#124-binary-tree-maximum-path-sum-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int maxPathSum ( TreeNode * root ) { helper ( root ); return ans ; } private : int ans = INT_MIN ; int helper ( TreeNode * root ) { if ( ! root ) return 0 ; int left = max ( helper ( root -> left ), 0 ); int right = max ( helper ( root -> right ), 0 ); ans = max ( ans , root -> val + left + right ); return root -> val + max ( left , right ); } };","title":"124. Binary Tree Maximum Path Sum $\\star\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#125-valid-palindrome-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isPalindrome ( string s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! isalnum ( s [ l ])) ++ l ; while ( l < r && ! isalnum ( s [ r ])) -- r ; if ( tolower ( s [ l ]) != tolower ( s [ r ])) return false ; ++ l ; -- r ; } return true ; } };","title":"125. Valid Palindrome $\\star$"},{"location":"cpp/0101-0200/0121-0130/#126-word-ladder-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> ans ; unordered_set < string > set ( wordList . begin (), wordList . end ()); if ( ! set . count ( endWord )) return ans ; unordered_set < string > set1 = { beginWord }; unordered_map < string , vector < string >> map ; bool isFound = false ; while ( ! set1 . empty () && ! isFound ) { for ( const string & word : set1 ) set . erase ( word ); unordered_set < string > tempSet ; for ( const string & parent : set1 ) { string word = parent ; for ( int i = 0 ; i < word . length (); ++ i ) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; ++ j ) { word [ i ] = j ; if ( word == endWord ) { map [ parent ]. push_back ( word ); isFound = true ; } else if ( set . count ( word ) && ! isFound ) { tempSet . insert ( word ); map [ parent ]. push_back ( word ); } } word [ i ] = c ; } } swap ( set1 , tempSet ); } if ( isFound ) { vector < string > path = { beginWord }; dfs ( map , beginWord , endWord , path , ans ); } return ans ; } private : void dfs ( const unordered_map < string , vector < string >>& map , const string & word , const string & endWord , vector < string >& path , vector < vector < string >>& ans ) { if ( word == endWord ) { ans . push_back ( path ); return ; } if ( map . find ( word ) == map . cend ()) return ; for ( const string & child : map . at ( word )) { path . push_back ( child ); dfs ( map , child , endWord , path , ans ); path . pop_back (); } } };","title":"126. Word Ladder II $\\star\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#127-word-ladder-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > set ( wordList . begin (), wordList . end ()); if ( ! set . count ( endWord )) return 0 ; int ans = 0 ; unordered_set < string > set1 = { beginWord }; unordered_set < string > set2 = { endWord }; while ( ! set1 . empty () && ! set2 . empty ()) { ++ ans ; if ( set1 . size () > set2 . size ()) swap ( set1 , set2 ); unordered_set < string > tempSet ; for ( string word : set1 ) for ( int i = 0 ; i < word . length (); ++ i ) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; ++ j ) { word [ i ] = j ; if ( set2 . count ( word )) return ans + 1 ; if ( ! set . count ( word )) continue ; set . erase ( word ); tempSet . insert ( word ); } word [ i ] = c ; } swap ( set1 , tempSet ); } return 0 ; } };","title":"127. Word Ladder $\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#128-longest-consecutive-sequence-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int longestConsecutive ( vector < int >& nums ) { int ans = 0 ; unordered_set < int > set ( nums . begin (), nums . end ()); for ( long num : nums ) if ( ! set . count ( num - 1 )) { int length = 0 ; while ( set . count ( num ++ )) ++ length ; ans = max ( ans , length ); } return ans ; } };","title":"128. Longest Consecutive Sequence $\\star\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#129-sum-root-to-leaf-numbers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int sumNumbers ( TreeNode * root ) { int ans = 0 ; int path = 0 ; dfs ( root , path , ans ); return ans ; } private : void dfs ( TreeNode * root , int & path , int & ans ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { path = path * 10 + root -> val ; ans += path ; path = ( path - root -> val ) / 10 ; return ; } path = path * 10 + root -> val ; dfs ( root -> left , path , ans ); dfs ( root -> right , path , ans ); path = ( path - root -> val ) / 10 ; } };","title":"129. Sum Root to Leaf Numbers $\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#130-surrounded-regions-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : void solve ( vector < vector < char >>& board ) { if ( board . empty ()) return ; const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) { dfs ( board , i , 0 ); dfs ( board , i , n - 1 ); } for ( int j = 1 ; j < n - 1 ; ++ j ) { dfs ( board , 0 , j ); dfs ( board , m - 1 , j ); } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] = board [ i ][ j ] == '.' ? 'O' : 'X' ; } private : void dfs ( vector < vector < char >>& board , int i , int j ) { if ( i < 0 || j < 0 || i >= board . size () || j >= board [ 0 ]. size () || board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '.' ; dfs ( board , i , j + 1 ); dfs ( board , i , j - 1 ); dfs ( board , i + 1 , j ); dfs ( board , i - 1 , j ); } };","title":"130. Surrounded Regions $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/","text":"131. Palindrome Partitioning $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; vector < string > path ; dfs ( s , 0 , path , ans ); return ans ; } private : void dfs ( string & s , int j , vector < string >& path , vector < vector < string >>& ans ) { if ( j == s . length ()) { ans . push_back ( path ); return ; } for ( int i = j ; i < s . length (); ++ i ) if ( isPalindrome ( s , j , i )) { path . push_back ( s . substr ( j , i - j + 1 )); dfs ( s , i + 1 , path , ans ); path . pop_back (); } } bool isPalindrome ( string & s , int l , int r ) { while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } }; 132. Palindrome Partitioning II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int minCut ( string s ) { const int n = s . length (); vector < int > cut ( n ); vector < vector < bool >> dp ( n , vector < bool > ( n )); for ( int i = 0 ; i < n ; ++ i ) { int min = i ; for ( int j = 0 ; j <= i ; ++ j ) if ( s [ j ] == s [ i ] && ( j + 1 > i - 1 || dp [ j + 1 ][ i - 1 ])) { dp [ j ][ i ] = true ; min = j == 0 ? 0 : std :: min ( min , cut [ j - 1 ] + 1 ); } cut [ i ] = min ; } return cut [ n - 1 ]; } }; 133. Clone Graph $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : Node * cloneGraph ( Node * node ) { if ( ! node ) return NULL ; if ( map . count ( node )) return map [ node ]; map [ node ] = new Node ( node -> val , {}); for ( Node * neighbor : node -> neighbors ) map [ node ] -> neighbors . push_back ( cloneGraph ( neighbor )); return map [ node ]; } private : unordered_map < Node * , Node *> map ; }; 134. Gas Station $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int ans = 0 ; int net = 0 ; int sum = 0 ; for ( int i = 0 ; i < gas . size (); ++ i ) { net += gas [ i ] - cost [ i ]; sum += gas [ i ] - cost [ i ]; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; } } return net < 0 ? - 1 : ans ; } }; 135. Candy $\\star\\star\\star$ 136. Single Number $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) ans ^= num ; return ans ; } }; 137. Single Number II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int singleNumber ( vector < int >& nums ) { int ones = 0 ; int twos = 0 ; for ( int num : nums ) { ones ^= ( num & ~ twos ); twos ^= ( num & ~ ones ); } return ones ; } }; 138. Copy List with Random Pointer $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return NULL ; if ( map . count ( head )) return map [ head ]; map [ head ] = new Node ( head -> val , NULL , NULL ); map [ head ] -> next = copyRandomList ( head -> next ); map [ head ] -> random = copyRandomList ( head -> random ); return map [ head ]; } private : unordered_map < Node * , Node *> map ; }; 139. Word Break $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > set ( wordDict . begin (), wordDict . end ()); return wordBreak ( s , set ); } private : unordered_map < string , bool > map ; bool wordBreak ( string & s , unordered_set < string >& set ) { if ( map . count ( s )) return map [ s ]; if ( set . count ( s )) return map [ s ] = true ; for ( int i = 1 ; i < s . length (); ++ i ) { string left = s . substr ( 0 , i ); string right = s . substr ( i ); if ( wordBreak ( left , set ) && set . count ( right )) return map [ s ] = true ; } return map [ s ] = false ; } }; 140. Word Break II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < string > wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > set ( wordDict . begin (), wordDict . end ()); return wordBreak ( s , set ); } private : unordered_map < string , vector < string >> map ; vector < string >& wordBreak ( string & s , unordered_set < string >& set ) { if ( map . count ( s )) return map [ s ]; vector < string > ans ; if ( set . count ( s )) ans . push_back ( s ); for ( int i = 1 ; i < s . length (); ++ i ) { string right = s . substr ( i ); if ( set . count ( right )) { string left = s . substr ( 0 , i ); vector < string > leftAns = append ( wordBreak ( left , set ), right ); ans . insert ( ans . end (), leftAns . begin (), leftAns . end ()); } } return map [ s ] = ans ; } vector < string > append ( vector < string > prefixes , string & word ) { for ( string & prefix : prefixes ) prefix += \" \" + word ; return prefixes ; } };","title":"0131-0140"},{"location":"cpp/0101-0200/0131-0140/#131-palindrome-partitioning-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; vector < string > path ; dfs ( s , 0 , path , ans ); return ans ; } private : void dfs ( string & s , int j , vector < string >& path , vector < vector < string >>& ans ) { if ( j == s . length ()) { ans . push_back ( path ); return ; } for ( int i = j ; i < s . length (); ++ i ) if ( isPalindrome ( s , j , i )) { path . push_back ( s . substr ( j , i - j + 1 )); dfs ( s , i + 1 , path , ans ); path . pop_back (); } } bool isPalindrome ( string & s , int l , int r ) { while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } };","title":"131. Palindrome Partitioning $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#132-palindrome-partitioning-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int minCut ( string s ) { const int n = s . length (); vector < int > cut ( n ); vector < vector < bool >> dp ( n , vector < bool > ( n )); for ( int i = 0 ; i < n ; ++ i ) { int min = i ; for ( int j = 0 ; j <= i ; ++ j ) if ( s [ j ] == s [ i ] && ( j + 1 > i - 1 || dp [ j + 1 ][ i - 1 ])) { dp [ j ][ i ] = true ; min = j == 0 ? 0 : std :: min ( min , cut [ j - 1 ] + 1 ); } cut [ i ] = min ; } return cut [ n - 1 ]; } };","title":"132. Palindrome Partitioning II $\\star\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#133-clone-graph-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : Node * cloneGraph ( Node * node ) { if ( ! node ) return NULL ; if ( map . count ( node )) return map [ node ]; map [ node ] = new Node ( node -> val , {}); for ( Node * neighbor : node -> neighbors ) map [ node ] -> neighbors . push_back ( cloneGraph ( neighbor )); return map [ node ]; } private : unordered_map < Node * , Node *> map ; };","title":"133. Clone Graph $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#134-gas-station-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int ans = 0 ; int net = 0 ; int sum = 0 ; for ( int i = 0 ; i < gas . size (); ++ i ) { net += gas [ i ] - cost [ i ]; sum += gas [ i ] - cost [ i ]; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; } } return net < 0 ? - 1 : ans ; } };","title":"134. Gas Station $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#135-candy-starstarstar","text":"","title":"135. Candy $\\star\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#136-single-number-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) ans ^= num ; return ans ; } };","title":"136. Single Number $\\star$"},{"location":"cpp/0101-0200/0131-0140/#137-single-number-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int singleNumber ( vector < int >& nums ) { int ones = 0 ; int twos = 0 ; for ( int num : nums ) { ones ^= ( num & ~ twos ); twos ^= ( num & ~ ones ); } return ones ; } };","title":"137. Single Number II $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#138-copy-list-with-random-pointer-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return NULL ; if ( map . count ( head )) return map [ head ]; map [ head ] = new Node ( head -> val , NULL , NULL ); map [ head ] -> next = copyRandomList ( head -> next ); map [ head ] -> random = copyRandomList ( head -> random ); return map [ head ]; } private : unordered_map < Node * , Node *> map ; };","title":"138. Copy List with Random Pointer $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#139-word-break-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > set ( wordDict . begin (), wordDict . end ()); return wordBreak ( s , set ); } private : unordered_map < string , bool > map ; bool wordBreak ( string & s , unordered_set < string >& set ) { if ( map . count ( s )) return map [ s ]; if ( set . count ( s )) return map [ s ] = true ; for ( int i = 1 ; i < s . length (); ++ i ) { string left = s . substr ( 0 , i ); string right = s . substr ( i ); if ( wordBreak ( left , set ) && set . count ( right )) return map [ s ] = true ; } return map [ s ] = false ; } };","title":"139. Word Break $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#140-word-break-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < string > wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > set ( wordDict . begin (), wordDict . end ()); return wordBreak ( s , set ); } private : unordered_map < string , vector < string >> map ; vector < string >& wordBreak ( string & s , unordered_set < string >& set ) { if ( map . count ( s )) return map [ s ]; vector < string > ans ; if ( set . count ( s )) ans . push_back ( s ); for ( int i = 1 ; i < s . length (); ++ i ) { string right = s . substr ( i ); if ( set . count ( right )) { string left = s . substr ( 0 , i ); vector < string > leftAns = append ( wordBreak ( left , set ), right ); ans . insert ( ans . end (), leftAns . begin (), leftAns . end ()); } } return map [ s ] = ans ; } vector < string > append ( vector < string > prefixes , string & word ) { for ( string & prefix : prefixes ) prefix += \" \" + word ; return prefixes ; } };","title":"140. Word Break II $\\star\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/","text":"141. Linked List Cycle $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } }; 142. Linked List Cycle II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } }; 143. Reorder List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * prev = NULL ; ListNode * slow = head ; ListNode * fast = head ; ListNode * l1 = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = NULL ; ListNode * l2 = reverse ( slow ); merge ( l1 , l2 ); } private : ListNode * reverse ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { auto next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { auto next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } }; 144. Binary Tree Preorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack ; stack . push ( root ); while ( ! stack . empty ()) { TreeNode * node = stack . top (); ans . push_back ( node -> val ); stack . pop (); if ( node -> right ) stack . push ( node -> right ); if ( node -> left ) stack . push ( node -> left ); } return ans ; } }; 145. Binary Tree Postorder Traversal $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack ; stack . push ( root ); while ( ! stack . empty ()) { TreeNode * node = stack . top (); ans . push_back ( node -> val ); stack . pop (); if ( node -> left ) stack . push ( node -> left ); if ( node -> right ) stack . push ( node -> right ); } reverse ( ans . begin (), ans . end ()); return ans ; } }; 146. LRU Cache $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class LRUCache { public : LRUCache ( int capacity ) : capacity ( capacity ) {} int get ( int key ) { if ( ! map . count ( key )) return - 1 ; cache . splice ( cache . begin (), cache , map [ key ]); return map [ key ] -> second ; } void put ( int key , int value ) { if ( map . count ( key )) { map [ key ] -> second = value ; cache . splice ( cache . begin (), cache , map [ key ]); return ; } if ( cache . size () == capacity ) { pair < int , int >& node = cache . back (); map . erase ( node . first ); cache . pop_back (); } cache . emplace_front ( key , value ); map [ key ] = cache . begin (); } private : int capacity ; list < pair < int , int >> cache ; unordered_map < int , list < pair < int , int >>:: iterator > map ; }; 147. Insertion Sort List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * insertionSortList ( ListNode * head ) { ListNode dummy ( 0 ); ListNode * curr = head ; while ( curr ) { auto prev = & dummy ; while ( prev -> next && prev -> next -> val < curr -> val ) prev = prev -> next ; auto next = curr -> next ; curr -> next = prev -> next ; prev -> next = curr ; curr = next ; } return dummy . next ; } }; 148. Sort List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : ListNode * sortList ( ListNode * head ) { int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; ListNode dummy ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k <<= 1 ) { ListNode * curr = dummy . next ; ListNode * tail = & dummy ; while ( curr ) { ListNode * l = curr ; ListNode * r = split ( l , k ); curr = split ( r , k ); vector < ListNode *> merged = merge ( l , r ); tail -> next = merged [ 0 ]; tail = merged [ 1 ]; } } return dummy . next ; } private : ListNode * split ( ListNode * head , int k ) { while ( -- k && head ) head = head -> next ; ListNode * rest = head ? head -> next : NULL ; if ( head ) head -> next = NULL ; return rest ; } vector < ListNode *> merge ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * tail = & dummy ; while ( l1 && l2 ) { if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); tail -> next = l1 ; l1 = l1 -> next ; tail = tail -> next ; } tail -> next = l1 ? l1 : l2 ; while ( tail -> next ) tail = tail -> next ; return { dummy . next , tail }; } }; 149. Max Points on a Line $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : int maxPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 0 ; i < points . size (); ++ i ) { map < pair < int , int > , int > map ; vector < int > p1 = points [ i ]; int samePoints = 1 ; int maxPoints = 0 ; for ( int j = i + 1 ; j < points . size (); ++ j ) { vector < int > p2 = points [ j ]; if ( p1 [ 0 ] == p2 [ 0 ] && p1 [ 1 ] == p2 [ 1 ]) ++ samePoints ; else maxPoints = max ( maxPoints , ++ map [ getSlope ( p1 , p2 )]); } ans = max ( ans , samePoints + maxPoints ); } return ans ; } private : pair < int , int > getSlope ( vector < int >& p1 , vector < int >& p2 ) { int dx = p2 [ 0 ] - p1 [ 0 ]; int dy = p2 [ 1 ] - p1 [ 1 ]; if ( dy == 0 ) return { p1 [ 1 ], 0 }; if ( dx == 0 ) return { 0 , p1 [ 0 ]}; int d = gcd ( dx , dy ); return { dy / d , dx / d }; } int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } }; 150. Evaluate Reverse Polish Notation $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stack ; int a ; int b ; for ( string & token : tokens ) { if ( token == \"+\" ) { helper ( stack , a , b ); stack . push ( a + b ); } else if ( token == \"-\" ) { helper ( stack , a , b ); stack . push ( a - b ); } else if ( token == \"*\" ) { helper ( stack , a , b ); stack . push ( a * b ); } else if ( token == \"/\" ) { helper ( stack , a , b ); stack . push ( a / b ); } else { stack . push ( stoi ( token )); } } return stack . top (); } private : void helper ( stack < int >& stack , int & a , int & b ) { b = stack . top (); stack . pop (); a = stack . top (); stack . pop (); } };","title":"0141-0150"},{"location":"cpp/0101-0200/0141-0150/#141-linked-list-cycle-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } };","title":"141. Linked List Cycle $\\star$"},{"location":"cpp/0101-0200/0141-0150/#142-linked-list-cycle-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } };","title":"142. Linked List Cycle II $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#143-reorder-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * prev = NULL ; ListNode * slow = head ; ListNode * fast = head ; ListNode * l1 = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = NULL ; ListNode * l2 = reverse ( slow ); merge ( l1 , l2 ); } private : ListNode * reverse ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { auto next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { auto next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } };","title":"143. Reorder List $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#144-binary-tree-preorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack ; stack . push ( root ); while ( ! stack . empty ()) { TreeNode * node = stack . top (); ans . push_back ( node -> val ); stack . pop (); if ( node -> right ) stack . push ( node -> right ); if ( node -> left ) stack . push ( node -> left ); } return ans ; } };","title":"144. Binary Tree Preorder Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#145-binary-tree-postorder-traversal-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack ; stack . push ( root ); while ( ! stack . empty ()) { TreeNode * node = stack . top (); ans . push_back ( node -> val ); stack . pop (); if ( node -> left ) stack . push ( node -> left ); if ( node -> right ) stack . push ( node -> right ); } reverse ( ans . begin (), ans . end ()); return ans ; } };","title":"145. Binary Tree Postorder Traversal $\\star\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#146-lru-cache-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class LRUCache { public : LRUCache ( int capacity ) : capacity ( capacity ) {} int get ( int key ) { if ( ! map . count ( key )) return - 1 ; cache . splice ( cache . begin (), cache , map [ key ]); return map [ key ] -> second ; } void put ( int key , int value ) { if ( map . count ( key )) { map [ key ] -> second = value ; cache . splice ( cache . begin (), cache , map [ key ]); return ; } if ( cache . size () == capacity ) { pair < int , int >& node = cache . back (); map . erase ( node . first ); cache . pop_back (); } cache . emplace_front ( key , value ); map [ key ] = cache . begin (); } private : int capacity ; list < pair < int , int >> cache ; unordered_map < int , list < pair < int , int >>:: iterator > map ; };","title":"146. LRU Cache $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#147-insertion-sort-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * insertionSortList ( ListNode * head ) { ListNode dummy ( 0 ); ListNode * curr = head ; while ( curr ) { auto prev = & dummy ; while ( prev -> next && prev -> next -> val < curr -> val ) prev = prev -> next ; auto next = curr -> next ; curr -> next = prev -> next ; prev -> next = curr ; curr = next ; } return dummy . next ; } };","title":"147. Insertion Sort List $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#148-sort-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : ListNode * sortList ( ListNode * head ) { int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; ListNode dummy ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k <<= 1 ) { ListNode * curr = dummy . next ; ListNode * tail = & dummy ; while ( curr ) { ListNode * l = curr ; ListNode * r = split ( l , k ); curr = split ( r , k ); vector < ListNode *> merged = merge ( l , r ); tail -> next = merged [ 0 ]; tail = merged [ 1 ]; } } return dummy . next ; } private : ListNode * split ( ListNode * head , int k ) { while ( -- k && head ) head = head -> next ; ListNode * rest = head ? head -> next : NULL ; if ( head ) head -> next = NULL ; return rest ; } vector < ListNode *> merge ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * tail = & dummy ; while ( l1 && l2 ) { if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); tail -> next = l1 ; l1 = l1 -> next ; tail = tail -> next ; } tail -> next = l1 ? l1 : l2 ; while ( tail -> next ) tail = tail -> next ; return { dummy . next , tail }; } };","title":"148. Sort List $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#149-max-points-on-a-line-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : int maxPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 0 ; i < points . size (); ++ i ) { map < pair < int , int > , int > map ; vector < int > p1 = points [ i ]; int samePoints = 1 ; int maxPoints = 0 ; for ( int j = i + 1 ; j < points . size (); ++ j ) { vector < int > p2 = points [ j ]; if ( p1 [ 0 ] == p2 [ 0 ] && p1 [ 1 ] == p2 [ 1 ]) ++ samePoints ; else maxPoints = max ( maxPoints , ++ map [ getSlope ( p1 , p2 )]); } ans = max ( ans , samePoints + maxPoints ); } return ans ; } private : pair < int , int > getSlope ( vector < int >& p1 , vector < int >& p2 ) { int dx = p2 [ 0 ] - p1 [ 0 ]; int dy = p2 [ 1 ] - p1 [ 1 ]; if ( dy == 0 ) return { p1 [ 1 ], 0 }; if ( dx == 0 ) return { 0 , p1 [ 0 ]}; int d = gcd ( dx , dy ); return { dy / d , dx / d }; } int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } };","title":"149. Max Points on a Line $\\star\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#150-evaluate-reverse-polish-notation-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stack ; int a ; int b ; for ( string & token : tokens ) { if ( token == \"+\" ) { helper ( stack , a , b ); stack . push ( a + b ); } else if ( token == \"-\" ) { helper ( stack , a , b ); stack . push ( a - b ); } else if ( token == \"*\" ) { helper ( stack , a , b ); stack . push ( a * b ); } else if ( token == \"/\" ) { helper ( stack , a , b ); stack . push ( a / b ); } else { stack . push ( stoi ( token )); } } return stack . top (); } private : void helper ( stack < int >& stack , int & a , int & b ) { b = stack . top (); stack . pop (); a = stack . top (); stack . pop (); } };","title":"150. Evaluate Reverse Polish Notation $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/","text":"151. Reverse Words in a String $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : string reverseWords ( string s ) { reverse ( s . begin (), s . end ()); reverseWords ( s , 0 , 0 ); return cleanSpaces ( s , 0 , 0 ); } private : void reverseWords ( string & s , int i , int j ) { while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( s . begin () + i , s . begin () + j ); } } string cleanSpaces ( string & s , int i , int j ) { while ( j < s . length ()) { while ( j < s . length () && s [ j ] == ' ' ) ++ j ; while ( j < s . length () && s [ j ] != ' ' ) s [ i ++ ] = s [ j ++ ]; while ( j < s . length () && s [ j ] == ' ' ) ++ j ; if ( j < s . length ()) s [ i ++ ] = ' ' ; } return s . substr ( 0 , i ); } }; 152. Maximum Product Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProduct ( vector < int >& nums ) { int ans = nums [ 0 ]; int prevMin = nums [ 0 ]; int prevMax = nums [ 0 ]; for ( int i = 1 ; i < nums . size (); ++ i ) { int min = prevMin * nums [ i ]; int max = prevMax * nums [ i ]; prevMin = std :: min ( nums [ i ], std :: min ( min , max )); prevMax = std :: max ( nums [ i ], std :: max ( min , max )); ans = std :: max ( ans , prevMax ); } return ans ; } }; 153. Find Minimum in Rotated Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }; 154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ]) -- r ; else if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }; 155. Min Stack $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MinStack { public : void push ( int x ) { int min = stack . empty () ? x : std :: min ( stack . top (). second , x ); stack . push ({ x , min }); } void pop () { stack . pop (); } int top () { return stack . top (). first ; } int getMin () { return stack . top (). second ; } private : std :: stack < pair < int , int >> stack ; }; 156. Binary Tree Upside Down $\\star\\star$ 157. Read N Characters Given Read4 $\\star$ 158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$ 159. Longest Substring with At Most Two Distinct Characters $\\star\\star$ 160. Intersection of Two Linked Lists $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { if ( ! headA || ! headB ) return NULL ; ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a == NULL ? headB : a -> next ; b = b == NULL ? headA : b -> next ; } return a ; } };","title":"0151-0160"},{"location":"cpp/0101-0200/0151-0160/#151-reverse-words-in-a-string-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : string reverseWords ( string s ) { reverse ( s . begin (), s . end ()); reverseWords ( s , 0 , 0 ); return cleanSpaces ( s , 0 , 0 ); } private : void reverseWords ( string & s , int i , int j ) { while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( s . begin () + i , s . begin () + j ); } } string cleanSpaces ( string & s , int i , int j ) { while ( j < s . length ()) { while ( j < s . length () && s [ j ] == ' ' ) ++ j ; while ( j < s . length () && s [ j ] != ' ' ) s [ i ++ ] = s [ j ++ ]; while ( j < s . length () && s [ j ] == ' ' ) ++ j ; if ( j < s . length ()) s [ i ++ ] = ' ' ; } return s . substr ( 0 , i ); } };","title":"151. Reverse Words in a String $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#152-maximum-product-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProduct ( vector < int >& nums ) { int ans = nums [ 0 ]; int prevMin = nums [ 0 ]; int prevMax = nums [ 0 ]; for ( int i = 1 ; i < nums . size (); ++ i ) { int min = prevMin * nums [ i ]; int max = prevMax * nums [ i ]; prevMin = std :: min ( nums [ i ], std :: min ( min , max )); prevMax = std :: max ( nums [ i ], std :: max ( min , max )); ans = std :: max ( ans , prevMax ); } return ans ; } };","title":"152. Maximum Product Subarray $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#153-find-minimum-in-rotated-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } };","title":"153. Find Minimum in Rotated Sorted Array $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#154-find-minimum-in-rotated-sorted-array-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ]) -- r ; else if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } };","title":"154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#155-min-stack-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MinStack { public : void push ( int x ) { int min = stack . empty () ? x : std :: min ( stack . top (). second , x ); stack . push ({ x , min }); } void pop () { stack . pop (); } int top () { return stack . top (). first ; } int getMin () { return stack . top (). second ; } private : std :: stack < pair < int , int >> stack ; };","title":"155. Min Stack $\\star$"},{"location":"cpp/0101-0200/0151-0160/#156-binary-tree-upside-down-starstar","text":"","title":"156. Binary Tree Upside Down $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#157-read-n-characters-given-read4-star","text":"","title":"157. Read N Characters Given Read4 $\\star$"},{"location":"cpp/0101-0200/0151-0160/#158-read-n-characters-given-read4-ii-call-multiple-times-starstarstar","text":"","title":"158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#159-longest-substring-with-at-most-two-distinct-characters-starstar","text":"","title":"159. Longest Substring with At Most Two Distinct Characters $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#160-intersection-of-two-linked-lists-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { if ( ! headA || ! headB ) return NULL ; ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a == NULL ? headB : a -> next ; b = b == NULL ? headA : b -> next ; } return a ; } };","title":"160. Intersection of Two Linked Lists $\\star$"},{"location":"cpp/0101-0200/0161-0170/","text":"161. One Edit Distance $\\star\\star$ 162. Find Peak Element $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findPeakElement ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > nums [ m + 1 ]) r = m ; else l = m + 1 ; } return l ; } }; 163. Missing Ranges $\\star\\star$ 164. Maximum Gap $\\star\\star\\star$ 165. Compare Version Numbers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int compareVersion ( string version1 , string version2 ) { istringstream iss1 ( version1 ); istringstream iss2 ( version2 ); int num1 ; int num2 ; char c ; while ( bool ( iss1 >> num1 ) + bool ( iss2 >> num2 )) { if ( num1 < num2 ) return - 1 ; if ( num1 > num2 ) return 1 ; iss1 >> c ; iss2 >> c ; num1 = 0 ; num2 = 0 ; } if ( num1 == num2 ) return 0 ; return 0 ; }; }; 166. Fraction to Recurring Decimal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; string ans ; if ( numerator < 0 ^ denominator < 0 ) ans += \"-\" ; long n = abs (( long ) numerator ); long d = abs (( long ) denominator ); ans += to_string ( n / d ); if ( n % d == 0 ) return ans ; ans += '.' ; unordered_map < int , int > map ; for ( long r = n % d ; r ; r %= d ) { if ( map . count ( r ) > 0 ) { ans . insert ( map [ r ], 1 , '(' ); ans += ')' ; break ; } map [ r ] = ans . size (); r *= 10 ; ans += to_string ( r / d ); } return ans ; } }; 167. Two Sum II - Input array is sorted $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int l = 0 ; int r = numbers . size () - 1 ; while ( l < r ) { int sum = numbers [ l ] + numbers [ r ]; if ( sum == target ) return { l + 1 , r + 1 }; if ( sum < target ) ++ l ; else -- r ; } throw ; } }; 168. Excel Sheet Column Title $\\star$ 1 2 3 4 5 6 7 class Solution { public : string convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char )( 'A' + (( n - 1 ) % 26 )); } }; 169. Majority Element $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int majorityElement ( vector < int >& nums ) { int ans ; int count = 0 ; for ( int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } }; 170. Two Sum III - Data structure design $\\star$","title":"0161-0170"},{"location":"cpp/0101-0200/0161-0170/#161-one-edit-distance-starstar","text":"","title":"161. One Edit Distance $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#162-find-peak-element-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findPeakElement ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > nums [ m + 1 ]) r = m ; else l = m + 1 ; } return l ; } };","title":"162. Find Peak Element $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#163-missing-ranges-starstar","text":"","title":"163. Missing Ranges $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#164-maximum-gap-starstarstar","text":"","title":"164. Maximum Gap $\\star\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#165-compare-version-numbers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int compareVersion ( string version1 , string version2 ) { istringstream iss1 ( version1 ); istringstream iss2 ( version2 ); int num1 ; int num2 ; char c ; while ( bool ( iss1 >> num1 ) + bool ( iss2 >> num2 )) { if ( num1 < num2 ) return - 1 ; if ( num1 > num2 ) return 1 ; iss1 >> c ; iss2 >> c ; num1 = 0 ; num2 = 0 ; } if ( num1 == num2 ) return 0 ; return 0 ; }; };","title":"165. Compare Version Numbers $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#166-fraction-to-recurring-decimal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; string ans ; if ( numerator < 0 ^ denominator < 0 ) ans += \"-\" ; long n = abs (( long ) numerator ); long d = abs (( long ) denominator ); ans += to_string ( n / d ); if ( n % d == 0 ) return ans ; ans += '.' ; unordered_map < int , int > map ; for ( long r = n % d ; r ; r %= d ) { if ( map . count ( r ) > 0 ) { ans . insert ( map [ r ], 1 , '(' ); ans += ')' ; break ; } map [ r ] = ans . size (); r *= 10 ; ans += to_string ( r / d ); } return ans ; } };","title":"166. Fraction to Recurring Decimal $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#167-two-sum-ii-input-array-is-sorted-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int l = 0 ; int r = numbers . size () - 1 ; while ( l < r ) { int sum = numbers [ l ] + numbers [ r ]; if ( sum == target ) return { l + 1 , r + 1 }; if ( sum < target ) ++ l ; else -- r ; } throw ; } };","title":"167. Two Sum II - Input array is sorted $\\star$"},{"location":"cpp/0101-0200/0161-0170/#168-excel-sheet-column-title-star","text":"1 2 3 4 5 6 7 class Solution { public : string convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char )( 'A' + (( n - 1 ) % 26 )); } };","title":"168. Excel Sheet Column Title $\\star$"},{"location":"cpp/0101-0200/0161-0170/#169-majority-element-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int majorityElement ( vector < int >& nums ) { int ans ; int count = 0 ; for ( int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } };","title":"169. Majority Element $\\star$"},{"location":"cpp/0101-0200/0161-0170/#170-two-sum-iii-data-structure-design-star","text":"","title":"170. Two Sum III - Data structure design $\\star$"},{"location":"cpp/0101-0200/0171-0180/","text":"171. Excel Sheet Column Number $\\star$ 1 2 3 4 5 6 7 class Solution { public : int titleToNumber ( string s ) { return accumulate ( s . begin (), s . end (), 0 , []( int a , int b ) { return a * 26 + ( b - 'A' + 1 ); }); } }; 172. Factorial Trailing Zeroes $\\star$ 1 2 3 4 5 6 class Solution { public : int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } }; 173. Binary Search Tree Iterator $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class BSTIterator { public : BSTIterator ( TreeNode * root ) { helper ( root ); } int next () { TreeNode * node = stack . top (); stack . pop (); if ( node -> right ) helper ( node -> right ); return node -> val ; } bool hasNext () { return ! stack . empty (); } private : std :: stack < TreeNode *> stack ; void helper ( TreeNode * root ) { while ( root ) { stack . push ( root ); root = root -> left ; } } }; 174. Dungeon Game $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { const int m = dungeon . size (); const int n = dungeon [ 0 ]. size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) dp [ i ][ j ] = max ( 1 , min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ]); return dp [ 0 ][ 0 ]; } }; 175. Combine Two Tables $\\star$ 176. Second Highest Salary $\\star$ 177. Nth Highest Salary $\\star\\star$ 178. Rank Scores $\\star\\star$ 179. Largest Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : string largestNumber ( vector < int >& nums ) { string ans ; sort ( nums . begin (), nums . end (), []( int a , int b ) { return to_string ( a ) + to_string ( b ) > to_string ( b ) + to_string ( a ); }); for ( int num : nums ) ans += to_string ( num ); return ans [ 0 ] == '0' ? \"0\" : ans ; } }; 180. Consecutive Numbers $\\star\\star$","title":"0171-0180"},{"location":"cpp/0101-0200/0171-0180/#171-excel-sheet-column-number-star","text":"1 2 3 4 5 6 7 class Solution { public : int titleToNumber ( string s ) { return accumulate ( s . begin (), s . end (), 0 , []( int a , int b ) { return a * 26 + ( b - 'A' + 1 ); }); } };","title":"171. Excel Sheet Column Number $\\star$"},{"location":"cpp/0101-0200/0171-0180/#172-factorial-trailing-zeroes-star","text":"1 2 3 4 5 6 class Solution { public : int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } };","title":"172. Factorial Trailing Zeroes $\\star$"},{"location":"cpp/0101-0200/0171-0180/#173-binary-search-tree-iterator-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class BSTIterator { public : BSTIterator ( TreeNode * root ) { helper ( root ); } int next () { TreeNode * node = stack . top (); stack . pop (); if ( node -> right ) helper ( node -> right ); return node -> val ; } bool hasNext () { return ! stack . empty (); } private : std :: stack < TreeNode *> stack ; void helper ( TreeNode * root ) { while ( root ) { stack . push ( root ); root = root -> left ; } } };","title":"173. Binary Search Tree Iterator $\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#174-dungeon-game-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { const int m = dungeon . size (); const int n = dungeon [ 0 ]. size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) dp [ i ][ j ] = max ( 1 , min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ]); return dp [ 0 ][ 0 ]; } };","title":"174. Dungeon Game $\\star\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#175-combine-two-tables-star","text":"","title":"175. Combine Two Tables $\\star$"},{"location":"cpp/0101-0200/0171-0180/#176-second-highest-salary-star","text":"","title":"176. Second Highest Salary $\\star$"},{"location":"cpp/0101-0200/0171-0180/#177-nth-highest-salary-starstar","text":"","title":"177. Nth Highest Salary $\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#178-rank-scores-starstar","text":"","title":"178. Rank Scores $\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#179-largest-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : string largestNumber ( vector < int >& nums ) { string ans ; sort ( nums . begin (), nums . end (), []( int a , int b ) { return to_string ( a ) + to_string ( b ) > to_string ( b ) + to_string ( a ); }); for ( int num : nums ) ans += to_string ( num ); return ans [ 0 ] == '0' ? \"0\" : ans ; } };","title":"179. Largest Number $\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#180-consecutive-numbers-starstar","text":"","title":"180. Consecutive Numbers $\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/","text":"181. Employees Earning More Than Their Managers $\\star$ 182. Duplicate Emails $\\star$ 183. Customers Who Never Order $\\star$ 184. Department Highest Salary $\\star\\star$ 185. Department Top Three Salaries $\\star\\star\\star$ 186. Reverse Words in a String II $\\star\\star$ 187. Repeated DNA Sequences $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < string > findRepeatedDnaSequences ( string s ) { const int n = s . length (); unordered_set < string > ans ; unordered_set < string > set ; for ( int i = 0 ; i <= n - 10 ; ++ i ) { string seq = s . substr ( i , 10 ); if ( set . count ( seq )) ans . insert ( seq ); set . insert ( seq ); } return vector < string > ( ans . begin (), ans . end ()); } }; 188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int maxProfit ( int k , vector < int >& prices ) { if ( k >= prices . size () / 2 ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } vector < int > sell ( k + 1 ); vector < int > hold ( k + 1 , INT_MIN ); for ( int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = max ( sell [ i ], hold [ i ] + price ); hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ); } return sell [ k ]; } }; 189. Rotate Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : void rotate ( vector < int >& nums , int k ) { k %= nums . size (); reverse ( nums , 0 , nums . size () - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } }; 190. Reverse Bits $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : uint32_t reverseBits ( uint32_t num ) { unsigned int NO_OF_BITS = sizeof ( num ) * 8 ; unsigned int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; ++ i ) { temp = ( num & ( 1 << i )); if ( temp ) reverse_num |= ( 1 << (( NO_OF_BITS - 1 ) - i )); } return reverse_num ; } };","title":"0181-0190"},{"location":"cpp/0101-0200/0181-0190/#181-employees-earning-more-than-their-managers-star","text":"","title":"181. Employees Earning More Than Their Managers $\\star$"},{"location":"cpp/0101-0200/0181-0190/#182-duplicate-emails-star","text":"","title":"182. Duplicate Emails $\\star$"},{"location":"cpp/0101-0200/0181-0190/#183-customers-who-never-order-star","text":"","title":"183. Customers Who Never Order $\\star$"},{"location":"cpp/0101-0200/0181-0190/#184-department-highest-salary-starstar","text":"","title":"184. Department Highest Salary $\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#185-department-top-three-salaries-starstarstar","text":"","title":"185. Department Top Three Salaries $\\star\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#186-reverse-words-in-a-string-ii-starstar","text":"","title":"186. Reverse Words in a String II $\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#187-repeated-dna-sequences-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < string > findRepeatedDnaSequences ( string s ) { const int n = s . length (); unordered_set < string > ans ; unordered_set < string > set ; for ( int i = 0 ; i <= n - 10 ; ++ i ) { string seq = s . substr ( i , 10 ); if ( set . count ( seq )) ans . insert ( seq ); set . insert ( seq ); } return vector < string > ( ans . begin (), ans . end ()); } };","title":"187. Repeated DNA Sequences $\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#188-best-time-to-buy-and-sell-stock-iv-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int maxProfit ( int k , vector < int >& prices ) { if ( k >= prices . size () / 2 ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } vector < int > sell ( k + 1 ); vector < int > hold ( k + 1 , INT_MIN ); for ( int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = max ( sell [ i ], hold [ i ] + price ); hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ); } return sell [ k ]; } };","title":"188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#189-rotate-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : void rotate ( vector < int >& nums , int k ) { k %= nums . size (); reverse ( nums , 0 , nums . size () - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } };","title":"189. Rotate Array $\\star$"},{"location":"cpp/0101-0200/0181-0190/#190-reverse-bits-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : uint32_t reverseBits ( uint32_t num ) { unsigned int NO_OF_BITS = sizeof ( num ) * 8 ; unsigned int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; ++ i ) { temp = ( num & ( 1 << i )); if ( temp ) reverse_num |= ( 1 << (( NO_OF_BITS - 1 ) - i )); } return reverse_num ; } };","title":"190. Reverse Bits $\\star$"},{"location":"cpp/0101-0200/0191-0200/","text":"191. Number of 1 Bits $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int hammingWeight ( uint32_t n ) { int ans ; for ( ans = 0 ; n != 0 ; ++ ans ) n &= n - 1 ; return ans ; } }; 192. Word Frequency $\\star\\star$ 193. Valid Phone Numbers $\\star$ 194. Transpose File $\\star\\star$ 195. Tenth Line $\\star$ 196. Delete Duplicate Emails $\\star$ 197. Rising Temperature $\\star$ 198. House Robber $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int rob ( vector < int >& nums ) { int dp1 = 0 ; int dp2 = 0 ; for ( int num : nums ) { int temp = dp1 ; dp1 = max ( dp1 , dp2 + num ); dp2 = temp ; } return dp1 ; } }; 199. Binary Tree Right Side View $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; dfs ( root , 1 , ans ); return ans ; } private : void dfs ( TreeNode * root , int level , vector < int >& ans ) { if ( ! root ) return ; if ( level > ans . size ()) ans . push_back ( root -> val ); dfs ( root -> right , level + 1 , ans ); dfs ( root -> left , level + 1 , ans ); } }; 200. Number of Islands $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int numIslands ( vector < vector < char >>& grid ) { if ( grid . empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> visited ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( ! visited [ i ][ j ] && grid [ i ][ j ] == '1' ) { ++ ans ; dfs ( grid , i , j , visited ); } return ans ; } private : void dfs ( vector < vector < char >>& grid , int i , int j , vector < vector < bool >>& visited ) { if ( i < 0 || j < 0 || i >= grid . size () || j >= grid [ 0 ]. size () || visited [ i ][ j ] || grid [ i ][ j ] == '0' ) return ; visited [ i ][ j ] = true ; dfs ( grid , i + 1 , j , visited ); dfs ( grid , i - 1 , j , visited ); dfs ( grid , i , j + 1 , visited ); dfs ( grid , i , j - 1 , visited ); } };","title":"0191-0200"},{"location":"cpp/0101-0200/0191-0200/#191-number-of-1-bits-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int hammingWeight ( uint32_t n ) { int ans ; for ( ans = 0 ; n != 0 ; ++ ans ) n &= n - 1 ; return ans ; } };","title":"191. Number of 1 Bits $\\star$"},{"location":"cpp/0101-0200/0191-0200/#192-word-frequency-starstar","text":"","title":"192. Word Frequency $\\star\\star$"},{"location":"cpp/0101-0200/0191-0200/#193-valid-phone-numbers-star","text":"","title":"193. Valid Phone Numbers $\\star$"},{"location":"cpp/0101-0200/0191-0200/#194-transpose-file-starstar","text":"","title":"194. Transpose File $\\star\\star$"},{"location":"cpp/0101-0200/0191-0200/#195-tenth-line-star","text":"","title":"195. Tenth Line $\\star$"},{"location":"cpp/0101-0200/0191-0200/#196-delete-duplicate-emails-star","text":"","title":"196. Delete Duplicate Emails $\\star$"},{"location":"cpp/0101-0200/0191-0200/#197-rising-temperature-star","text":"","title":"197. Rising Temperature $\\star$"},{"location":"cpp/0101-0200/0191-0200/#198-house-robber-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int rob ( vector < int >& nums ) { int dp1 = 0 ; int dp2 = 0 ; for ( int num : nums ) { int temp = dp1 ; dp1 = max ( dp1 , dp2 + num ); dp2 = temp ; } return dp1 ; } };","title":"198. House Robber $\\star$"},{"location":"cpp/0101-0200/0191-0200/#199-binary-tree-right-side-view-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; dfs ( root , 1 , ans ); return ans ; } private : void dfs ( TreeNode * root , int level , vector < int >& ans ) { if ( ! root ) return ; if ( level > ans . size ()) ans . push_back ( root -> val ); dfs ( root -> right , level + 1 , ans ); dfs ( root -> left , level + 1 , ans ); } };","title":"199. Binary Tree Right Side View $\\star\\star$"},{"location":"cpp/0101-0200/0191-0200/#200-number-of-islands-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int numIslands ( vector < vector < char >>& grid ) { if ( grid . empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> visited ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( ! visited [ i ][ j ] && grid [ i ][ j ] == '1' ) { ++ ans ; dfs ( grid , i , j , visited ); } return ans ; } private : void dfs ( vector < vector < char >>& grid , int i , int j , vector < vector < bool >>& visited ) { if ( i < 0 || j < 0 || i >= grid . size () || j >= grid [ 0 ]. size () || visited [ i ][ j ] || grid [ i ][ j ] == '0' ) return ; visited [ i ][ j ] = true ; dfs ( grid , i + 1 , j , visited ); dfs ( grid , i - 1 , j , visited ); dfs ( grid , i , j + 1 , visited ); dfs ( grid , i , j - 1 , visited ); } };","title":"200. Number of Islands $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/","text":"201. Bitwise AND of Numbers Range $\\star\\star$ 1 2 3 4 5 6 class Solution { public : int rangeBitwiseAnd ( int m , int n ) { return m < n ? rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 : m ; } }; 202. Happy Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool isHappy ( int n ) { int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } if ( slow == 1 ) return true ; return false ; } private : int helper ( int n ) { int sum = 0 ; while ( n ) { sum += pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } }; 203. Remove Linked List Elements $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : ListNode * removeElements ( ListNode * head , int val ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * curr = & dummy ; while ( curr ) { ListNode * next = curr -> next ; while ( next && next -> val == val ) next = next -> next ; curr -> next = next ; curr = next ; } return dummy . next ; } }; 204. Count Primes $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int countPrimes ( int n ) { if ( n <= 2 ) return 0 ; vector < bool > prime ( n , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i < sqrt ( n ); ++ i ) if ( prime [ i ]) for ( int j = i * 2 ; j < n ; j += i ) prime [ j ] = false ; return count ( prime . begin (), prime . end (), true ); } }; 205. Isomorphic Strings $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isIsomorphic ( string s , string t ) { unordered_map < char , int > map_s ; unordered_map < char , int > map_t ; for ( int i = 0 ; i < s . length (); ++ i ) { if ( map_s [ s [ i ]] != map_t [ t [ i ]]) return false ; map_s [ s [ i ]] = i + 1 ; map_t [ t [ i ]] = i + 1 ; } return true ; } }; 206. Reverse Linked List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { auto next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } }; 207. Course Schedule $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool canFinish ( int numCourses , vector < vector < int >>& prerequisites ) { vector < vector < int >> graph ( numCourses ); vector < int > visited ( numCourses , 0 ); for ( vector < int >& prerequisite : prerequisites ) graph [ prerequisite [ 1 ]]. push_back ( prerequisite [ 0 ]); for ( int i = 0 ; i < numCourses ; ++ i ) if ( dfs ( graph , visited , i )) return false ; return true ; } private : bool dfs ( vector < vector < int >>& graph , vector < int >& visited , int curr ) { if ( visited [ curr ] == 1 ) return true ; if ( visited [ curr ] == 2 ) return false ; visited [ curr ] = 1 ; for ( int neighbor : graph [ curr ]) if ( dfs ( graph , visited , neighbor )) return true ; visited [ curr ] = 2 ; return false ; } }; 208. Implement Trie (Prefix Tree) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Trie { public : void insert ( string word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> isWord = true ; } bool search ( string word ) { TrieNode * node = find ( word ); return node && node -> isWord ; } bool startsWith ( string prefix ) { return find ( prefix ); } private : struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; TrieNode root ; TrieNode * find ( string & prefix ) { TrieNode * node = & root ; for ( char c : prefix ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) return nullptr ; node = next ; } return node ; } }; 209. Minimum Size Subarray Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int minSubArrayLen ( int s , vector < int >& nums ) { int ans = INT_MAX ; int sum = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; while ( sum >= s ) { ans = min ( ans , i - j + 1 ); sum -= nums [ j ++ ]; } } return ans != INT_MAX ? ans : 0 ; } }; 210. Course Schedule II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < int > findOrder ( int numCourses , vector < vector < int >>& prerequisites ) { vector < int > ans ; vector < vector < int >> graph ( numCourses ); vector < int > visited ( numCourses , 0 ); for ( vector < int >& prerequisite : prerequisites ) graph [ prerequisite [ 0 ]]. push_back ( prerequisite [ 1 ]); for ( int i = 0 ; i < numCourses ; ++ i ) if ( dfs ( graph , visited , i , ans )) return {}; return ans ; } private : bool dfs ( vector < vector < int >>& graph , vector < int >& visited , int curr , vector < int >& ans ) { if ( visited [ curr ] == 1 ) return true ; if ( visited [ curr ] == 2 ) return false ; visited [ curr ] = 1 ; for ( int neighbor : graph [ curr ]) if ( dfs ( graph , visited , neighbor , ans )) return true ; visited [ curr ] = 2 ; ans . push_back ( curr ); return false ; } };","title":"0201-0210"},{"location":"cpp/0201-0300/0201-0210/#201-bitwise-and-of-numbers-range-starstar","text":"1 2 3 4 5 6 class Solution { public : int rangeBitwiseAnd ( int m , int n ) { return m < n ? rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 : m ; } };","title":"201. Bitwise AND of Numbers Range $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/#202-happy-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool isHappy ( int n ) { int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } if ( slow == 1 ) return true ; return false ; } private : int helper ( int n ) { int sum = 0 ; while ( n ) { sum += pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } };","title":"202. Happy Number $\\star$"},{"location":"cpp/0201-0300/0201-0210/#203-remove-linked-list-elements-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : ListNode * removeElements ( ListNode * head , int val ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * curr = & dummy ; while ( curr ) { ListNode * next = curr -> next ; while ( next && next -> val == val ) next = next -> next ; curr -> next = next ; curr = next ; } return dummy . next ; } };","title":"203. Remove Linked List Elements $\\star$"},{"location":"cpp/0201-0300/0201-0210/#204-count-primes-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int countPrimes ( int n ) { if ( n <= 2 ) return 0 ; vector < bool > prime ( n , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i < sqrt ( n ); ++ i ) if ( prime [ i ]) for ( int j = i * 2 ; j < n ; j += i ) prime [ j ] = false ; return count ( prime . begin (), prime . end (), true ); } };","title":"204. Count Primes $\\star$"},{"location":"cpp/0201-0300/0201-0210/#205-isomorphic-strings-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isIsomorphic ( string s , string t ) { unordered_map < char , int > map_s ; unordered_map < char , int > map_t ; for ( int i = 0 ; i < s . length (); ++ i ) { if ( map_s [ s [ i ]] != map_t [ t [ i ]]) return false ; map_s [ s [ i ]] = i + 1 ; map_t [ t [ i ]] = i + 1 ; } return true ; } };","title":"205. Isomorphic Strings $\\star$"},{"location":"cpp/0201-0300/0201-0210/#206-reverse-linked-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { auto next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } };","title":"206. Reverse Linked List $\\star$"},{"location":"cpp/0201-0300/0201-0210/#207-course-schedule-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool canFinish ( int numCourses , vector < vector < int >>& prerequisites ) { vector < vector < int >> graph ( numCourses ); vector < int > visited ( numCourses , 0 ); for ( vector < int >& prerequisite : prerequisites ) graph [ prerequisite [ 1 ]]. push_back ( prerequisite [ 0 ]); for ( int i = 0 ; i < numCourses ; ++ i ) if ( dfs ( graph , visited , i )) return false ; return true ; } private : bool dfs ( vector < vector < int >>& graph , vector < int >& visited , int curr ) { if ( visited [ curr ] == 1 ) return true ; if ( visited [ curr ] == 2 ) return false ; visited [ curr ] = 1 ; for ( int neighbor : graph [ curr ]) if ( dfs ( graph , visited , neighbor )) return true ; visited [ curr ] = 2 ; return false ; } };","title":"207. Course Schedule $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/#208-implement-trie-prefix-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Trie { public : void insert ( string word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> isWord = true ; } bool search ( string word ) { TrieNode * node = find ( word ); return node && node -> isWord ; } bool startsWith ( string prefix ) { return find ( prefix ); } private : struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; TrieNode root ; TrieNode * find ( string & prefix ) { TrieNode * node = & root ; for ( char c : prefix ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) return nullptr ; node = next ; } return node ; } };","title":"208. Implement Trie (Prefix Tree) $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/#209-minimum-size-subarray-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int minSubArrayLen ( int s , vector < int >& nums ) { int ans = INT_MAX ; int sum = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; while ( sum >= s ) { ans = min ( ans , i - j + 1 ); sum -= nums [ j ++ ]; } } return ans != INT_MAX ? ans : 0 ; } };","title":"209. Minimum Size Subarray Sum $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/#210-course-schedule-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < int > findOrder ( int numCourses , vector < vector < int >>& prerequisites ) { vector < int > ans ; vector < vector < int >> graph ( numCourses ); vector < int > visited ( numCourses , 0 ); for ( vector < int >& prerequisite : prerequisites ) graph [ prerequisite [ 0 ]]. push_back ( prerequisite [ 1 ]); for ( int i = 0 ; i < numCourses ; ++ i ) if ( dfs ( graph , visited , i , ans )) return {}; return ans ; } private : bool dfs ( vector < vector < int >>& graph , vector < int >& visited , int curr , vector < int >& ans ) { if ( visited [ curr ] == 1 ) return true ; if ( visited [ curr ] == 2 ) return false ; visited [ curr ] = 1 ; for ( int neighbor : graph [ curr ]) if ( dfs ( graph , visited , neighbor , ans )) return true ; visited [ curr ] = 2 ; ans . push_back ( curr ); return false ; } };","title":"210. Course Schedule II $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/","text":"211. Add and Search Word - Data structure design $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class WordDictionary { public : void addWord ( string word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> isWord = true ; } bool search ( string word ) { return dfs ( word , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; TrieNode root ; bool dfs ( const string & word , int depth , TrieNode * node ) { if ( depth == word . length ()) return node -> isWord ; if ( word [ depth ] != '.' ) { TrieNode * next = node -> children [ word [ depth ] - 'a' ]; return next ? dfs ( word , depth + 1 , next ) : false ; } for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ] && dfs ( word , depth + 1 , node -> children [ i ])) return true ; return false ; } }; 212. Word Search II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { for ( const string & word : words ) insert ( word ); vector < string > ans ; for ( int i = 0 ; i < board . size (); ++ i ) for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) dfs ( board , i , j , & root , ans ); return ans ; } private : struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete ( child ); } vector < TrieNode *> children ; const string * word ; }; TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> word = & word ; } void dfs ( vector < vector < char >>& board , int i , int j , TrieNode * node , vector < string >& ans ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] == '*' ) return ; char c = board [ i ][ j ]; TrieNode * next = node -> children [ c - 'a' ]; if ( ! next ) return ; if ( next -> word ) { ans . push_back ( * next -> word ); next -> word = nullptr ; } board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j , next , ans ); dfs ( board , i - 1 , j , next , ans ); dfs ( board , i , j + 1 , next , ans ); dfs ( board , i , j - 1 , next , ans ); board [ i ][ j ] = c ; } }; 213. House Robber II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int rob ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; if ( nums . size () < 2 ) return nums [ 0 ]; const int n = nums . size (); return max ( rob ( nums , 0 , n - 2 ), rob ( nums , 1 , n - 1 )); } private : int rob ( vector < int >& nums , int l , int r ) { int dp1 = 0 ; int dp2 = 0 ; for ( int i = l ; i <= r ; ++ i ) { int temp = dp1 ; dp1 = max ( dp1 , dp2 + nums [ i ]); dp2 = temp ; } return dp1 ; } }; 214. Shortest Palindrome $\\star\\star\\star$ 215. Kth Largest Element in an Array $\\star\\star$ 1 2 3 4 5 6 7 8 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { nth_element ( nums . begin (), nums . begin () + k - 1 , nums . end (), greater < int > ()); return nums [ k - 1 ]; } }; 216. Combination Sum III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; vector < int > path ; dfs ( k , n , 1 , path , ans ); return ans ; } private : void dfs ( int k , int n , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( k == 0 && n == 0 ) { ans . push_back ( path ); return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . push_back ( i ); dfs ( k - 1 , n - i , i + 1 , path , ans ); path . pop_back (); } } }; 217. Contains Duplicate $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > set ; for ( int num : nums ) { if ( set . count ( num )) return true ; set . insert ( num ); } return false ; } }; 218. The Skyline Problem $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : vector < vector < int >> getSkyline ( vector < vector < int >>& buildings ) { vector < vector < int >> ans ; vector < vector < int >> events ; for ( vector < int >& building : buildings ) { events . push_back ({ building [ 0 ], building [ 2 ]}); events . push_back ({ building [ 1 ], - building [ 2 ]}); } sort ( events . begin (), events . end (), []( const vector < int >& e1 , const vector < int >& e2 ) { return e1 [ 0 ] == e2 [ 0 ] ? e1 [ 1 ] > e2 [ 1 ] : e1 [ 0 ] < e2 [ 0 ]; }); for ( vector < int >& event : events ) { int x = event [ 0 ]; int h = abs ( event [ 1 ]); if ( event [ 1 ] > 0 ) { if ( h > maxHeight ()) ans . push_back ({ x , h }); set . insert ( h ); } else { set . erase ( set . equal_range ( h ). first ); if ( h > maxHeight ()) ans . push_back ({ x , maxHeight ()}); } } return ans ; } private : multiset < int > set ; int maxHeight () const { return set . empty () ? 0 : * set . rbegin (); } }; 219. Contains Duplicate II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { unordered_set < int > set ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( i > k ) set . erase ( nums [ i - k - 1 ]); if ( set . count ( nums [ i ])) return true ; set . insert ( nums [ i ]); } return false ; } }; 220. Contains Duplicate III $\\star\\star$","title":"0211-0220"},{"location":"cpp/0201-0300/0211-0220/#211-add-and-search-word-data-structure-design-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class WordDictionary { public : void addWord ( string word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> isWord = true ; } bool search ( string word ) { return dfs ( word , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; TrieNode root ; bool dfs ( const string & word , int depth , TrieNode * node ) { if ( depth == word . length ()) return node -> isWord ; if ( word [ depth ] != '.' ) { TrieNode * next = node -> children [ word [ depth ] - 'a' ]; return next ? dfs ( word , depth + 1 , next ) : false ; } for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ] && dfs ( word , depth + 1 , node -> children [ i ])) return true ; return false ; } };","title":"211. Add and Search Word - Data structure design $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#212-word-search-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { for ( const string & word : words ) insert ( word ); vector < string > ans ; for ( int i = 0 ; i < board . size (); ++ i ) for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) dfs ( board , i , j , & root , ans ); return ans ; } private : struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete ( child ); } vector < TrieNode *> children ; const string * word ; }; TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> word = & word ; } void dfs ( vector < vector < char >>& board , int i , int j , TrieNode * node , vector < string >& ans ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] == '*' ) return ; char c = board [ i ][ j ]; TrieNode * next = node -> children [ c - 'a' ]; if ( ! next ) return ; if ( next -> word ) { ans . push_back ( * next -> word ); next -> word = nullptr ; } board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j , next , ans ); dfs ( board , i - 1 , j , next , ans ); dfs ( board , i , j + 1 , next , ans ); dfs ( board , i , j - 1 , next , ans ); board [ i ][ j ] = c ; } };","title":"212. Word Search II $\\star\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#213-house-robber-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int rob ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; if ( nums . size () < 2 ) return nums [ 0 ]; const int n = nums . size (); return max ( rob ( nums , 0 , n - 2 ), rob ( nums , 1 , n - 1 )); } private : int rob ( vector < int >& nums , int l , int r ) { int dp1 = 0 ; int dp2 = 0 ; for ( int i = l ; i <= r ; ++ i ) { int temp = dp1 ; dp1 = max ( dp1 , dp2 + nums [ i ]); dp2 = temp ; } return dp1 ; } };","title":"213. House Robber II $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#214-shortest-palindrome-starstarstar","text":"","title":"214. Shortest Palindrome $\\star\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#215-kth-largest-element-in-an-array-starstar","text":"1 2 3 4 5 6 7 8 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { nth_element ( nums . begin (), nums . begin () + k - 1 , nums . end (), greater < int > ()); return nums [ k - 1 ]; } };","title":"215. Kth Largest Element in an Array $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#216-combination-sum-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; vector < int > path ; dfs ( k , n , 1 , path , ans ); return ans ; } private : void dfs ( int k , int n , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( k == 0 && n == 0 ) { ans . push_back ( path ); return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . push_back ( i ); dfs ( k - 1 , n - i , i + 1 , path , ans ); path . pop_back (); } } };","title":"216. Combination Sum III $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#217-contains-duplicate-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > set ; for ( int num : nums ) { if ( set . count ( num )) return true ; set . insert ( num ); } return false ; } };","title":"217. Contains Duplicate $\\star$"},{"location":"cpp/0201-0300/0211-0220/#218-the-skyline-problem-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : vector < vector < int >> getSkyline ( vector < vector < int >>& buildings ) { vector < vector < int >> ans ; vector < vector < int >> events ; for ( vector < int >& building : buildings ) { events . push_back ({ building [ 0 ], building [ 2 ]}); events . push_back ({ building [ 1 ], - building [ 2 ]}); } sort ( events . begin (), events . end (), []( const vector < int >& e1 , const vector < int >& e2 ) { return e1 [ 0 ] == e2 [ 0 ] ? e1 [ 1 ] > e2 [ 1 ] : e1 [ 0 ] < e2 [ 0 ]; }); for ( vector < int >& event : events ) { int x = event [ 0 ]; int h = abs ( event [ 1 ]); if ( event [ 1 ] > 0 ) { if ( h > maxHeight ()) ans . push_back ({ x , h }); set . insert ( h ); } else { set . erase ( set . equal_range ( h ). first ); if ( h > maxHeight ()) ans . push_back ({ x , maxHeight ()}); } } return ans ; } private : multiset < int > set ; int maxHeight () const { return set . empty () ? 0 : * set . rbegin (); } };","title":"218. The Skyline Problem $\\star\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#219-contains-duplicate-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { unordered_set < int > set ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( i > k ) set . erase ( nums [ i - k - 1 ]); if ( set . count ( nums [ i ])) return true ; set . insert ( nums [ i ]); } return false ; } };","title":"219. Contains Duplicate II $\\star$"},{"location":"cpp/0201-0300/0211-0220/#220-contains-duplicate-iii-starstar","text":"","title":"220. Contains Duplicate III $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/","text":"221. Maximal Square $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maximalSquare ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < int > dp ( n ); int max = 0 ; int prev = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int temp = dp [ j ]; dp [ j ] = ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) ? matrix [ i ][ j ] - '0' : min ( dp [ j ], min ( dp [ j - 1 ], prev )) + 1 ; max = std :: max ( max , dp [ j ]); prev = temp ; } return max * max ; } }; 222. Count Complete Tree Nodes $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int countNodes ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { ++ ans ; TreeNode * node = queue . front (); queue . pop (); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } return ans ; } }; 223. Rectangle Area $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int computeArea ( int A , int B , int C , int D , int E , int F , int G , int H ) { long x = max ( A , E ) < min ( C , G ) ? ( min ( C , G ) - max ( A , E )) : 0 ; long y = max ( B , F ) < min ( D , H ) ? ( min ( D , H ) - max ( B , F )) : 0 ; return ( long )( C - A ) * ( long )( D - B ) + ( long )( G - E ) * ( long )( H - F ) - x * y ; } }; 224. Basic Calculator $\\star\\star\\star$ 225. Implement Stack using Queues $\\star$ 226. Invert Binary Tree $\\star$ 227. Basic Calculator II $\\star\\star$ 228. Summary Ranges $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < string > summaryRanges ( vector < int >& nums ) { vector < string > ans ; for ( int i = 0 ; i < nums . size (); ++ i ) { int begin = nums [ i ]; while ( i < nums . size () - 1 && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; int end = nums [ i ]; if ( begin == end ) ans . push_back ( to_string ( begin )); else ans . push_back ( to_string ( begin ) + \"->\" + to_string ( end )); } return ans ; } }; 229. Majority Element II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : vector < int > majorityElement ( vector < int >& nums ) { vector < int > ans ; int ans1 = 0 ; int ans2 = 1 ; int count1 = 0 ; int count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; else if ( count1 == 0 ) { ans1 = num ; ++ count1 ; } else if ( count2 == 0 ) { ans2 = num ; ++ count2 ; } else { -- count1 ; -- count2 ; } } count1 = 0 ; count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; } if ( count1 > nums . size () / 3 ) ans . push_back ( ans1 ); if ( count2 > nums . size () / 3 ) ans . push_back ( ans2 ); return ans ; } }; 230. Kth Smallest Element in a BST $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int kthSmallest ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); return nums [ k - 1 ]; } private : void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } };","title":"0221-0230"},{"location":"cpp/0201-0300/0221-0230/#221-maximal-square-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maximalSquare ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < int > dp ( n ); int max = 0 ; int prev = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int temp = dp [ j ]; dp [ j ] = ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) ? matrix [ i ][ j ] - '0' : min ( dp [ j ], min ( dp [ j - 1 ], prev )) + 1 ; max = std :: max ( max , dp [ j ]); prev = temp ; } return max * max ; } };","title":"221. Maximal Square $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#222-count-complete-tree-nodes-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int countNodes ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { ++ ans ; TreeNode * node = queue . front (); queue . pop (); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } return ans ; } };","title":"222. Count Complete Tree Nodes $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#223-rectangle-area-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int computeArea ( int A , int B , int C , int D , int E , int F , int G , int H ) { long x = max ( A , E ) < min ( C , G ) ? ( min ( C , G ) - max ( A , E )) : 0 ; long y = max ( B , F ) < min ( D , H ) ? ( min ( D , H ) - max ( B , F )) : 0 ; return ( long )( C - A ) * ( long )( D - B ) + ( long )( G - E ) * ( long )( H - F ) - x * y ; } };","title":"223. Rectangle Area $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#224-basic-calculator-starstarstar","text":"","title":"224. Basic Calculator $\\star\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#225-implement-stack-using-queues-star","text":"","title":"225. Implement Stack using Queues $\\star$"},{"location":"cpp/0201-0300/0221-0230/#226-invert-binary-tree-star","text":"","title":"226. Invert Binary Tree $\\star$"},{"location":"cpp/0201-0300/0221-0230/#227-basic-calculator-ii-starstar","text":"","title":"227. Basic Calculator II $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#228-summary-ranges-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < string > summaryRanges ( vector < int >& nums ) { vector < string > ans ; for ( int i = 0 ; i < nums . size (); ++ i ) { int begin = nums [ i ]; while ( i < nums . size () - 1 && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; int end = nums [ i ]; if ( begin == end ) ans . push_back ( to_string ( begin )); else ans . push_back ( to_string ( begin ) + \"->\" + to_string ( end )); } return ans ; } };","title":"228. Summary Ranges $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#229-majority-element-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : vector < int > majorityElement ( vector < int >& nums ) { vector < int > ans ; int ans1 = 0 ; int ans2 = 1 ; int count1 = 0 ; int count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; else if ( count1 == 0 ) { ans1 = num ; ++ count1 ; } else if ( count2 == 0 ) { ans2 = num ; ++ count2 ; } else { -- count1 ; -- count2 ; } } count1 = 0 ; count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; } if ( count1 > nums . size () / 3 ) ans . push_back ( ans1 ); if ( count2 > nums . size () / 3 ) ans . push_back ( ans2 ); return ans ; } };","title":"229. Majority Element II $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#230-kth-smallest-element-in-a-bst-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int kthSmallest ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); return nums [ k - 1 ]; } private : void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } };","title":"230. Kth Smallest Element in a BST $\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/","text":"231. Power of Two $\\star$ 232. Implement Queue using Stacks $\\star$ 233. Number of Digit One $\\star\\star\\star$ 234. Palindrome Linked List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : bool isPalindrome ( ListNode * head ) { if ( ! head || ! head -> next ) return true ; auto slow = head ; auto fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) slow = slow -> next ; slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) return false ; slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } }; 235. Lowest Common Ancestor of a Binary Search Tree $\\star$ 236. Lowest Common Ancestor of a Binary Tree $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root || root == p || root == q ) return root ; TreeNode * left = lowestCommonAncestor ( root -> left , p , q ); TreeNode * right = lowestCommonAncestor ( root -> right , p , q ); if ( ! left ) return right ; if ( ! right ) return left ; return root ; } }; 237. Delete Node in a Linked List $\\star$ 1 2 3 4 5 6 7 class Solution { public : void deleteNode ( ListNode * node ) { node -> val = node -> next -> val ; node -> next = node -> next -> next ; } }; 238. Product of Array Except Self $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > ans ( nums . size (), 0 ); ans [ 0 ] = 1 ; int r = 1 ; for ( int i = 1 ; i < nums . size (); ++ i ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]; for ( int i = nums . size () - 1 ; i >= 0 ; -- i ) { ans [ i ] *= r ; r *= nums [ i ]; } return ans ; } }; 239. Sliding Window Maximum $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; deque < int > deque ; for ( int i = 0 ; i < nums . size (); ++ i ) { while ( ! deque . empty () && nums [ i ] > deque . back ()) deque . pop_back (); deque . push_back ( nums [ i ]); if ( i - k + 1 >= 0 ) { ans . push_back ( deque . front ()); if ( nums [ i - k + 1 ] == deque . front ()) deque . pop_front (); } } return ans ; } }; 240. Search a 2D Matrix II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; int r = 0 ; int c = matrix [ 0 ]. size () - 1 ; while ( r < matrix . size () && c >= 0 ) { if ( matrix [ r ][ c ] == target ) return true ; target < matrix [ r ][ c ] ? -- c : ++ r ; } return false ; } };","title":"0231-0240"},{"location":"cpp/0201-0300/0231-0240/#231-power-of-two-star","text":"","title":"231. Power of Two $\\star$"},{"location":"cpp/0201-0300/0231-0240/#232-implement-queue-using-stacks-star","text":"","title":"232. Implement Queue using Stacks $\\star$"},{"location":"cpp/0201-0300/0231-0240/#233-number-of-digit-one-starstarstar","text":"","title":"233. Number of Digit One $\\star\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/#234-palindrome-linked-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : bool isPalindrome ( ListNode * head ) { if ( ! head || ! head -> next ) return true ; auto slow = head ; auto fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) slow = slow -> next ; slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) return false ; slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } };","title":"234. Palindrome Linked List $\\star$"},{"location":"cpp/0201-0300/0231-0240/#235-lowest-common-ancestor-of-a-binary-search-tree-star","text":"","title":"235. Lowest Common Ancestor of a Binary Search Tree $\\star$"},{"location":"cpp/0201-0300/0231-0240/#236-lowest-common-ancestor-of-a-binary-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root || root == p || root == q ) return root ; TreeNode * left = lowestCommonAncestor ( root -> left , p , q ); TreeNode * right = lowestCommonAncestor ( root -> right , p , q ); if ( ! left ) return right ; if ( ! right ) return left ; return root ; } };","title":"236. Lowest Common Ancestor of a Binary Tree $\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/#237-delete-node-in-a-linked-list-star","text":"1 2 3 4 5 6 7 class Solution { public : void deleteNode ( ListNode * node ) { node -> val = node -> next -> val ; node -> next = node -> next -> next ; } };","title":"237. Delete Node in a Linked List $\\star$"},{"location":"cpp/0201-0300/0231-0240/#238-product-of-array-except-self-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > ans ( nums . size (), 0 ); ans [ 0 ] = 1 ; int r = 1 ; for ( int i = 1 ; i < nums . size (); ++ i ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]; for ( int i = nums . size () - 1 ; i >= 0 ; -- i ) { ans [ i ] *= r ; r *= nums [ i ]; } return ans ; } };","title":"238. Product of Array Except Self $\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/#239-sliding-window-maximum-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; deque < int > deque ; for ( int i = 0 ; i < nums . size (); ++ i ) { while ( ! deque . empty () && nums [ i ] > deque . back ()) deque . pop_back (); deque . push_back ( nums [ i ]); if ( i - k + 1 >= 0 ) { ans . push_back ( deque . front ()); if ( nums [ i - k + 1 ] == deque . front ()) deque . pop_front (); } } return ans ; } };","title":"239. Sliding Window Maximum $\\star\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/#240-search-a-2d-matrix-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; int r = 0 ; int c = matrix [ 0 ]. size () - 1 ; while ( r < matrix . size () && c >= 0 ) { if ( matrix [ r ][ c ] == target ) return true ; target < matrix [ r ][ c ] ? -- c : ++ r ; } return false ; } };","title":"240. Search a 2D Matrix II $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/","text":"241. Different Ways to Add Parentheses $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > diffWaysToCompute ( string input ) { vector < int > ans ; for ( int i = 0 ; i < input . size (); ++ i ) if ( ispunct ( input [ i ])) { vector < int > left = diffWaysToCompute ( input . substr ( 0 , i )); vector < int > right = diffWaysToCompute ( input . substr ( i + 1 )); for ( int a : left ) for ( int b : right ) ans . push_back ( input [ i ] == '+' ? a + b : input [ i ] == '-' ? a - b : a * b ); } return ans . empty () ? vector < int > { stoi ( input )} : ans ; } }; 242. Valid Anagram $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isAnagram ( string s , string t ) { if ( s . length () != t . length ()) return false ; unordered_map < char , int > map ; for ( char c : s ) ++ map [ c ]; for ( char c : t ) if ( -- map [ c ] < 0 ) return false ; return true ; } }; 243. Shortest Word Distance $\\star$ 244. Shortest Word Distance II $\\star\\star$ 245. Shortest Word Distance III $\\star\\star$ 246. Strobogrammatic Number $\\star$ 247. Strobogrammatic Number II $\\star\\star$ 248. Strobogrammatic Number III $\\star\\star\\star$ 249. Group Shifted Strings $\\star\\star$ 250. Count Univalue Subtrees $\\star\\star$","title":"0241-0250"},{"location":"cpp/0201-0300/0241-0250/#241-different-ways-to-add-parentheses-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > diffWaysToCompute ( string input ) { vector < int > ans ; for ( int i = 0 ; i < input . size (); ++ i ) if ( ispunct ( input [ i ])) { vector < int > left = diffWaysToCompute ( input . substr ( 0 , i )); vector < int > right = diffWaysToCompute ( input . substr ( i + 1 )); for ( int a : left ) for ( int b : right ) ans . push_back ( input [ i ] == '+' ? a + b : input [ i ] == '-' ? a - b : a * b ); } return ans . empty () ? vector < int > { stoi ( input )} : ans ; } };","title":"241. Different Ways to Add Parentheses $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#242-valid-anagram-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isAnagram ( string s , string t ) { if ( s . length () != t . length ()) return false ; unordered_map < char , int > map ; for ( char c : s ) ++ map [ c ]; for ( char c : t ) if ( -- map [ c ] < 0 ) return false ; return true ; } };","title":"242. Valid Anagram $\\star$"},{"location":"cpp/0201-0300/0241-0250/#243-shortest-word-distance-star","text":"","title":"243. Shortest Word Distance $\\star$"},{"location":"cpp/0201-0300/0241-0250/#244-shortest-word-distance-ii-starstar","text":"","title":"244. Shortest Word Distance II $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#245-shortest-word-distance-iii-starstar","text":"","title":"245. Shortest Word Distance III $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#246-strobogrammatic-number-star","text":"","title":"246. Strobogrammatic Number $\\star$"},{"location":"cpp/0201-0300/0241-0250/#247-strobogrammatic-number-ii-starstar","text":"","title":"247. Strobogrammatic Number II $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#248-strobogrammatic-number-iii-starstarstar","text":"","title":"248. Strobogrammatic Number III $\\star\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#249-group-shifted-strings-starstar","text":"","title":"249. Group Shifted Strings $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#250-count-univalue-subtrees-starstar","text":"","title":"250. Count Univalue Subtrees $\\star\\star$"},{"location":"cpp/0201-0300/0251-0260/","text":"251. Flatten 2D Vector $\\star\\star$ 252. Meeting Rooms $\\star$ 253. Meeting Rooms II $\\star\\star$ 254. Factor Combinations $\\star\\star$ 255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$ 256. Paint House $\\star$ 257. Binary Tree Paths $\\star$ 258. Add Digits $\\star$ 259. 3Sum Smaller $\\star\\star$ 260. Single Number III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { vector < int > ans ( 2 ); int xor_ = accumulate ( nums . begin (), nums . end (), 0 , bit_xor < int > ()); xor_ &= - xor_ ; for ( int num : nums ) { if ( num & xor_ ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; } return ans ; } };","title":"0251-0260"},{"location":"cpp/0201-0300/0251-0260/#251-flatten-2d-vector-starstar","text":"","title":"251. Flatten 2D Vector $\\star\\star$"},{"location":"cpp/0201-0300/0251-0260/#252-meeting-rooms-star","text":"","title":"252. Meeting Rooms $\\star$"},{"location":"cpp/0201-0300/0251-0260/#253-meeting-rooms-ii-starstar","text":"","title":"253. Meeting Rooms II $\\star\\star$"},{"location":"cpp/0201-0300/0251-0260/#254-factor-combinations-starstar","text":"","title":"254. Factor Combinations $\\star\\star$"},{"location":"cpp/0201-0300/0251-0260/#255-verify-preorder-sequence-in-binary-search-tree-starstar","text":"","title":"255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$"},{"location":"cpp/0201-0300/0251-0260/#256-paint-house-star","text":"","title":"256. Paint House $\\star$"},{"location":"cpp/0201-0300/0251-0260/#257-binary-tree-paths-star","text":"","title":"257. Binary Tree Paths $\\star$"},{"location":"cpp/0201-0300/0251-0260/#258-add-digits-star","text":"","title":"258. Add Digits $\\star$"},{"location":"cpp/0201-0300/0251-0260/#259-3sum-smaller-starstar","text":"","title":"259. 3Sum Smaller $\\star\\star$"},{"location":"cpp/0201-0300/0251-0260/#260-single-number-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { vector < int > ans ( 2 ); int xor_ = accumulate ( nums . begin (), nums . end (), 0 , bit_xor < int > ()); xor_ &= - xor_ ; for ( int num : nums ) { if ( num & xor_ ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; } return ans ; } };","title":"260. Single Number III $\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/","text":"261. Graph Valid Tree $\\star\\star$ 262. Trips and Users $\\star\\star\\star$ 263. Ugly Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isUgly ( int num ) { if ( num == 0 ) return false ; vector < int > factors { 2 , 3 , 5 }; for ( int factor : factors ) while ( num % factor == 0 ) num /= factor ; return num == 1 ; } }; 264. Ugly Number II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int nthUglyNumber ( int n ) { vector < int > nums { 1 }; int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( nums . size () < n ) { int next2 = nums [ i2 ] * 2 ; int next3 = nums [ i3 ] * 3 ; int next5 = nums [ i5 ] * 5 ; int next = min ( next2 , min ( next3 , next5 )); if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; nums . push_back ( next ); } return nums . back (); } }; 265. Paint House II $\\star\\star\\star$ 266. Palindrome Permutation $\\star$ 267. Palindrome Permutation II $\\star\\star$ 268. Missing Number $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int missingNumber ( vector < int >& nums ) { int ans = nums . size (); for ( int i = 0 ; i < nums . size (); ++ i ) ans ^= i ^ nums [ i ]; return ans ; } }; 269. Alien Dictionary $\\star\\star\\star$ 270. Closest Binary Search Tree Value $\\star$","title":"0261-0270"},{"location":"cpp/0201-0300/0261-0270/#261-graph-valid-tree-starstar","text":"","title":"261. Graph Valid Tree $\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#262-trips-and-users-starstarstar","text":"","title":"262. Trips and Users $\\star\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#263-ugly-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isUgly ( int num ) { if ( num == 0 ) return false ; vector < int > factors { 2 , 3 , 5 }; for ( int factor : factors ) while ( num % factor == 0 ) num /= factor ; return num == 1 ; } };","title":"263. Ugly Number $\\star$"},{"location":"cpp/0201-0300/0261-0270/#264-ugly-number-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int nthUglyNumber ( int n ) { vector < int > nums { 1 }; int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( nums . size () < n ) { int next2 = nums [ i2 ] * 2 ; int next3 = nums [ i3 ] * 3 ; int next5 = nums [ i5 ] * 5 ; int next = min ( next2 , min ( next3 , next5 )); if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; nums . push_back ( next ); } return nums . back (); } };","title":"264. Ugly Number II $\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#265-paint-house-ii-starstarstar","text":"","title":"265. Paint House II $\\star\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#266-palindrome-permutation-star","text":"","title":"266. Palindrome Permutation $\\star$"},{"location":"cpp/0201-0300/0261-0270/#267-palindrome-permutation-ii-starstar","text":"","title":"267. Palindrome Permutation II $\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#268-missing-number-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int missingNumber ( vector < int >& nums ) { int ans = nums . size (); for ( int i = 0 ; i < nums . size (); ++ i ) ans ^= i ^ nums [ i ]; return ans ; } };","title":"268. Missing Number $\\star$"},{"location":"cpp/0201-0300/0261-0270/#269-alien-dictionary-starstarstar","text":"","title":"269. Alien Dictionary $\\star\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#270-closest-binary-search-tree-value-star","text":"","title":"270. Closest Binary Search Tree Value $\\star$"},{"location":"cpp/0201-0300/0271-0280/","text":"271. Encode and Decode Strings $\\star\\star$ 272. Closest Binary Search Tree Value II $\\star\\star\\star$ 273. Integer to English Words $\\star\\star\\star$ 274. H-Index $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int hIndex ( vector < int >& citations ) { sort ( citations . begin (), citations . end ()); for ( int i = 0 ; i < citations . size (); ++ i ) if ( citations [ i ] >= citations . size () - i ) return citations . size () - i ; return 0 ; } }; 275. H-Index II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int hIndex ( vector < int >& citations ) { int l = 0 ; int r = citations . size () - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( citations [ m ] == citations . size () - m ) return citations [ m ]; else if ( citations [ m ] > citations . size () - m ) r = m - 1 ; else l = m + 1 ; } return citations . size () - ( r + 1 ); } }; 276. Paint Fence $\\star$ 277. Find the Celebrity $\\star\\star$ 278. First Bad Version $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool isBadVersion ( int version ); class Solution { public : int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } }; 279. Perfect Squares $\\star\\star$ 280. Wiggle Sort $\\star\\star$","title":"0271-0280"},{"location":"cpp/0201-0300/0271-0280/#271-encode-and-decode-strings-starstar","text":"","title":"271. Encode and Decode Strings $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#272-closest-binary-search-tree-value-ii-starstarstar","text":"","title":"272. Closest Binary Search Tree Value II $\\star\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#273-integer-to-english-words-starstarstar","text":"","title":"273. Integer to English Words $\\star\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#274-h-index-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int hIndex ( vector < int >& citations ) { sort ( citations . begin (), citations . end ()); for ( int i = 0 ; i < citations . size (); ++ i ) if ( citations [ i ] >= citations . size () - i ) return citations . size () - i ; return 0 ; } };","title":"274. H-Index $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#275-h-index-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int hIndex ( vector < int >& citations ) { int l = 0 ; int r = citations . size () - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( citations [ m ] == citations . size () - m ) return citations [ m ]; else if ( citations [ m ] > citations . size () - m ) r = m - 1 ; else l = m + 1 ; } return citations . size () - ( r + 1 ); } };","title":"275. H-Index II $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#276-paint-fence-star","text":"","title":"276. Paint Fence $\\star$"},{"location":"cpp/0201-0300/0271-0280/#277-find-the-celebrity-starstar","text":"","title":"277. Find the Celebrity $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#278-first-bad-version-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool isBadVersion ( int version ); class Solution { public : int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } };","title":"278. First Bad Version $\\star$"},{"location":"cpp/0201-0300/0271-0280/#279-perfect-squares-starstar","text":"","title":"279. Perfect Squares $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#280-wiggle-sort-starstar","text":"","title":"280. Wiggle Sort $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/","text":"281. Zigzag Iterator $\\star\\star$ 282. Expression Add Operators $\\star\\star\\star$ 283. Move Zeroes $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : void moveZeroes ( vector < int >& nums ) { int j = 0 ; for ( int num : nums ) if ( num != 0 ) nums [ j ++ ] = num ; for ( int i = j ; i < nums . size (); ++ i ) nums [ i ] = 0 ; } }; 284. Peeking Iterator $\\star\\star$ 285. Inorder Successor in BST $\\star\\star$ 286. Walls and Gates $\\star\\star$ 287. Find the Duplicate Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findDuplicate ( vector < int >& nums ) { int slow = nums [ nums [ 0 ]]; int fast = nums [ nums [ nums [ 0 ]]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } slow = nums [ 0 ]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } }; 288. Unique Word Abbreviation $\\star\\star$ 289. Game of Life $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) ones += board [ y ][ x ] & 1 ; if (( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) || ( board [ i ][ j ] == 0 && ones == 3 )) board [ i ][ j ] |= 0 b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] >>= 1 ; } }; 290. Word Pattern $\\star$","title":"0281-0290"},{"location":"cpp/0201-0300/0281-0290/#281-zigzag-iterator-starstar","text":"","title":"281. Zigzag Iterator $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#282-expression-add-operators-starstarstar","text":"","title":"282. Expression Add Operators $\\star\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#283-move-zeroes-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : void moveZeroes ( vector < int >& nums ) { int j = 0 ; for ( int num : nums ) if ( num != 0 ) nums [ j ++ ] = num ; for ( int i = j ; i < nums . size (); ++ i ) nums [ i ] = 0 ; } };","title":"283. Move Zeroes $\\star$"},{"location":"cpp/0201-0300/0281-0290/#284-peeking-iterator-starstar","text":"","title":"284. Peeking Iterator $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#285-inorder-successor-in-bst-starstar","text":"","title":"285. Inorder Successor in BST $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#286-walls-and-gates-starstar","text":"","title":"286. Walls and Gates $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#287-find-the-duplicate-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findDuplicate ( vector < int >& nums ) { int slow = nums [ nums [ 0 ]]; int fast = nums [ nums [ nums [ 0 ]]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } slow = nums [ 0 ]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } };","title":"287. Find the Duplicate Number $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#288-unique-word-abbreviation-starstar","text":"","title":"288. Unique Word Abbreviation $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#289-game-of-life-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) ones += board [ y ][ x ] & 1 ; if (( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) || ( board [ i ][ j ] == 0 && ones == 3 )) board [ i ][ j ] |= 0 b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] >>= 1 ; } };","title":"289. Game of Life $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#290-word-pattern-star","text":"","title":"290. Word Pattern $\\star$"},{"location":"cpp/0201-0300/0291-0300/","text":"291. Word Pattern II $\\star\\star\\star$ 292. Nim Game $\\star$ 293. Flip Game $\\star$ 294. Flip Game II $\\star\\star$ 295. Find Median from Data Stream $\\star\\star\\star$ 296. Best Meeting Point $\\star\\star\\star$ 297. Serialize and Deserialize Binary Tree $\\star\\star\\star$ 298. Binary Tree Longest Consecutive Sequence $\\star\\star$ 299. Bulls and Cows $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getHint ( string secans , string guess ) { int A = 0 ; int B = 0 ; map < char , int > map1 ; map < char , int > map2 ; for ( int i = 0 ; i < secans . length (); ++ i ) { if ( secans [ i ] == guess [ i ]) ++ A ; else { ++ map1 [ secans [ i ]]; ++ map2 [ guess [ i ]]; } } for ( int i = 0 ; i <= 9 ; ++ i ) B += min ( map1 [ '0' + i ], map2 [ '0' + i ]); return to_string ( A ) + \"A\" + to_string ( B ) + \"B\" ; } }; 300. Longest Increasing Subsequence $\\star\\star$","title":"0291-0300"},{"location":"cpp/0201-0300/0291-0300/#291-word-pattern-ii-starstarstar","text":"","title":"291. Word Pattern II $\\star\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#292-nim-game-star","text":"","title":"292. Nim Game $\\star$"},{"location":"cpp/0201-0300/0291-0300/#293-flip-game-star","text":"","title":"293. Flip Game $\\star$"},{"location":"cpp/0201-0300/0291-0300/#294-flip-game-ii-starstar","text":"","title":"294. Flip Game II $\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#295-find-median-from-data-stream-starstarstar","text":"","title":"295. Find Median from Data Stream $\\star\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#296-best-meeting-point-starstarstar","text":"","title":"296. Best Meeting Point $\\star\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#297-serialize-and-deserialize-binary-tree-starstarstar","text":"","title":"297. Serialize and Deserialize Binary Tree $\\star\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#298-binary-tree-longest-consecutive-sequence-starstar","text":"","title":"298. Binary Tree Longest Consecutive Sequence $\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#299-bulls-and-cows-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getHint ( string secans , string guess ) { int A = 0 ; int B = 0 ; map < char , int > map1 ; map < char , int > map2 ; for ( int i = 0 ; i < secans . length (); ++ i ) { if ( secans [ i ] == guess [ i ]) ++ A ; else { ++ map1 [ secans [ i ]]; ++ map2 [ guess [ i ]]; } } for ( int i = 0 ; i <= 9 ; ++ i ) B += min ( map1 [ '0' + i ], map2 [ '0' + i ]); return to_string ( A ) + \"A\" + to_string ( B ) + \"B\" ; } };","title":"299. Bulls and Cows $\\star$"},{"location":"cpp/0201-0300/0291-0300/#300-longest-increasing-subsequence-starstar","text":"","title":"300. Longest Increasing Subsequence $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/","text":"301. Remove Invalid Parentheses $\\star\\star\\star$ 302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$ 303. Range Sum Query - Immutable $\\star$ 304. Range Sum Query 2D - Immutable $\\star\\star$ 305. Number of Islands II $\\star\\star\\star$ 306. Additive Number $\\star\\star$ 307. Range Sum Query - Mutable $\\star\\star$ 308. Range Sum Query 2D - Mutable $\\star\\star\\star$ 309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; int prev = 0 ; for ( int price : prices ) { int cache = sell ; sell = max ( sell , hold + price ); hold = max ( hold , prev - price ); prev = cache ; } return sell ; } }; 310. Minimum Height Trees $\\star\\star$","title":"0301-0310"},{"location":"cpp/0301-0400/0301-0310/#301-remove-invalid-parentheses-starstarstar","text":"","title":"301. Remove Invalid Parentheses $\\star\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#302-smallest-rectangle-enclosing-black-pixels-starstarstar","text":"","title":"302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#303-range-sum-query-immutable-star","text":"","title":"303. Range Sum Query - Immutable $\\star$"},{"location":"cpp/0301-0400/0301-0310/#304-range-sum-query-2d-immutable-starstar","text":"","title":"304. Range Sum Query 2D - Immutable $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#305-number-of-islands-ii-starstarstar","text":"","title":"305. Number of Islands II $\\star\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#306-additive-number-starstar","text":"","title":"306. Additive Number $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#307-range-sum-query-mutable-starstar","text":"","title":"307. Range Sum Query - Mutable $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#308-range-sum-query-2d-mutable-starstarstar","text":"","title":"308. Range Sum Query 2D - Mutable $\\star\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#309-best-time-to-buy-and-sell-stock-with-cooldown-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; int prev = 0 ; for ( int price : prices ) { int cache = sell ; sell = max ( sell , hold + price ); hold = max ( hold , prev - price ); prev = cache ; } return sell ; } };","title":"309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#310-minimum-height-trees-starstar","text":"","title":"310. Minimum Height Trees $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/","text":"311. Sparse Matrix Multiplication $\\star\\star$ 312. Burst Balloons $\\star\\star\\star$ 313. Super Ugly Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { const int k = primes . size (); vector < int > nums { 1 }; vector < int > indices ( k ); while ( nums . size () < n ) { vector < int > nexts ( k ); for ( int i = 0 ; i < k ; ++ i ) nexts [ i ] = nums [ indices [ i ]] * primes [ i ]; int next = accumulate ( nexts . begin (), nexts . end (), INT_MAX , []( int a , int b ) { return min ( a , b ); }); for ( int i = 0 ; i < k ; ++ i ) if ( next == nexts [ i ]) ++ indices [ i ]; nums . push_back ( next ); } return nums . back (); } }; 314. Binary Tree Vertical Order Traversal $\\star\\star$ 315. Count of Smaller Numbers After Self $\\star\\star\\star$ 316. Remove Duplicate Letters $\\star\\star\\star$ 317. Shortest Distance from All Buildings $\\star\\star\\star$ 318. Maximum Product of Word Lengths $\\star\\star$ 319. Bulb Switcher $\\star\\star$ 1 2 3 4 class Solution { public : int bulbSwitch ( int n ) { return sqrt ( n ); } }; 320. Generalized Abbreviation $\\star\\star$","title":"0311-0320"},{"location":"cpp/0301-0400/0311-0320/#311-sparse-matrix-multiplication-starstar","text":"","title":"311. Sparse Matrix Multiplication $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#312-burst-balloons-starstarstar","text":"","title":"312. Burst Balloons $\\star\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#313-super-ugly-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { const int k = primes . size (); vector < int > nums { 1 }; vector < int > indices ( k ); while ( nums . size () < n ) { vector < int > nexts ( k ); for ( int i = 0 ; i < k ; ++ i ) nexts [ i ] = nums [ indices [ i ]] * primes [ i ]; int next = accumulate ( nexts . begin (), nexts . end (), INT_MAX , []( int a , int b ) { return min ( a , b ); }); for ( int i = 0 ; i < k ; ++ i ) if ( next == nexts [ i ]) ++ indices [ i ]; nums . push_back ( next ); } return nums . back (); } };","title":"313. Super Ugly Number $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#314-binary-tree-vertical-order-traversal-starstar","text":"","title":"314. Binary Tree Vertical Order Traversal $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#315-count-of-smaller-numbers-after-self-starstarstar","text":"","title":"315. Count of Smaller Numbers After Self $\\star\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#316-remove-duplicate-letters-starstarstar","text":"","title":"316. Remove Duplicate Letters $\\star\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#317-shortest-distance-from-all-buildings-starstarstar","text":"","title":"317. Shortest Distance from All Buildings $\\star\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#318-maximum-product-of-word-lengths-starstar","text":"","title":"318. Maximum Product of Word Lengths $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#319-bulb-switcher-starstar","text":"1 2 3 4 class Solution { public : int bulbSwitch ( int n ) { return sqrt ( n ); } };","title":"319. Bulb Switcher $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#320-generalized-abbreviation-starstar","text":"","title":"320. Generalized Abbreviation $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/","text":"321. Create Maximum Number $\\star\\star\\star$ 322. Coin Change $\\star\\star$ 323. Number of Connected Components in an Undirected Graph $\\star\\star$ 324. Wiggle Sort II $\\star\\star$ 325. Maximum Size Subarray Sum Equals k $\\star\\star$ 326. Power of Three $\\star$ 327. Count of Range Sum $\\star\\star\\star$ 328. Odd Even Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : ListNode * oddEvenList ( ListNode * head ) { if ( ! head ) return NULL ; ListNode dummyOdd ( 0 ); ListNode dummyEven ( 0 ); ListNode * prevOdd = & dummyOdd ; ListNode * prevEven = & dummyEven ; int index = 0 ; while ( head ) { auto next = head -> next ; head -> next = NULL ; if ( index ++ & 1 ) { prevEven -> next = head ; prevEven = head ; } else { prevOdd -> next = head ; prevOdd = head ; } head = next ; } prevOdd -> next = dummyEven . next ; return dummyOdd . next ; } }; 329. Longest Increasing Path in a Matrix $\\star\\star\\star$ 330. Patching Array $\\star\\star\\star$","title":"0321-0330"},{"location":"cpp/0301-0400/0321-0330/#321-create-maximum-number-starstarstar","text":"","title":"321. Create Maximum Number $\\star\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#322-coin-change-starstar","text":"","title":"322. Coin Change $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#323-number-of-connected-components-in-an-undirected-graph-starstar","text":"","title":"323. Number of Connected Components in an Undirected Graph $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#324-wiggle-sort-ii-starstar","text":"","title":"324. Wiggle Sort II $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#325-maximum-size-subarray-sum-equals-k-starstar","text":"","title":"325. Maximum Size Subarray Sum Equals k $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#326-power-of-three-star","text":"","title":"326. Power of Three $\\star$"},{"location":"cpp/0301-0400/0321-0330/#327-count-of-range-sum-starstarstar","text":"","title":"327. Count of Range Sum $\\star\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#328-odd-even-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : ListNode * oddEvenList ( ListNode * head ) { if ( ! head ) return NULL ; ListNode dummyOdd ( 0 ); ListNode dummyEven ( 0 ); ListNode * prevOdd = & dummyOdd ; ListNode * prevEven = & dummyEven ; int index = 0 ; while ( head ) { auto next = head -> next ; head -> next = NULL ; if ( index ++ & 1 ) { prevEven -> next = head ; prevEven = head ; } else { prevOdd -> next = head ; prevOdd = head ; } head = next ; } prevOdd -> next = dummyEven . next ; return dummyOdd . next ; } };","title":"328. Odd Even Linked List $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#329-longest-increasing-path-in-a-matrix-starstarstar","text":"","title":"329. Longest Increasing Path in a Matrix $\\star\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#330-patching-array-starstarstar","text":"","title":"330. Patching Array $\\star\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/","text":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$ 332. Reconstruct Itinerary $\\star\\star$ 333. Largest BST Subtree $\\star\\star$ 334. Increasing Triplet Subsequence $\\star\\star$ 335. Self Crossing $\\star\\star\\star$ 336. Palindrome Pairs $\\star\\star\\star$ 337. House Robber III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int rob ( TreeNode * root ) { vector < int > ans = helper ( root ); return max ( ans [ 0 ], ans [ 1 ]); } vector < int > helper ( TreeNode * root ) { if ( ! root ) return { 0 , 0 }; vector < int > left = helper ( root -> left ); vector < int > right = helper ( root -> right ); return { max ( left [ 0 ], left [ 1 ]) + max ( right [ 0 ], right [ 1 ]), root -> val + left [ 0 ] + right [ 0 ]}; } }; 338. Counting Bits $\\star\\star$ 339. Nested List Weight Sum $\\star$ 340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$","title":"0331-0340"},{"location":"cpp/0301-0400/0331-0340/#331-verify-preorder-serialization-of-a-binary-tree-starstar","text":"","title":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#332-reconstruct-itinerary-starstar","text":"","title":"332. Reconstruct Itinerary $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#333-largest-bst-subtree-starstar","text":"","title":"333. Largest BST Subtree $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#334-increasing-triplet-subsequence-starstar","text":"","title":"334. Increasing Triplet Subsequence $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#335-self-crossing-starstarstar","text":"","title":"335. Self Crossing $\\star\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#336-palindrome-pairs-starstarstar","text":"","title":"336. Palindrome Pairs $\\star\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#337-house-robber-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int rob ( TreeNode * root ) { vector < int > ans = helper ( root ); return max ( ans [ 0 ], ans [ 1 ]); } vector < int > helper ( TreeNode * root ) { if ( ! root ) return { 0 , 0 }; vector < int > left = helper ( root -> left ); vector < int > right = helper ( root -> right ); return { max ( left [ 0 ], left [ 1 ]) + max ( right [ 0 ], right [ 1 ]), root -> val + left [ 0 ] + right [ 0 ]}; } };","title":"337. House Robber III $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#338-counting-bits-starstar","text":"","title":"338. Counting Bits $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#339-nested-list-weight-sum-star","text":"","title":"339. Nested List Weight Sum $\\star$"},{"location":"cpp/0301-0400/0331-0340/#340-longest-substring-with-at-most-k-distinct-characters-starstarstar","text":"","title":"340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/","text":"341. Flatten Nested List Iterator $\\star\\star$ 342. Power of Four $\\star$ 343. Integer Break $\\star\\star$ 344. Reverse String $\\star$ 345. Reverse Vowels of a String $\\star$ 346. Moving Average from Data Stream $\\star$ 347. Top K Frequent Elements $\\star\\star$ 348. Design Tic-Tac-Toe $\\star\\star$ 349. Intersection of Two Arrays $\\star$ 350. Intersection of Two Arrays II $\\star$","title":"0341-0350"},{"location":"cpp/0301-0400/0341-0350/#341-flatten-nested-list-iterator-starstar","text":"","title":"341. Flatten Nested List Iterator $\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/#342-power-of-four-star","text":"","title":"342. Power of Four $\\star$"},{"location":"cpp/0301-0400/0341-0350/#343-integer-break-starstar","text":"","title":"343. Integer Break $\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/#344-reverse-string-star","text":"","title":"344. Reverse String $\\star$"},{"location":"cpp/0301-0400/0341-0350/#345-reverse-vowels-of-a-string-star","text":"","title":"345. Reverse Vowels of a String $\\star$"},{"location":"cpp/0301-0400/0341-0350/#346-moving-average-from-data-stream-star","text":"","title":"346. Moving Average from Data Stream $\\star$"},{"location":"cpp/0301-0400/0341-0350/#347-top-k-frequent-elements-starstar","text":"","title":"347. Top K Frequent Elements $\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/#348-design-tic-tac-toe-starstar","text":"","title":"348. Design Tic-Tac-Toe $\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/#349-intersection-of-two-arrays-star","text":"","title":"349. Intersection of Two Arrays $\\star$"},{"location":"cpp/0301-0400/0341-0350/#350-intersection-of-two-arrays-ii-star","text":"","title":"350. Intersection of Two Arrays II $\\star$"},{"location":"cpp/0301-0400/0351-0360/","text":"351. Android Unlock Patterns $\\star\\star$ 352. Data Stream as Disjoint Intervals $\\star\\star\\star$ 353. Design Snake Game $\\star\\star$ 354. Russian Doll Envelopes $\\star\\star\\star$ 355. Design Twitter $\\star\\star$ 356. Line Reflection $\\star\\star$ 357. Count Numbers with Unique Digits $\\star\\star$ 358. Rearrange String k Distance Apart $\\star\\star\\star$ 359. Logger Rate Limiter $\\star$ 360. Sort Transformed Array $\\star\\star$","title":"0351-0360"},{"location":"cpp/0301-0400/0351-0360/#351-android-unlock-patterns-starstar","text":"","title":"351. Android Unlock Patterns $\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#352-data-stream-as-disjoint-intervals-starstarstar","text":"","title":"352. Data Stream as Disjoint Intervals $\\star\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#353-design-snake-game-starstar","text":"","title":"353. Design Snake Game $\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#354-russian-doll-envelopes-starstarstar","text":"","title":"354. Russian Doll Envelopes $\\star\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#355-design-twitter-starstar","text":"","title":"355. Design Twitter $\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#356-line-reflection-starstar","text":"","title":"356. Line Reflection $\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#357-count-numbers-with-unique-digits-starstar","text":"","title":"357. Count Numbers with Unique Digits $\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#358-rearrange-string-k-distance-apart-starstarstar","text":"","title":"358. Rearrange String k Distance Apart $\\star\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#359-logger-rate-limiter-star","text":"","title":"359. Logger Rate Limiter $\\star$"},{"location":"cpp/0301-0400/0351-0360/#360-sort-transformed-array-starstar","text":"","title":"360. Sort Transformed Array $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/","text":"361. Bomb Enemy $\\star\\star$ 362. Design Hit Counter $\\star\\star$ 363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$ 364. Nested List Weight Sum II $\\star\\star$ 365. Water and Jug Problem $\\star\\star$ 366. Find Leaves of Binary Tree $\\star\\star$ 367. Valid Perfect Square $\\star$ 368. Largest Divisible Subset $\\star\\star$ 369. Plus One Linked List $\\star\\star$ 370. Range Addition $\\star\\star$","title":"0361-0370"},{"location":"cpp/0301-0400/0361-0370/#361-bomb-enemy-starstar","text":"","title":"361. Bomb Enemy $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#362-design-hit-counter-starstar","text":"","title":"362. Design Hit Counter $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#363-max-sum-of-rectangle-no-larger-than-k-starstarstar","text":"","title":"363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#364-nested-list-weight-sum-ii-starstar","text":"","title":"364. Nested List Weight Sum II $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#365-water-and-jug-problem-starstar","text":"","title":"365. Water and Jug Problem $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#366-find-leaves-of-binary-tree-starstar","text":"","title":"366. Find Leaves of Binary Tree $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#367-valid-perfect-square-star","text":"","title":"367. Valid Perfect Square $\\star$"},{"location":"cpp/0301-0400/0361-0370/#368-largest-divisible-subset-starstar","text":"","title":"368. Largest Divisible Subset $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#369-plus-one-linked-list-starstar","text":"","title":"369. Plus One Linked List $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#370-range-addition-starstar","text":"","title":"370. Range Addition $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/","text":"371. Sum of Two Integers $\\star$ 372. Super Pow $\\star\\star$ 373. Find K Pairs with Smallest Sums $\\star\\star$ 374. Guess Number Higher or Lower $\\star$ 375. Guess Number Higher or Lower II $\\star\\star$ 376. Wiggle Subsequence $\\star\\star$ 377. Combination Sum IV $\\star\\star$ \u6807\u51c6DP\uff0c\u4f46\u662f\u6d4b\u8bd5case\u4e0d\u591f\uff0c\u662f\u6070\u597d\u901a\u8fc7[3, 33, 333] 100\u5f97\u8f93\u5165\u7684 \u7279\u6b8a\u7684\u8f93\u5165\u4f1a\u5bfc\u81f4\u4e2d\u95f4\u7ed3\u679c\u592a\u5927\uff0c\u6ea2\u51fa\u6807\u51c6\u7c7b\u578b\u53ef\u5b58\u50a8\u7684\u503c \u8be6\u7ec6\u53c2\u8003\u4ee3\u7801\u548c\u6211\u5728leetcode\u4e0a\u7684 diss 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class Solution { public : int combinationSum4 ( vector < int > & nums , int target ) { // return func1(nums, target); // return func2(nums, target); return func3 ( nums , target ); } // ** iterative int func1 ( vector < int > & nums , int target ) { return helper1 ( nums , 0 , target ); } int helper1 ( vector < int > & nums , int sum , int target ) { if ( sum > target ) { return 0 ; } if ( sum == target ) { return 1 ; } int res = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { res += helper1 ( nums , sum + nums [ i ], target ); } return res ; } // ** 1D array dp int func2 ( vector < int > & nums , int target ) { // vector<int> dp(target+1, 0); // vector<unsigned int> dp(target+1, 0); // vector<unsigned long> dp(target+1, 0); // vector<double> dp(target+1, 0); vector < long double > dp ( target + 1 , 0 ); for ( auto n : nums ) { if ( n <= target ) { dp [ n ] = 1 ; } } for ( int i = 1 ; i <= target ; i ++ ) { for ( auto n : nums ) { if ( i - n > 0 ) { dp [ i ] += dp [ i - n ]; } } } cout << \"size of int = \" << sizeof ( int ) << endl ; cout << \"size of unsigned int = \" << sizeof ( unsigned int ) << endl ; cout << \"size of long = \" << sizeof ( long ) << endl ; cout << \"size of long long =\" << sizeof ( long long ) << endl ; cout << \"size of double =\" << sizeof ( double ) << endl ; cout << \"size of long double =\" << sizeof ( long double ) << endl << endl ; int cnt0 = 0 ; int cnt1 = 0 ; int cnt2 = 0 ; int cnt3 = 0 ; for ( int i = 0 ; i <= target ; i ++ ) { // ** signed 4 Bytes integer max if ( dp [ i ] > 2147483647 ) { cnt0 ++ ; } // ** unsigned 4 Bytes integer max if ( dp [ i ] > 4294967295 ) { cnt1 ++ ; } // ** signed 8 Bytes integer max if ( dp [ i ] > 9223372036854775807 ) { cnt2 ++ ; } // ** unsigned 8 Bytes integer max if ( dp [ i ] > 18446744073709551615 ) { cnt3 ++ ; } } cout << \"numbers >2147483647 count = \" << cnt0 << endl ; cout << \"numbers >4294967295 count = \" << cnt1 << endl ; cout << \"numbers >9223372036854775807 count = \" << cnt2 << endl ; cout << \"numbers >18446744073709551615 count = \" << cnt3 << endl << endl ; unsigned int x = 4294967295 ; cout << \"x = \" << x << endl ; x += 1 ; cout << \"x = \" << x << endl ; return dp [ target ]; } // ** minus always better to plus in func1() // ** NO... also TLE at [1,2,3] 32 int func3 ( vector < int > & nums , int target ) { if ( target == 0 ) { return 1 ; } int res = 0 ; for ( auto n : nums ) { if ( target >= n ) { res += func3 ( nums , target - n ); } } return res ; } }; 378. Kth Smallest Element in a Sorted Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { int l = matrix [ 0 ][ 0 ]; int r = matrix . back (). back (); while ( l < r ) { int m = ( l + r ) >> 1 ; int count = 0 ; for ( auto & row : matrix ) count += upper_bound ( row . begin (), row . end (), m ) - row . begin (); if ( count >= k ) r = m ; else l = m + 1 ; } return l ; } }; 379. Design Phone Directory $\\star\\star$ 380. Insert Delete GetRandom O(1) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class RandomizedSet { public : bool insert ( int val ) { if ( map . count ( val )) return false ; map [ val ] = vals . size (); vals . push_back ( val ); return true ; } bool remove ( int val ) { if ( ! map . count ( val )) return false ; int index = map [ val ]; map [ vals . back ()] = index ; map . erase ( val ); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]; } private : vector < int > vals ; unordered_map < int , int > map ; };","title":"0371-0380"},{"location":"cpp/0301-0400/0371-0380/#371-sum-of-two-integers-star","text":"","title":"371. Sum of Two Integers $\\star$"},{"location":"cpp/0301-0400/0371-0380/#372-super-pow-starstar","text":"","title":"372. Super Pow $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#373-find-k-pairs-with-smallest-sums-starstar","text":"","title":"373. Find K Pairs with Smallest Sums $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#374-guess-number-higher-or-lower-star","text":"","title":"374. Guess Number Higher or Lower $\\star$"},{"location":"cpp/0301-0400/0371-0380/#375-guess-number-higher-or-lower-ii-starstar","text":"","title":"375. Guess Number Higher or Lower II $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#376-wiggle-subsequence-starstar","text":"","title":"376. Wiggle Subsequence $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#377-combination-sum-iv-starstar","text":"\u6807\u51c6DP\uff0c\u4f46\u662f\u6d4b\u8bd5case\u4e0d\u591f\uff0c\u662f\u6070\u597d\u901a\u8fc7[3, 33, 333] 100\u5f97\u8f93\u5165\u7684 \u7279\u6b8a\u7684\u8f93\u5165\u4f1a\u5bfc\u81f4\u4e2d\u95f4\u7ed3\u679c\u592a\u5927\uff0c\u6ea2\u51fa\u6807\u51c6\u7c7b\u578b\u53ef\u5b58\u50a8\u7684\u503c \u8be6\u7ec6\u53c2\u8003\u4ee3\u7801\u548c\u6211\u5728leetcode\u4e0a\u7684 diss 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class Solution { public : int combinationSum4 ( vector < int > & nums , int target ) { // return func1(nums, target); // return func2(nums, target); return func3 ( nums , target ); } // ** iterative int func1 ( vector < int > & nums , int target ) { return helper1 ( nums , 0 , target ); } int helper1 ( vector < int > & nums , int sum , int target ) { if ( sum > target ) { return 0 ; } if ( sum == target ) { return 1 ; } int res = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { res += helper1 ( nums , sum + nums [ i ], target ); } return res ; } // ** 1D array dp int func2 ( vector < int > & nums , int target ) { // vector<int> dp(target+1, 0); // vector<unsigned int> dp(target+1, 0); // vector<unsigned long> dp(target+1, 0); // vector<double> dp(target+1, 0); vector < long double > dp ( target + 1 , 0 ); for ( auto n : nums ) { if ( n <= target ) { dp [ n ] = 1 ; } } for ( int i = 1 ; i <= target ; i ++ ) { for ( auto n : nums ) { if ( i - n > 0 ) { dp [ i ] += dp [ i - n ]; } } } cout << \"size of int = \" << sizeof ( int ) << endl ; cout << \"size of unsigned int = \" << sizeof ( unsigned int ) << endl ; cout << \"size of long = \" << sizeof ( long ) << endl ; cout << \"size of long long =\" << sizeof ( long long ) << endl ; cout << \"size of double =\" << sizeof ( double ) << endl ; cout << \"size of long double =\" << sizeof ( long double ) << endl << endl ; int cnt0 = 0 ; int cnt1 = 0 ; int cnt2 = 0 ; int cnt3 = 0 ; for ( int i = 0 ; i <= target ; i ++ ) { // ** signed 4 Bytes integer max if ( dp [ i ] > 2147483647 ) { cnt0 ++ ; } // ** unsigned 4 Bytes integer max if ( dp [ i ] > 4294967295 ) { cnt1 ++ ; } // ** signed 8 Bytes integer max if ( dp [ i ] > 9223372036854775807 ) { cnt2 ++ ; } // ** unsigned 8 Bytes integer max if ( dp [ i ] > 18446744073709551615 ) { cnt3 ++ ; } } cout << \"numbers >2147483647 count = \" << cnt0 << endl ; cout << \"numbers >4294967295 count = \" << cnt1 << endl ; cout << \"numbers >9223372036854775807 count = \" << cnt2 << endl ; cout << \"numbers >18446744073709551615 count = \" << cnt3 << endl << endl ; unsigned int x = 4294967295 ; cout << \"x = \" << x << endl ; x += 1 ; cout << \"x = \" << x << endl ; return dp [ target ]; } // ** minus always better to plus in func1() // ** NO... also TLE at [1,2,3] 32 int func3 ( vector < int > & nums , int target ) { if ( target == 0 ) { return 1 ; } int res = 0 ; for ( auto n : nums ) { if ( target >= n ) { res += func3 ( nums , target - n ); } } return res ; } };","title":"377. Combination Sum IV $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#378-kth-smallest-element-in-a-sorted-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { int l = matrix [ 0 ][ 0 ]; int r = matrix . back (). back (); while ( l < r ) { int m = ( l + r ) >> 1 ; int count = 0 ; for ( auto & row : matrix ) count += upper_bound ( row . begin (), row . end (), m ) - row . begin (); if ( count >= k ) r = m ; else l = m + 1 ; } return l ; } };","title":"378. Kth Smallest Element in a Sorted Matrix $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#379-design-phone-directory-starstar","text":"","title":"379. Design Phone Directory $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#380-insert-delete-getrandom-o1-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class RandomizedSet { public : bool insert ( int val ) { if ( map . count ( val )) return false ; map [ val ] = vals . size (); vals . push_back ( val ); return true ; } bool remove ( int val ) { if ( ! map . count ( val )) return false ; int index = map [ val ]; map [ vals . back ()] = index ; map . erase ( val ); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]; } private : vector < int > vals ; unordered_map < int , int > map ; };","title":"380. Insert Delete GetRandom O(1) $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/","text":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class RandomizedCollection { public : bool insert ( int val ) { map [ val ]. push_back ( vals . size ()); vals . emplace_back ( val , map [ val ]. size () - 1 ); return map [ val ]. size () == 1 ; } bool remove ( int val ) { if ( ! map . count ( val ) || map [ val ]. empty ()) return false ; int index = map [ val ]. back (); map [ vals . back (). first ][ vals . back (). second ] = index ; map [ val ]. pop_back (); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]. first ; } private : vector < pair < int , int >> vals ; unordered_map < int , vector < int >> map ; }; 382. Linked List Random Node $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Solution ( ListNode * head ) { privateHead = head ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; } int getRandom () { int n = rand () % length ; ListNode * curr = privateHead ; while ( n -- > 0 ) curr = curr -> next ; return curr -> val ; } private : ListNode * privateHead ; int length = 0 ; }; 383. Ransom Note $\\star$ 384. Shuffle an Array $\\star\\star$ 385. Mini Parser $\\star\\star$ 386. Lexicographical Numbers $\\star\\star$ 387. First Unique Character in a String $\\star$ 388. Longest Absolute File Path $\\star\\star$ 389. Find the Difference $\\star$ 390. Elimination Game $\\star\\star$","title":"0381-0390"},{"location":"cpp/0301-0400/0381-0390/#381-insert-delete-getrandom-o1-duplicates-allowed-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class RandomizedCollection { public : bool insert ( int val ) { map [ val ]. push_back ( vals . size ()); vals . emplace_back ( val , map [ val ]. size () - 1 ); return map [ val ]. size () == 1 ; } bool remove ( int val ) { if ( ! map . count ( val ) || map [ val ]. empty ()) return false ; int index = map [ val ]. back (); map [ vals . back (). first ][ vals . back (). second ] = index ; map [ val ]. pop_back (); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]. first ; } private : vector < pair < int , int >> vals ; unordered_map < int , vector < int >> map ; };","title":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#382-linked-list-random-node-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Solution ( ListNode * head ) { privateHead = head ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; } int getRandom () { int n = rand () % length ; ListNode * curr = privateHead ; while ( n -- > 0 ) curr = curr -> next ; return curr -> val ; } private : ListNode * privateHead ; int length = 0 ; };","title":"382. Linked List Random Node $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#383-ransom-note-star","text":"","title":"383. Ransom Note $\\star$"},{"location":"cpp/0301-0400/0381-0390/#384-shuffle-an-array-starstar","text":"","title":"384. Shuffle an Array $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#385-mini-parser-starstar","text":"","title":"385. Mini Parser $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#386-lexicographical-numbers-starstar","text":"","title":"386. Lexicographical Numbers $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#387-first-unique-character-in-a-string-star","text":"","title":"387. First Unique Character in a String $\\star$"},{"location":"cpp/0301-0400/0381-0390/#388-longest-absolute-file-path-starstar","text":"","title":"388. Longest Absolute File Path $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#389-find-the-difference-star","text":"","title":"389. Find the Difference $\\star$"},{"location":"cpp/0301-0400/0381-0390/#390-elimination-game-starstar","text":"","title":"390. Elimination Game $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/","text":"391. Perfect Rectangle $\\star\\star\\star$ 392. Is Subsequence $\\star$ 393. UTF-8 Validation $\\star\\star$ 394. Decode String $\\star\\star$ 395. Longest Substring with At Least K Repeating Characters $\\star\\star$ 396. Rotate Function $\\star\\star$ 397. Integer Replacement $\\star\\star$ 398. Random Pick Index $\\star\\star$ 399. Evaluate Division $\\star\\star$ 400. Nth Digit $\\star\\star$","title":"0391-0300"},{"location":"cpp/0301-0400/0391-0400/#391-perfect-rectangle-starstarstar","text":"","title":"391. Perfect Rectangle $\\star\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#392-is-subsequence-star","text":"","title":"392. Is Subsequence $\\star$"},{"location":"cpp/0301-0400/0391-0400/#393-utf-8-validation-starstar","text":"","title":"393. UTF-8 Validation $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#394-decode-string-starstar","text":"","title":"394. Decode String $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#395-longest-substring-with-at-least-k-repeating-characters-starstar","text":"","title":"395. Longest Substring with At Least K Repeating Characters $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#396-rotate-function-starstar","text":"","title":"396. Rotate Function $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#397-integer-replacement-starstar","text":"","title":"397. Integer Replacement $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#398-random-pick-index-starstar","text":"","title":"398. Random Pick Index $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#399-evaluate-division-starstar","text":"","title":"399. Evaluate Division $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#400-nth-digit-starstar","text":"","title":"400. Nth Digit $\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/","text":"401. Binary Watch $\\star$ 402. Remove K Digits $\\star\\star$ 403. Frog Jump $\\star\\star\\star$ 404. Sum of Left Leaves $\\star$ 405. Convert a Number to Hexadecimal $\\star$ 406. Queue Reconstruction by Height $\\star\\star$ 407. Trapping Rain Water II $\\star\\star\\star$ 408. Valid Word Abbreviation $\\star$ 409. Longest Palindrome $\\star$ 410. Split Array Largest Sum $\\star\\star\\star$","title":"0401-0410"},{"location":"cpp/0401-0500/0401-0410/#401-binary-watch-star","text":"","title":"401. Binary Watch $\\star$"},{"location":"cpp/0401-0500/0401-0410/#402-remove-k-digits-starstar","text":"","title":"402. Remove K Digits $\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/#403-frog-jump-starstarstar","text":"","title":"403. Frog Jump $\\star\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/#404-sum-of-left-leaves-star","text":"","title":"404. Sum of Left Leaves $\\star$"},{"location":"cpp/0401-0500/0401-0410/#405-convert-a-number-to-hexadecimal-star","text":"","title":"405. Convert a Number to Hexadecimal $\\star$"},{"location":"cpp/0401-0500/0401-0410/#406-queue-reconstruction-by-height-starstar","text":"","title":"406. Queue Reconstruction by Height $\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/#407-trapping-rain-water-ii-starstarstar","text":"","title":"407. Trapping Rain Water II $\\star\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/#408-valid-word-abbreviation-star","text":"","title":"408. Valid Word Abbreviation $\\star$"},{"location":"cpp/0401-0500/0401-0410/#409-longest-palindrome-star","text":"","title":"409. Longest Palindrome $\\star$"},{"location":"cpp/0401-0500/0401-0410/#410-split-array-largest-sum-starstarstar","text":"","title":"410. Split Array Largest Sum $\\star\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/","text":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$ 412. Fizz Buzz $\\star$ 413. Arithmetic Slices $\\star\\star$ 414. Third Maximum Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int thirdMax ( vector < int >& nums ) { priority_queue < int , vector < int > , compare > pq ; unordered_set < int > set ; for ( int num : nums ) if ( ! set . count ( num )) { set . insert ( num ); pq . push ( num ); if ( pq . size () > 3 ) pq . pop (); } if ( pq . size () == 2 ) pq . pop (); return pq . top (); } private : struct compare { bool operator ()( const int a , const int b ) { return a > b ; } }; }; 415. Add Strings $\\star$ 416. Partition Equal Subset Sum $\\star\\star$ 417. Pacific Atlantic Water Flow $\\star\\star$ 418. Sentence Screen Fitting $\\star\\star$ 419. Battleships in a Board $\\star\\star$ 420. Strong Password Checker $\\star\\star\\star$","title":"0411-0420"},{"location":"cpp/0401-0500/0411-0420/#411-minimum-unique-word-abbreviation-starstarstar","text":"","title":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#412-fizz-buzz-star","text":"","title":"412. Fizz Buzz $\\star$"},{"location":"cpp/0401-0500/0411-0420/#413-arithmetic-slices-starstar","text":"","title":"413. Arithmetic Slices $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#414-third-maximum-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int thirdMax ( vector < int >& nums ) { priority_queue < int , vector < int > , compare > pq ; unordered_set < int > set ; for ( int num : nums ) if ( ! set . count ( num )) { set . insert ( num ); pq . push ( num ); if ( pq . size () > 3 ) pq . pop (); } if ( pq . size () == 2 ) pq . pop (); return pq . top (); } private : struct compare { bool operator ()( const int a , const int b ) { return a > b ; } }; };","title":"414. Third Maximum Number $\\star$"},{"location":"cpp/0401-0500/0411-0420/#415-add-strings-star","text":"","title":"415. Add Strings $\\star$"},{"location":"cpp/0401-0500/0411-0420/#416-partition-equal-subset-sum-starstar","text":"","title":"416. Partition Equal Subset Sum $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#417-pacific-atlantic-water-flow-starstar","text":"","title":"417. Pacific Atlantic Water Flow $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#418-sentence-screen-fitting-starstar","text":"","title":"418. Sentence Screen Fitting $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#419-battleships-in-a-board-starstar","text":"","title":"419. Battleships in a Board $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#420-strong-password-checker-starstarstar","text":"","title":"420. Strong Password Checker $\\star\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/","text":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$ 422. Valid Word Square $\\star$ 423. Reconstruct Original Digits from English $\\star\\star$ 424. Longest Repeating Character Replacement $\\star\\star$ 425. Word Squares $\\star\\star\\star$ 426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$ 427. Construct Quad Tree $\\star\\star$ 428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$ 429. N-ary Tree Level Order Traversal $\\star\\star$ 430. Flatten a Multilevel Doubly Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * flatten ( Node * head ) { for ( Node * curr = head ; curr ; curr = curr -> next ) if ( curr -> child ) { Node * next = curr -> next ; curr -> next = curr -> child ; curr -> next -> prev = curr ; curr -> child = NULL ; Node * tail = curr -> next ; while ( tail -> next ) tail = tail -> next ; tail -> next = next ; if ( next ) next -> prev = tail ; } return head ; } };","title":"0421-0430"},{"location":"cpp/0401-0500/0421-0430/#421-maximum-xor-of-two-numbers-in-an-array-starstar","text":"","title":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#422-valid-word-square-star","text":"","title":"422. Valid Word Square $\\star$"},{"location":"cpp/0401-0500/0421-0430/#423-reconstruct-original-digits-from-english-starstar","text":"","title":"423. Reconstruct Original Digits from English $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#424-longest-repeating-character-replacement-starstar","text":"","title":"424. Longest Repeating Character Replacement $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#425-word-squares-starstarstar","text":"","title":"425. Word Squares $\\star\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#426-convert-binary-search-tree-to-sorted-doubly-linked-list-starstar","text":"","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#427-construct-quad-tree-starstar","text":"","title":"427. Construct Quad Tree $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#428-serialize-and-deserialize-n-ary-tree-starstarstar","text":"","title":"428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#429-n-ary-tree-level-order-traversal-starstar","text":"","title":"429. N-ary Tree Level Order Traversal $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#430-flatten-a-multilevel-doubly-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * flatten ( Node * head ) { for ( Node * curr = head ; curr ; curr = curr -> next ) if ( curr -> child ) { Node * next = curr -> next ; curr -> next = curr -> child ; curr -> next -> prev = curr ; curr -> child = NULL ; Node * tail = curr -> next ; while ( tail -> next ) tail = tail -> next ; tail -> next = next ; if ( next ) next -> prev = tail ; } return head ; } };","title":"430. Flatten a Multilevel Doubly Linked List $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/","text":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$ 432. All O`one Data Structure $\\star\\star\\star$ 433. Minimum Genetic Mutation $\\star\\star$ 434. Number of Segments in a String $\\star$ 435. Non-overlapping Intervals $\\star\\star$ 436. Find Right Interval $\\star\\star$ 437. Path Sum III $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int pathSum ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return helper ( root , sum ) + pathSum ( root -> left , sum ) + pathSum ( root -> right , sum ); } private : int helper ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return ( sum == root -> val ) + helper ( root -> left , sum - root -> val ) + helper ( root -> right , sum - root -> val ); } }; 438. Find All Anagrams in a String $\\star\\star$ 439. Ternary Expression Parser $\\star\\star$ 440. K-th Smallest in Lexicographical Order $\\star\\star\\star$","title":"0431-0440"},{"location":"cpp/0401-0500/0431-0440/#431-encode-n-ary-tree-to-binary-tree-starstarstar","text":"","title":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#432-all-oone-data-structure-starstarstar","text":"","title":"432. All O`one Data Structure $\\star\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#433-minimum-genetic-mutation-starstar","text":"","title":"433. Minimum Genetic Mutation $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#434-number-of-segments-in-a-string-star","text":"","title":"434. Number of Segments in a String $\\star$"},{"location":"cpp/0401-0500/0431-0440/#435-non-overlapping-intervals-starstar","text":"","title":"435. Non-overlapping Intervals $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#436-find-right-interval-starstar","text":"","title":"436. Find Right Interval $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#437-path-sum-iii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int pathSum ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return helper ( root , sum ) + pathSum ( root -> left , sum ) + pathSum ( root -> right , sum ); } private : int helper ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return ( sum == root -> val ) + helper ( root -> left , sum - root -> val ) + helper ( root -> right , sum - root -> val ); } };","title":"437. Path Sum III $\\star$"},{"location":"cpp/0401-0500/0431-0440/#438-find-all-anagrams-in-a-string-starstar","text":"","title":"438. Find All Anagrams in a String $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#439-ternary-expression-parser-starstar","text":"","title":"439. Ternary Expression Parser $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#440-k-th-smallest-in-lexicographical-order-starstarstar","text":"","title":"440. K-th Smallest in Lexicographical Order $\\star\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/","text":"441. Arranging Coins $\\star$ 442. Find All Duplicates in an Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > findDuplicates ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { nums [ abs ( num ) - 1 ] *= - 1 ; if ( nums [ abs ( num ) - 1 ] > 0 ) ans . push_back ( abs ( num )); } return ans ; } }; 443. String Compression $\\star$ 444. Sequence Reconstruction $\\star\\star$ 445. Add Two Numbers II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { stack < ListNode *> stack1 ; stack < ListNode *> stack2 ; while ( l1 ) { stack1 . push ( l1 ); l1 = l1 -> next ; } while ( l2 ) { stack2 . push ( l2 ); l2 = l2 -> next ; } ListNode * head = NULL ; int carry = 0 ; while ( carry || ! stack1 . empty () || ! stack2 . empty ()) { if ( ! stack1 . empty ()) { carry += stack1 . top () -> val ; stack1 . pop (); } if ( ! stack2 . empty ()) { carry += stack2 . top () -> val ; stack2 . pop (); } ListNode * node = new ListNode ( carry % 10 ); node -> next = head ; head = node ; carry /= 10 ; } return head ; } }; 446. Arithmetic Slices II - Subsequence $\\star\\star\\star$ 447. Number of Boomerangs $\\star$ 448. Find All Numbers Disappeared in an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > findDisappearedNumbers ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { int index = abs ( num ) - 1 ; nums [ index ] = - abs ( nums [ index ]); } for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > 0 ) ans . push_back ( i + 1 ); return ans ; } }; 449. Serialize and Deserialize BST $\\star\\star$ 450. Delete Node in a BST $\\star\\star$","title":"0441-0450"},{"location":"cpp/0401-0500/0441-0450/#441-arranging-coins-star","text":"","title":"441. Arranging Coins $\\star$"},{"location":"cpp/0401-0500/0441-0450/#442-find-all-duplicates-in-an-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > findDuplicates ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { nums [ abs ( num ) - 1 ] *= - 1 ; if ( nums [ abs ( num ) - 1 ] > 0 ) ans . push_back ( abs ( num )); } return ans ; } };","title":"442. Find All Duplicates in an Array $\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#443-string-compression-star","text":"","title":"443. String Compression $\\star$"},{"location":"cpp/0401-0500/0441-0450/#444-sequence-reconstruction-starstar","text":"","title":"444. Sequence Reconstruction $\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#445-add-two-numbers-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { stack < ListNode *> stack1 ; stack < ListNode *> stack2 ; while ( l1 ) { stack1 . push ( l1 ); l1 = l1 -> next ; } while ( l2 ) { stack2 . push ( l2 ); l2 = l2 -> next ; } ListNode * head = NULL ; int carry = 0 ; while ( carry || ! stack1 . empty () || ! stack2 . empty ()) { if ( ! stack1 . empty ()) { carry += stack1 . top () -> val ; stack1 . pop (); } if ( ! stack2 . empty ()) { carry += stack2 . top () -> val ; stack2 . pop (); } ListNode * node = new ListNode ( carry % 10 ); node -> next = head ; head = node ; carry /= 10 ; } return head ; } };","title":"445. Add Two Numbers II $\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#446-arithmetic-slices-ii-subsequence-starstarstar","text":"","title":"446. Arithmetic Slices II - Subsequence $\\star\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#447-number-of-boomerangs-star","text":"","title":"447. Number of Boomerangs $\\star$"},{"location":"cpp/0401-0500/0441-0450/#448-find-all-numbers-disappeared-in-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > findDisappearedNumbers ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { int index = abs ( num ) - 1 ; nums [ index ] = - abs ( nums [ index ]); } for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > 0 ) ans . push_back ( i + 1 ); return ans ; } };","title":"448. Find All Numbers Disappeared in an Array $\\star$"},{"location":"cpp/0401-0500/0441-0450/#449-serialize-and-deserialize-bst-starstar","text":"","title":"449. Serialize and Deserialize BST $\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#450-delete-node-in-a-bst-starstar","text":"","title":"450. Delete Node in a BST $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/","text":"451. Sort Characters By Frequency $\\star\\star$ 452. Minimum Number of Arrows to Burst Balloons $\\star\\star$ 453. Minimum Moves to Equal Array Elements $\\star$ 454. 4Sum II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fourSumCount ( vector < int >& A , vector < int >& B , vector < int >& C , vector < int >& D ) { int ans = 0 ; unordered_map < int , int > map ; for ( int a : A ) for ( int b : B ) ++ map [ a + b ]; for ( int c : C ) for ( int d : D ) ans += map . count ( - c - d ) ? map [ - c - d ] : 0 ; return ans ; } }; 455. Assign Cookies $\\star$ 456. 132 Pattern $\\star\\star$ 457. Circular Array Loop $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { if ( nums . size () < 2 ) return false ; function < int ( int ) > advance = [ & ]( int i ) { const int n = nums . size (); int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } }; 458. Poor Pigs $\\star\\star\\star$ 459. Repeated Substring Pattern $\\star$ 460. LFU Cache $\\star\\star\\star$","title":"0451-0460"},{"location":"cpp/0401-0500/0451-0460/#451-sort-characters-by-frequency-starstar","text":"","title":"451. Sort Characters By Frequency $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#452-minimum-number-of-arrows-to-burst-balloons-starstar","text":"","title":"452. Minimum Number of Arrows to Burst Balloons $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#453-minimum-moves-to-equal-array-elements-star","text":"","title":"453. Minimum Moves to Equal Array Elements $\\star$"},{"location":"cpp/0401-0500/0451-0460/#454-4sum-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fourSumCount ( vector < int >& A , vector < int >& B , vector < int >& C , vector < int >& D ) { int ans = 0 ; unordered_map < int , int > map ; for ( int a : A ) for ( int b : B ) ++ map [ a + b ]; for ( int c : C ) for ( int d : D ) ans += map . count ( - c - d ) ? map [ - c - d ] : 0 ; return ans ; } };","title":"454. 4Sum II $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#455-assign-cookies-star","text":"","title":"455. Assign Cookies $\\star$"},{"location":"cpp/0401-0500/0451-0460/#456-132-pattern-starstar","text":"","title":"456. 132 Pattern $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#457-circular-array-loop-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { if ( nums . size () < 2 ) return false ; function < int ( int ) > advance = [ & ]( int i ) { const int n = nums . size (); int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } };","title":"457. Circular Array Loop $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#458-poor-pigs-starstarstar","text":"","title":"458. Poor Pigs $\\star\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#459-repeated-substring-pattern-star","text":"","title":"459. Repeated Substring Pattern $\\star$"},{"location":"cpp/0401-0500/0451-0460/#460-lfu-cache-starstarstar","text":"","title":"460. LFU Cache $\\star\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/","text":"461. Hamming Distance $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int hammingDistance ( int x , int y ) { int ans = 0 ; while ( x || y ) { ans += ( x % 2 ) ^ ( y % 2 ); x /= 2 ; y /= 2 ; } return ans ; } }; 462. Minimum Moves to Equal Array Elements II $\\star\\star$ 463. Island Perimeter $\\star$ 464. Can I Win $\\star\\star$ 465. Optimal Account Balancing $\\star\\star\\star$ 466. Count The Repetitions $\\star\\star\\star$ 467. Unique Substrings in Wraparound String $\\star\\star$ 468. Validate IP Address $\\star\\star$ 469. Convex Polygon $\\star\\star$ 470. Implement Rand10() Using Rand7() $\\star\\star$","title":"0461-0470"},{"location":"cpp/0401-0500/0461-0470/#461-hamming-distance-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int hammingDistance ( int x , int y ) { int ans = 0 ; while ( x || y ) { ans += ( x % 2 ) ^ ( y % 2 ); x /= 2 ; y /= 2 ; } return ans ; } };","title":"461. Hamming Distance $\\star$"},{"location":"cpp/0401-0500/0461-0470/#462-minimum-moves-to-equal-array-elements-ii-starstar","text":"","title":"462. Minimum Moves to Equal Array Elements II $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#463-island-perimeter-star","text":"","title":"463. Island Perimeter $\\star$"},{"location":"cpp/0401-0500/0461-0470/#464-can-i-win-starstar","text":"","title":"464. Can I Win $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#465-optimal-account-balancing-starstarstar","text":"","title":"465. Optimal Account Balancing $\\star\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#466-count-the-repetitions-starstarstar","text":"","title":"466. Count The Repetitions $\\star\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#467-unique-substrings-in-wraparound-string-starstar","text":"","title":"467. Unique Substrings in Wraparound String $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#468-validate-ip-address-starstar","text":"","title":"468. Validate IP Address $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#469-convex-polygon-starstar","text":"","title":"469. Convex Polygon $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#470-implement-rand10-using-rand7-starstar","text":"","title":"470. Implement Rand10() Using Rand7() $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/","text":"471. Encode String with Shortest Length $\\star\\star\\star$ 472. Concatenated Words $\\star\\star\\star$ 473. Matchsticks to Square $\\star\\star$ 474. Ones and Zeroes $\\star\\star$ \u6807\u51c6\u7684\u4e8c\u7ef4DP\u95ee\u9898\uff0c\u6ce8\u610f\u5728func3()\u4e2d\u4f7f\u7528\u4e86\u975e\u5e38\u5e38\u89c1\u7684\uff0c \u6539\u4ece\u5c0f\u5230\u5927\u8fed\u4ee3\u4e3a\u4ece\u5927\u5230\u5c0f\u4ee5\u8282\u7701dp\u6570\u7ec4\u7684\u6280\u5de7 \uff0c\u6682\u65f6\u60f3\u4e0d\u8d77\u6765\u662f\u5728\u54ea\u5b66\u5230\u7684\u8fd9\u4e2a\u6280\u5de7 \u60f3\u8d77\u6765\u4e86\uff0c\u5728 \u80cc\u5305\u4e5d\u8bb2 \u7684\u7b2c\u4e00\u8bb2\u7684 \u4f18\u5316\u7a7a\u95f4\u590d\u6742\u5ea6 \u4e2d\u5b66\u4e60\u5f97\u5230\u7684\uff0c\u8fd9\u4e2a\u9898\u5e94\u8be5\u5212\u5206\u4e3a \u7b2c4\u79cd\u80cc\u5305\u95ee\u9898\uff0c\u5373\u4e8c\u7ef4\u8d39\u7528\u80cc\u5305\u95ee\u9898 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 class Solution { public : int findMaxForm ( vector < string > & strs , int m , int n ) { // return func1(strs, m, n); // return func2(strs, m, n); return func3 ( strs , m , n ); } // ** recursive // ** time 0(len * 2^N), len = max length of strs, N = strs.size() int func1 ( vector < string > & strs , int m , int n ) { return helper1 ( strs , 0 , m , n ); } int helper1 ( vector < string > & strs , int idx , int m , int n ) { if ( idx >= strs . size ()) { return 0 ; } int cnt0 = 0 ; int cnt1 = 0 ; for ( int i = 0 ; i < strs [ idx ]. length (); i ++ ) { if ( strs [ idx ][ i ] == '0' ) cnt0 ++ ; if ( strs [ idx ][ i ] == '1' ) cnt1 ++ ; } int notp = helper1 ( strs , idx + 1 , m , n ); int pick = notp ; if ( cnt0 <= m && cnt1 <= n ) { pick = 1 + helper1 ( strs , idx + 1 , m - cnt0 , n - cnt1 ); } return max ( notp , pick ); } // ** dp two 2D array int func2 ( vector < string > & strs , int m , int n ) { vector < vector < int >> dp1 ( m + 1 , vector < int > ( n + 1 , 0 )); vector < vector < int >> dp2 ( m + 1 , vector < int > ( n + 1 , 0 )); for ( int i = 0 ; i < strs . size (); i ++ ) { int cnt0 = 0 ; int cnt1 = 0 ; for ( int j = 0 ; j < strs [ i ]. length (); j ++ ) { if ( strs [ i ][ j ] == '0' ) cnt0 ++ ; if ( strs [ i ][ j ] == '1' ) cnt1 ++ ; } for ( int x = cnt0 ; x <= m ; x ++ ) { for ( int y = cnt1 ; y <= n ; y ++ ) { dp1 [ x ][ y ] = max ( dp2 [ x ][ y ], 1 + dp2 [ x - cnt0 ][ y - cnt1 ]); } } for ( int x = 0 ; x <= m ; x ++ ) { for ( int y = 0 ; y <= n ; y ++ ) { dp2 [ x ][ y ] = dp1 [ x ][ y ]; } } // for (int x = 0; x <= m; x++) { // for (int y = 0; y <= n; y++) { // cout << dp2[x][y] << \" \"; // } // cout << endl; // } // cout << \"-------\" << endl; } return dp1 [ m ][ n ]; } // ** dp one 2D array int func3 ( vector < string > & strs , int m , int n ) { vector < vector < int >> dp1 ( m + 1 , vector < int > ( n + 1 , 0 )); for ( int i = 0 ; i < strs . size (); i ++ ) { int cnt0 = 0 ; int cnt1 = 0 ; for ( int j = 0 ; j < strs [ i ]. length (); j ++ ) { if ( strs [ i ][ j ] == '0' ) cnt0 ++ ; if ( strs [ i ][ j ] == '1' ) cnt1 ++ ; } for ( int x = m ; x >= cnt0 ; x -- ) { for ( int y = n ; y >= cnt1 ; y -- ) { dp1 [ x ][ y ] = max ( dp1 [ x ][ y ], 1 + dp1 [ x - cnt0 ][ y - cnt1 ]); } } } return dp1 [ m ][ n ]; } }; 475. Heaters $\\star$ 476. Number Complement $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int findComplement ( int num ) { unsigned int mask = ~ 0 ; while ( num & mask ) mask <<= 1 ; return ~ num ^ mask ; } }; 477. Total Hamming Distance $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int totalHammingDistance ( vector < int >& nums ) { int ans = 0 ; int mask = 1 ; for ( int i = 0 ; i < 30 ; ++ i ) { int onesCount = 0 ; for ( int num : nums ) if ( num & mask ) ++ onesCount ; ans += ( nums . size () - onesCount ) * onesCount ; mask = mask << 1 ; } return ans ; } }; 478. Generate Random Point in a Circle $\\star\\star$ 479. Largest Palindrome Product $\\star\\star\\star$ 480. Sliding Window Median $\\star\\star\\star$","title":"0471-0480"},{"location":"cpp/0401-0500/0471-0480/#471-encode-string-with-shortest-length-starstarstar","text":"","title":"471. Encode String with Shortest Length $\\star\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#472-concatenated-words-starstarstar","text":"","title":"472. Concatenated Words $\\star\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#473-matchsticks-to-square-starstar","text":"","title":"473. Matchsticks to Square $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#474-ones-and-zeroes-starstar","text":"\u6807\u51c6\u7684\u4e8c\u7ef4DP\u95ee\u9898\uff0c\u6ce8\u610f\u5728func3()\u4e2d\u4f7f\u7528\u4e86\u975e\u5e38\u5e38\u89c1\u7684\uff0c \u6539\u4ece\u5c0f\u5230\u5927\u8fed\u4ee3\u4e3a\u4ece\u5927\u5230\u5c0f\u4ee5\u8282\u7701dp\u6570\u7ec4\u7684\u6280\u5de7 \uff0c\u6682\u65f6\u60f3\u4e0d\u8d77\u6765\u662f\u5728\u54ea\u5b66\u5230\u7684\u8fd9\u4e2a\u6280\u5de7 \u60f3\u8d77\u6765\u4e86\uff0c\u5728 \u80cc\u5305\u4e5d\u8bb2 \u7684\u7b2c\u4e00\u8bb2\u7684 \u4f18\u5316\u7a7a\u95f4\u590d\u6742\u5ea6 \u4e2d\u5b66\u4e60\u5f97\u5230\u7684\uff0c\u8fd9\u4e2a\u9898\u5e94\u8be5\u5212\u5206\u4e3a \u7b2c4\u79cd\u80cc\u5305\u95ee\u9898\uff0c\u5373\u4e8c\u7ef4\u8d39\u7528\u80cc\u5305\u95ee\u9898 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 class Solution { public : int findMaxForm ( vector < string > & strs , int m , int n ) { // return func1(strs, m, n); // return func2(strs, m, n); return func3 ( strs , m , n ); } // ** recursive // ** time 0(len * 2^N), len = max length of strs, N = strs.size() int func1 ( vector < string > & strs , int m , int n ) { return helper1 ( strs , 0 , m , n ); } int helper1 ( vector < string > & strs , int idx , int m , int n ) { if ( idx >= strs . size ()) { return 0 ; } int cnt0 = 0 ; int cnt1 = 0 ; for ( int i = 0 ; i < strs [ idx ]. length (); i ++ ) { if ( strs [ idx ][ i ] == '0' ) cnt0 ++ ; if ( strs [ idx ][ i ] == '1' ) cnt1 ++ ; } int notp = helper1 ( strs , idx + 1 , m , n ); int pick = notp ; if ( cnt0 <= m && cnt1 <= n ) { pick = 1 + helper1 ( strs , idx + 1 , m - cnt0 , n - cnt1 ); } return max ( notp , pick ); } // ** dp two 2D array int func2 ( vector < string > & strs , int m , int n ) { vector < vector < int >> dp1 ( m + 1 , vector < int > ( n + 1 , 0 )); vector < vector < int >> dp2 ( m + 1 , vector < int > ( n + 1 , 0 )); for ( int i = 0 ; i < strs . size (); i ++ ) { int cnt0 = 0 ; int cnt1 = 0 ; for ( int j = 0 ; j < strs [ i ]. length (); j ++ ) { if ( strs [ i ][ j ] == '0' ) cnt0 ++ ; if ( strs [ i ][ j ] == '1' ) cnt1 ++ ; } for ( int x = cnt0 ; x <= m ; x ++ ) { for ( int y = cnt1 ; y <= n ; y ++ ) { dp1 [ x ][ y ] = max ( dp2 [ x ][ y ], 1 + dp2 [ x - cnt0 ][ y - cnt1 ]); } } for ( int x = 0 ; x <= m ; x ++ ) { for ( int y = 0 ; y <= n ; y ++ ) { dp2 [ x ][ y ] = dp1 [ x ][ y ]; } } // for (int x = 0; x <= m; x++) { // for (int y = 0; y <= n; y++) { // cout << dp2[x][y] << \" \"; // } // cout << endl; // } // cout << \"-------\" << endl; } return dp1 [ m ][ n ]; } // ** dp one 2D array int func3 ( vector < string > & strs , int m , int n ) { vector < vector < int >> dp1 ( m + 1 , vector < int > ( n + 1 , 0 )); for ( int i = 0 ; i < strs . size (); i ++ ) { int cnt0 = 0 ; int cnt1 = 0 ; for ( int j = 0 ; j < strs [ i ]. length (); j ++ ) { if ( strs [ i ][ j ] == '0' ) cnt0 ++ ; if ( strs [ i ][ j ] == '1' ) cnt1 ++ ; } for ( int x = m ; x >= cnt0 ; x -- ) { for ( int y = n ; y >= cnt1 ; y -- ) { dp1 [ x ][ y ] = max ( dp1 [ x ][ y ], 1 + dp1 [ x - cnt0 ][ y - cnt1 ]); } } } return dp1 [ m ][ n ]; } };","title":"474. Ones and Zeroes $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#475-heaters-star","text":"","title":"475. Heaters $\\star$"},{"location":"cpp/0401-0500/0471-0480/#476-number-complement-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int findComplement ( int num ) { unsigned int mask = ~ 0 ; while ( num & mask ) mask <<= 1 ; return ~ num ^ mask ; } };","title":"476. Number Complement $\\star$"},{"location":"cpp/0401-0500/0471-0480/#477-total-hamming-distance-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int totalHammingDistance ( vector < int >& nums ) { int ans = 0 ; int mask = 1 ; for ( int i = 0 ; i < 30 ; ++ i ) { int onesCount = 0 ; for ( int num : nums ) if ( num & mask ) ++ onesCount ; ans += ( nums . size () - onesCount ) * onesCount ; mask = mask << 1 ; } return ans ; } };","title":"477. Total Hamming Distance $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#478-generate-random-point-in-a-circle-starstar","text":"","title":"478. Generate Random Point in a Circle $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#479-largest-palindrome-product-starstarstar","text":"","title":"479. Largest Palindrome Product $\\star\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#480-sliding-window-median-starstarstar","text":"","title":"480. Sliding Window Median $\\star\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/","text":"481. Magical String $\\star\\star$ 482. License Key Formatting $\\star$ 483. Smallest Good Base $\\star\\star\\star$ 484. Find Permutation $\\star\\star$ 485. Max Consecutive Ones $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findMaxConsecutiveOnes ( vector < int >& nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = max ( ans , sum ); } } return ans ; } }; 486. Predict the Winner $\\star\\star$ 487. Max Consecutive Ones II $\\star\\star$ 488. Zuma Game $\\star\\star\\star$ 489. Robot Room Cleaner $\\star\\star\\star$ 490. The Maze $\\star\\star$","title":"0481-0490"},{"location":"cpp/0401-0500/0481-0490/#481-magical-string-starstar","text":"","title":"481. Magical String $\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#482-license-key-formatting-star","text":"","title":"482. License Key Formatting $\\star$"},{"location":"cpp/0401-0500/0481-0490/#483-smallest-good-base-starstarstar","text":"","title":"483. Smallest Good Base $\\star\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#484-find-permutation-starstar","text":"","title":"484. Find Permutation $\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#485-max-consecutive-ones-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findMaxConsecutiveOnes ( vector < int >& nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = max ( ans , sum ); } } return ans ; } };","title":"485. Max Consecutive Ones $\\star$"},{"location":"cpp/0401-0500/0481-0490/#486-predict-the-winner-starstar","text":"","title":"486. Predict the Winner $\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#487-max-consecutive-ones-ii-starstar","text":"","title":"487. Max Consecutive Ones II $\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#488-zuma-game-starstarstar","text":"","title":"488. Zuma Game $\\star\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#489-robot-room-cleaner-starstarstar","text":"","title":"489. Robot Room Cleaner $\\star\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#490-the-maze-starstar","text":"","title":"490. The Maze $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/","text":"491. Increasing Subsequences $\\star\\star$ 492. Construct the Rectangle $\\star$ 493. Reverse Pairs $\\star\\star\\star$ 494. Target Sum $\\star\\star$ 495. Teemo Attacking $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int findPoisonedDuration ( vector < int >& timeSeries , int duration ) { if ( timeSeries . empty () || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . size (); ++ i ) ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ); return ans + duration ; } }; 496. Next Greater Element I $\\star$ 497. Random Point in Non-overlapping Rectangles $\\star\\star$ 498. Diagonal Traverse $\\star\\star$ 499. The Maze III $\\star\\star\\star$ 500. Keyboard Row $\\star$","title":"0491-0500"},{"location":"cpp/0401-0500/0491-0500/#491-increasing-subsequences-starstar","text":"","title":"491. Increasing Subsequences $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#492-construct-the-rectangle-star","text":"","title":"492. Construct the Rectangle $\\star$"},{"location":"cpp/0401-0500/0491-0500/#493-reverse-pairs-starstarstar","text":"","title":"493. Reverse Pairs $\\star\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#494-target-sum-starstar","text":"","title":"494. Target Sum $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#495-teemo-attacking-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int findPoisonedDuration ( vector < int >& timeSeries , int duration ) { if ( timeSeries . empty () || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . size (); ++ i ) ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ); return ans + duration ; } };","title":"495. Teemo Attacking $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#496-next-greater-element-i-star","text":"","title":"496. Next Greater Element I $\\star$"},{"location":"cpp/0401-0500/0491-0500/#497-random-point-in-non-overlapping-rectangles-starstar","text":"","title":"497. Random Point in Non-overlapping Rectangles $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#498-diagonal-traverse-starstar","text":"","title":"498. Diagonal Traverse $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#499-the-maze-iii-starstarstar","text":"","title":"499. The Maze III $\\star\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#500-keyboard-row-star","text":"","title":"500. Keyboard Row $\\star$"},{"location":"cpp/0501-0600/0501-0510/","text":"501. Find Mode in Binary Search Tree $\\star$ 502. IPO $\\star\\star\\star$ 503. Next Greater Element II $\\star\\star$ 504. Base 7 $\\star$ 505. The Maze II $\\star\\star$ 506. Relative Ranks $\\star$ 507. Perfect Number $\\star$ 508. Most Frequent Subtree Sum $\\star\\star$ 509. Fibonacci Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fib ( int N ) { if ( N < 2 ) return N ; int dp [] = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ]; dp [ 1 ] = dp [ 2 ]; dp [ 2 ] = dp [ 0 ] + dp [ 1 ]; } return dp [ 2 ]; } }; 510. Inorder Successor in BST II $\\star\\star$","title":"0501-0510"},{"location":"cpp/0501-0600/0501-0510/#501-find-mode-in-binary-search-tree-star","text":"","title":"501. Find Mode in Binary Search Tree $\\star$"},{"location":"cpp/0501-0600/0501-0510/#502-ipo-starstarstar","text":"","title":"502. IPO $\\star\\star\\star$"},{"location":"cpp/0501-0600/0501-0510/#503-next-greater-element-ii-starstar","text":"","title":"503. Next Greater Element II $\\star\\star$"},{"location":"cpp/0501-0600/0501-0510/#504-base-7-star","text":"","title":"504. Base 7 $\\star$"},{"location":"cpp/0501-0600/0501-0510/#505-the-maze-ii-starstar","text":"","title":"505. The Maze II $\\star\\star$"},{"location":"cpp/0501-0600/0501-0510/#506-relative-ranks-star","text":"","title":"506. Relative Ranks $\\star$"},{"location":"cpp/0501-0600/0501-0510/#507-perfect-number-star","text":"","title":"507. Perfect Number $\\star$"},{"location":"cpp/0501-0600/0501-0510/#508-most-frequent-subtree-sum-starstar","text":"","title":"508. Most Frequent Subtree Sum $\\star\\star$"},{"location":"cpp/0501-0600/0501-0510/#509-fibonacci-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fib ( int N ) { if ( N < 2 ) return N ; int dp [] = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ]; dp [ 1 ] = dp [ 2 ]; dp [ 2 ] = dp [ 0 ] + dp [ 1 ]; } return dp [ 2 ]; } };","title":"509. Fibonacci Number $\\star$"},{"location":"cpp/0501-0600/0501-0510/#510-inorder-successor-in-bst-ii-starstar","text":"","title":"510. Inorder Successor in BST II $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/","text":"511. Game Play Analysis I $\\star$ 512. Game Play Analysis II $\\star$ 513. Find Bottom Left Tree Value $\\star\\star$ 514. Freedom Trail $\\star\\star\\star$ 515. Find Largest Value in Each Tree Row $\\star\\star$ 516. Longest Palindromic Subsequence $\\star\\star$ 517. Super Washing Machines $\\star\\star\\star$ 518. Coin Change 2 $\\star\\star$ 519. Random Flip Matrix $\\star\\star$ 520. Detect Capital $\\star$","title":"0511-0520"},{"location":"cpp/0501-0600/0511-0520/#511-game-play-analysis-i-star","text":"","title":"511. Game Play Analysis I $\\star$"},{"location":"cpp/0501-0600/0511-0520/#512-game-play-analysis-ii-star","text":"","title":"512. Game Play Analysis II $\\star$"},{"location":"cpp/0501-0600/0511-0520/#513-find-bottom-left-tree-value-starstar","text":"","title":"513. Find Bottom Left Tree Value $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#514-freedom-trail-starstarstar","text":"","title":"514. Freedom Trail $\\star\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#515-find-largest-value-in-each-tree-row-starstar","text":"","title":"515. Find Largest Value in Each Tree Row $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#516-longest-palindromic-subsequence-starstar","text":"","title":"516. Longest Palindromic Subsequence $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#517-super-washing-machines-starstarstar","text":"","title":"517. Super Washing Machines $\\star\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#518-coin-change-2-starstar","text":"","title":"518. Coin Change 2 $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#519-random-flip-matrix-starstar","text":"","title":"519. Random Flip Matrix $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#520-detect-capital-star","text":"","title":"520. Detect Capital $\\star$"},{"location":"cpp/0501-0600/0521-0530/","text":"521. Longest Uncommon Subsequence I $\\star$ 522. Longest Uncommon Subsequence II $\\star\\star$ 523. Continuous Subarray Sum $\\star\\star$ 524. Longest Word in Dictionary through Deleting $\\star\\star$ 525. Contiguous Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int findMaxLength ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int ans = 0 ; int sum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ] ? 1 : - 1 ; if ( sum == 0 ) { ans = i + 1 ; } else if ( map . count ( sum )) { ans = max ( ans , i - map [ sum ]); } else { map [ sum ] = i ; } } return ans ; } }; 526. Beautiful Arrangement $\\star\\star$ 527. Word Abbreviation $\\star\\star\\star$ 528. Random Pick with Weight $\\star\\star$ 529. Minesweeper $\\star\\star$ 530. Minimum Absolute Difference in BST $\\star$","title":"0521-0530"},{"location":"cpp/0501-0600/0521-0530/#521-longest-uncommon-subsequence-i-star","text":"","title":"521. Longest Uncommon Subsequence I  $\\star$"},{"location":"cpp/0501-0600/0521-0530/#522-longest-uncommon-subsequence-ii-starstar","text":"","title":"522. Longest Uncommon Subsequence II $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#523-continuous-subarray-sum-starstar","text":"","title":"523. Continuous Subarray Sum $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#524-longest-word-in-dictionary-through-deleting-starstar","text":"","title":"524. Longest Word in Dictionary through Deleting $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#525-contiguous-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int findMaxLength ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int ans = 0 ; int sum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ] ? 1 : - 1 ; if ( sum == 0 ) { ans = i + 1 ; } else if ( map . count ( sum )) { ans = max ( ans , i - map [ sum ]); } else { map [ sum ] = i ; } } return ans ; } };","title":"525. Contiguous Array $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#526-beautiful-arrangement-starstar","text":"","title":"526. Beautiful Arrangement $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#527-word-abbreviation-starstarstar","text":"","title":"527. Word Abbreviation $\\star\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#528-random-pick-with-weight-starstar","text":"","title":"528. Random Pick with Weight $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#529-minesweeper-starstar","text":"","title":"529. Minesweeper $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#530-minimum-absolute-difference-in-bst-star","text":"","title":"530. Minimum Absolute Difference in BST $\\star$"},{"location":"cpp/0501-0600/0531-0540/","text":"531. Lonely Pixel I $\\star\\star$ 532. K-diff Pairs in an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int findPairs ( vector < int >& nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) map [ nums [ i ]] = i ; for ( int i = 0 ; i < nums . size (); ++ i ) { int target = nums [ i ] + k ; if ( map . count ( target ) && map [ target ] != i ) { ++ ans ; map . erase ( target ); } } return ans ; } }; 533. Lonely Pixel II $\\star\\star$ 534. Game Play Analysis III $\\star\\star$ 535. Encode and Decode TinyURL $\\star\\star$ 536. Construct Binary Tree from String $\\star\\star$ 537. Complex Number Multiplication $\\star\\star$ 538. Convert BST to Greater Tree $\\star$ 539. Minimum Time Difference $\\star\\star$ 540. Single Element in a Sorted Array $\\star\\star$","title":"0531-0540"},{"location":"cpp/0501-0600/0531-0540/#531-lonely-pixel-i-starstar","text":"","title":"531. Lonely Pixel I $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#532-k-diff-pairs-in-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int findPairs ( vector < int >& nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) map [ nums [ i ]] = i ; for ( int i = 0 ; i < nums . size (); ++ i ) { int target = nums [ i ] + k ; if ( map . count ( target ) && map [ target ] != i ) { ++ ans ; map . erase ( target ); } } return ans ; } };","title":"532. K-diff Pairs in an Array $\\star$"},{"location":"cpp/0501-0600/0531-0540/#533-lonely-pixel-ii-starstar","text":"","title":"533. Lonely Pixel II $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#534-game-play-analysis-iii-starstar","text":"","title":"534. Game Play Analysis III $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#535-encode-and-decode-tinyurl-starstar","text":"","title":"535. Encode and Decode TinyURL $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#536-construct-binary-tree-from-string-starstar","text":"","title":"536. Construct Binary Tree from String $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#537-complex-number-multiplication-starstar","text":"","title":"537. Complex Number Multiplication $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#538-convert-bst-to-greater-tree-star","text":"","title":"538. Convert BST to Greater Tree $\\star$"},{"location":"cpp/0501-0600/0531-0540/#539-minimum-time-difference-starstar","text":"","title":"539. Minimum Time Difference $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#540-single-element-in-a-sorted-array-starstar","text":"","title":"540. Single Element in a Sorted Array $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/","text":"541. Reverse String II $\\star$ 542. 01 Matrix $\\star\\star$ 543. Diameter of Binary Tree $\\star$ 544. Output Contest Matches $\\star\\star$ 545. Boundary of Binary Tree $\\star\\star$ 546. Remove Boxes $\\star\\star\\star$ 547. Friend Circles $\\star\\star$ 548. Split Array with Equal Sum $\\star\\star$ 549. Binary Tree Longest Consecutive Sequence II $\\star\\star$ 550. Game Play Analysis IV $\\star\\star$","title":"0541-0550"},{"location":"cpp/0501-0600/0541-0550/#541-reverse-string-ii-star","text":"","title":"541. Reverse String II $\\star$"},{"location":"cpp/0501-0600/0541-0550/#542-01-matrix-starstar","text":"","title":"542. 01 Matrix $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#543-diameter-of-binary-tree-star","text":"","title":"543. Diameter of Binary Tree $\\star$"},{"location":"cpp/0501-0600/0541-0550/#544-output-contest-matches-starstar","text":"","title":"544. Output Contest Matches $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#545-boundary-of-binary-tree-starstar","text":"","title":"545. Boundary of Binary Tree $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#546-remove-boxes-starstarstar","text":"","title":"546. Remove Boxes $\\star\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#547-friend-circles-starstar","text":"","title":"547. Friend Circles $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#548-split-array-with-equal-sum-starstar","text":"","title":"548. Split Array with Equal Sum $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#549-binary-tree-longest-consecutive-sequence-ii-starstar","text":"","title":"549. Binary Tree Longest Consecutive Sequence II $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#550-game-play-analysis-iv-starstar","text":"","title":"550. Game Play Analysis IV $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/","text":"551. Student Attendance Record I $\\star$ 552. Student Attendance Record II $\\star\\star\\star$ 553. Optimal Division $\\star\\star$ 554. Brick Wall $\\star\\star$ 555. Split Concatenated Strings $\\star\\star$ 556. Next Greater Element III $\\star\\star$ 557. Reverse Words in a String III $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string reverseWords ( string s ) { int i = 0 ; int j = 0 ; while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( s . begin () + i , s . begin () + j ); } return s ; } }; 558. Quad Tree Intersection $\\star$ 559. Maximum Depth of N-ary Tree $\\star$ 560. Subarray Sum Equals K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraySum ( vector < int >& nums , int k ) { int ans = 0 ; int sum = 0 ; unordered_map < int , int > map ; map [ 0 ] = 1 ; for ( int num : nums ) { sum += num ; ans += map [ sum - k ]; ++ map [ sum ]; } return ans ; } };","title":"0551-0560"},{"location":"cpp/0501-0600/0551-0560/#551-student-attendance-record-i-star","text":"","title":"551. Student Attendance Record I $\\star$"},{"location":"cpp/0501-0600/0551-0560/#552-student-attendance-record-ii-starstarstar","text":"","title":"552. Student Attendance Record II $\\star\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#553-optimal-division-starstar","text":"","title":"553. Optimal Division $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#554-brick-wall-starstar","text":"","title":"554. Brick Wall $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#555-split-concatenated-strings-starstar","text":"","title":"555. Split Concatenated Strings $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#556-next-greater-element-iii-starstar","text":"","title":"556. Next Greater Element III $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#557-reverse-words-in-a-string-iii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string reverseWords ( string s ) { int i = 0 ; int j = 0 ; while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( s . begin () + i , s . begin () + j ); } return s ; } };","title":"557. Reverse Words in a String III $\\star$"},{"location":"cpp/0501-0600/0551-0560/#558-quad-tree-intersection-star","text":"","title":"558. Quad Tree Intersection $\\star$"},{"location":"cpp/0501-0600/0551-0560/#559-maximum-depth-of-n-ary-tree-star","text":"","title":"559. Maximum Depth of N-ary Tree $\\star$"},{"location":"cpp/0501-0600/0551-0560/#560-subarray-sum-equals-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraySum ( vector < int >& nums , int k ) { int ans = 0 ; int sum = 0 ; unordered_map < int , int > map ; map [ 0 ] = 1 ; for ( int num : nums ) { sum += num ; ans += map [ sum - k ]; ++ map [ sum ]; } return ans ; } };","title":"560. Subarray Sum Equals K $\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/","text":"561. Array Partition I $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int arrayPairSum ( vector < int >& nums ) { int ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < nums . size (); i += 2 ) ans += nums [ i ]; return ans ; } }; 562. Longest Line of Consecutive One in Matrix $\\star\\star$ 563. Binary Tree Tilt $\\star$ 564. Find the Closest Palindrome $\\star\\star\\star$ 565. Array Nesting $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int arrayNesting ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ]; nums [ temp ] = - 1 ; ++ count ; } ans = max ( ans , count ); } return ans ; } }; 566. Reshape the Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < vector < int >> matrixReshape ( vector < vector < int >>& nums , int r , int c ) { if ( nums . empty () || r * c != nums . size () * nums [ 0 ]. size ()) return nums ; vector < vector < int >> ans ( r , vector < int > ( c )); int k = 0 ; for ( vector < int >& row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; ++ k ; } return ans ; } }; 567. Permutation in String $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool checkInclusion ( string s1 , string s2 ) { const int m = s1 . length (); const int n = s2 . length (); vector < int > map1 ( 26 ); vector < int > map2 ( 26 ); for ( char c : s1 ) ++ map1 [ c - 'a' ]; for ( int i = 0 ; i < n ; ++ i ) { if ( i >= m ) -- map2 [ s2 [ i - m ] - 'a' ]; ++ map2 [ s2 [ i ] - 'a' ]; if ( map1 == map2 ) return true ; } return false ; } }; 568. Maximum Vacation Days $\\star\\star\\star$ 569. Median Employee Salary $\\star\\star\\star$ 570. Managers with at Least 5 Direct Reports $\\star\\star$","title":"0561-0570"},{"location":"cpp/0501-0600/0561-0570/#561-array-partition-i-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int arrayPairSum ( vector < int >& nums ) { int ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < nums . size (); i += 2 ) ans += nums [ i ]; return ans ; } };","title":"561. Array Partition I $\\star$"},{"location":"cpp/0501-0600/0561-0570/#562-longest-line-of-consecutive-one-in-matrix-starstar","text":"","title":"562. Longest Line of Consecutive One in Matrix $\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#563-binary-tree-tilt-star","text":"","title":"563. Binary Tree Tilt $\\star$"},{"location":"cpp/0501-0600/0561-0570/#564-find-the-closest-palindrome-starstarstar","text":"","title":"564. Find the Closest Palindrome $\\star\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#565-array-nesting-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int arrayNesting ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ]; nums [ temp ] = - 1 ; ++ count ; } ans = max ( ans , count ); } return ans ; } };","title":"565. Array Nesting $\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#566-reshape-the-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < vector < int >> matrixReshape ( vector < vector < int >>& nums , int r , int c ) { if ( nums . empty () || r * c != nums . size () * nums [ 0 ]. size ()) return nums ; vector < vector < int >> ans ( r , vector < int > ( c )); int k = 0 ; for ( vector < int >& row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; ++ k ; } return ans ; } };","title":"566. Reshape the Matrix $\\star$"},{"location":"cpp/0501-0600/0561-0570/#567-permutation-in-string-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool checkInclusion ( string s1 , string s2 ) { const int m = s1 . length (); const int n = s2 . length (); vector < int > map1 ( 26 ); vector < int > map2 ( 26 ); for ( char c : s1 ) ++ map1 [ c - 'a' ]; for ( int i = 0 ; i < n ; ++ i ) { if ( i >= m ) -- map2 [ s2 [ i - m ] - 'a' ]; ++ map2 [ s2 [ i ] - 'a' ]; if ( map1 == map2 ) return true ; } return false ; } };","title":"567. Permutation in String $\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#568-maximum-vacation-days-starstarstar","text":"","title":"568. Maximum Vacation Days $\\star\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#569-median-employee-salary-starstarstar","text":"","title":"569. Median Employee Salary $\\star\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#570-managers-with-at-least-5-direct-reports-starstar","text":"","title":"570. Managers with at Least 5 Direct Reports $\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/","text":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$ 572. Subtree of Another Tree $\\star$ 573. Squirrel Simulation $\\star\\star$ 574. Winning Candidate $\\star\\star$ 575. Distribute Candies $\\star$ 576. Out of Boundary Paths $\\star\\star$ 577. Employee Bonus $\\star$ 578. Get Highest Answer Rate Question $\\star\\star$ 579. Find Cumulative Salary of an Employee $\\star\\star\\star$ 580. Count Student Number in Departments $\\star\\star$","title":"0571-0580"},{"location":"cpp/0501-0600/0571-0580/#571-find-median-given-frequency-of-numbers-starstarstar","text":"","title":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#572-subtree-of-another-tree-star","text":"","title":"572. Subtree of Another Tree $\\star$"},{"location":"cpp/0501-0600/0571-0580/#573-squirrel-simulation-starstar","text":"","title":"573. Squirrel Simulation $\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#574-winning-candidate-starstar","text":"","title":"574. Winning Candidate $\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#575-distribute-candies-star","text":"","title":"575. Distribute Candies $\\star$"},{"location":"cpp/0501-0600/0571-0580/#576-out-of-boundary-paths-starstar","text":"","title":"576. Out of Boundary Paths $\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#577-employee-bonus-star","text":"","title":"577. Employee Bonus $\\star$"},{"location":"cpp/0501-0600/0571-0580/#578-get-highest-answer-rate-question-starstar","text":"","title":"578. Get Highest Answer Rate Question $\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#579-find-cumulative-salary-of-an-employee-starstarstar","text":"","title":"579. Find Cumulative Salary of an Employee $\\star\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#580-count-student-number-in-departments-starstar","text":"","title":"580. Count Student Number in Departments $\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/","text":"581. Shortest Unsorted Continuous Subarray $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int findUnsortedSubarray ( vector < int >& nums ) { int min = INT_MAX ; int max = INT_MIN ; bool flag = false ; for ( int i = 1 ; i < nums . size (); ++ i ) { if ( nums [ i ] < nums [ i - 1 ]) flag = true ; if ( flag ) min = std :: min ( min , nums [ i ]); } flag = false ; for ( int i = nums . size () - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ]) flag = true ; if ( flag ) max = std :: max ( max , nums [ i ]); } int l ; for ( l = 0 ; l < nums . size (); ++ l ) if ( nums [ l ] > min ) break ; int r ; for ( r = nums . size () - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } }; 582. Kill Process $\\star\\star$ 583. Delete Operation for Two Strings $\\star\\star$ 584. Find Customer Referee $\\star$ 585. Investments in 2016 $\\star\\star$ 586. Customer Placing the Largest Number of Orders $\\star$ 587. Erect the Fence $\\star\\star\\star$ 588. Design In-Memory File System $\\star\\star\\star$ 589. N-ary Tree Preorder Traversal $\\star$ 590. N-ary Tree Postorder Traversal $\\star$","title":"0581-0590"},{"location":"cpp/0501-0600/0581-0590/#581-shortest-unsorted-continuous-subarray-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int findUnsortedSubarray ( vector < int >& nums ) { int min = INT_MAX ; int max = INT_MIN ; bool flag = false ; for ( int i = 1 ; i < nums . size (); ++ i ) { if ( nums [ i ] < nums [ i - 1 ]) flag = true ; if ( flag ) min = std :: min ( min , nums [ i ]); } flag = false ; for ( int i = nums . size () - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ]) flag = true ; if ( flag ) max = std :: max ( max , nums [ i ]); } int l ; for ( l = 0 ; l < nums . size (); ++ l ) if ( nums [ l ] > min ) break ; int r ; for ( r = nums . size () - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } };","title":"581. Shortest Unsorted Continuous Subarray $\\star$"},{"location":"cpp/0501-0600/0581-0590/#582-kill-process-starstar","text":"","title":"582. Kill Process $\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/#583-delete-operation-for-two-strings-starstar","text":"","title":"583. Delete Operation for Two Strings $\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/#584-find-customer-referee-star","text":"","title":"584. Find Customer Referee $\\star$"},{"location":"cpp/0501-0600/0581-0590/#585-investments-in-2016-starstar","text":"","title":"585. Investments in 2016 $\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/#586-customer-placing-the-largest-number-of-orders-star","text":"","title":"586. Customer Placing the Largest Number of Orders $\\star$"},{"location":"cpp/0501-0600/0581-0590/#587-erect-the-fence-starstarstar","text":"","title":"587. Erect the Fence $\\star\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/#588-design-in-memory-file-system-starstarstar","text":"","title":"588. Design In-Memory File System $\\star\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/#589-n-ary-tree-preorder-traversal-star","text":"","title":"589. N-ary Tree Preorder Traversal $\\star$"},{"location":"cpp/0501-0600/0581-0590/#590-n-ary-tree-postorder-traversal-star","text":"","title":"590. N-ary Tree Postorder Traversal $\\star$"},{"location":"cpp/0501-0600/0591-0600/","text":"591. Tag Validator $\\star\\star\\star$ 592. Fraction Addition and Subtraction $\\star\\star$ 593. Valid Square $\\star\\star$ 594. Longest Harmonious Subsequence $\\star$ 595. Big Countries $\\star$ 596. Classes More Than 5 Students $\\star$ 597. Friend Requests I: Overall Acceptance Rate $\\star$ 598. Range Addition II $\\star$ 599. Minimum Index Sum of Two Lists $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < string > findRestaurant ( vector < string >& list1 , vector < string >& list2 ) { vector < string > ans ; unordered_map < string , int > map ; for ( int i = 0 ; i < list1 . size (); ++ i ) map [ list1 [ i ]] = i ; int min = INT_MAX ; for ( int i = 0 ; i < list2 . size (); ++ i ) { if ( ! map . count ( list2 [ i ])) continue ; int sum = map [ list2 [ i ]] + i ; if ( sum < min ) ans . clear (); if ( sum <= min ) { min = sum ; ans . push_back ( list2 [ i ]); } } return ans ; } }; 600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$","title":"0591-0600"},{"location":"cpp/0501-0600/0591-0600/#591-tag-validator-starstarstar","text":"","title":"591. Tag Validator $\\star\\star\\star$"},{"location":"cpp/0501-0600/0591-0600/#592-fraction-addition-and-subtraction-starstar","text":"","title":"592. Fraction Addition and Subtraction $\\star\\star$"},{"location":"cpp/0501-0600/0591-0600/#593-valid-square-starstar","text":"","title":"593. Valid Square $\\star\\star$"},{"location":"cpp/0501-0600/0591-0600/#594-longest-harmonious-subsequence-star","text":"","title":"594. Longest Harmonious Subsequence $\\star$"},{"location":"cpp/0501-0600/0591-0600/#595-big-countries-star","text":"","title":"595. Big Countries $\\star$"},{"location":"cpp/0501-0600/0591-0600/#596-classes-more-than-5-students-star","text":"","title":"596. Classes More Than 5 Students $\\star$"},{"location":"cpp/0501-0600/0591-0600/#597-friend-requests-i-overall-acceptance-rate-star","text":"","title":"597. Friend Requests I: Overall Acceptance Rate $\\star$"},{"location":"cpp/0501-0600/0591-0600/#598-range-addition-ii-star","text":"","title":"598. Range Addition II $\\star$"},{"location":"cpp/0501-0600/0591-0600/#599-minimum-index-sum-of-two-lists-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < string > findRestaurant ( vector < string >& list1 , vector < string >& list2 ) { vector < string > ans ; unordered_map < string , int > map ; for ( int i = 0 ; i < list1 . size (); ++ i ) map [ list1 [ i ]] = i ; int min = INT_MAX ; for ( int i = 0 ; i < list2 . size (); ++ i ) { if ( ! map . count ( list2 [ i ])) continue ; int sum = map [ list2 [ i ]] + i ; if ( sum < min ) ans . clear (); if ( sum <= min ) { min = sum ; ans . push_back ( list2 [ i ]); } } return ans ; } };","title":"599. Minimum Index Sum of Two Lists $\\star$"},{"location":"cpp/0501-0600/0591-0600/#600-non-negative-integers-without-consecutive-ones-starstarstar","text":"","title":"600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/","text":"601. Human Traffic of Stadium $\\star\\star\\star$ 602. Friend Requests II: Who Has the Most Friends $\\star\\star$ 603. Consecutive Available Seats $\\star$ 604. Design Compressed String Iterator $\\star$ 605. Can Place Flowers $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canPlaceFlowers ( vector < int >& flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . size (); ++ i ) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . size () - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; -- n ; } if ( n <= 0 ) return true ; } return false ; } }; 606. Construct String from Binary Tree $\\star$ 607. Sales Person $\\star$ 608. Tree Node $\\star\\star$ 609. Find Duplicate File in System $\\star\\star$ 610. Triangle Judgement $\\star$","title":"0601-0610"},{"location":"cpp/0601-0700/0601-0610/#601-human-traffic-of-stadium-starstarstar","text":"","title":"601. Human Traffic of Stadium $\\star\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/#602-friend-requests-ii-who-has-the-most-friends-starstar","text":"","title":"602. Friend Requests II: Who Has the Most Friends $\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/#603-consecutive-available-seats-star","text":"","title":"603. Consecutive Available Seats $\\star$"},{"location":"cpp/0601-0700/0601-0610/#604-design-compressed-string-iterator-star","text":"","title":"604. Design Compressed String Iterator $\\star$"},{"location":"cpp/0601-0700/0601-0610/#605-can-place-flowers-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canPlaceFlowers ( vector < int >& flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . size (); ++ i ) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . size () - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; -- n ; } if ( n <= 0 ) return true ; } return false ; } };","title":"605. Can Place Flowers $\\star$"},{"location":"cpp/0601-0700/0601-0610/#606-construct-string-from-binary-tree-star","text":"","title":"606. Construct String from Binary Tree $\\star$"},{"location":"cpp/0601-0700/0601-0610/#607-sales-person-star","text":"","title":"607. Sales Person $\\star$"},{"location":"cpp/0601-0700/0601-0610/#608-tree-node-starstar","text":"","title":"608. Tree Node $\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/#609-find-duplicate-file-in-system-starstar","text":"","title":"609. Find Duplicate File in System $\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/#610-triangle-judgement-star","text":"","title":"610. Triangle Judgement $\\star$"},{"location":"cpp/0601-0700/0611-0620/","text":"611. Valid Triangle Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int triangleNumber ( vector < int >& nums ) { int ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int k = nums . size () - 1 ; k > 1 ; -- k ) for ( int i = 0 , j = k - 1 ; i < j ;) { if ( nums [ i ] + nums [ j ] > nums [ k ]) { ans += j - i ; -- j ; } else ++ i ; } return ans ; } }; 612. Shortest Distance in a Plane $\\star\\star$ 613. Shortest Distance in a Line $\\star$ 614. Second Degree Follower $\\star\\star$ 615. Average Salary: Departments VS Company $\\star\\star\\star$ 616. Add Bold Tag in String $\\star\\star$ 617. Merge Two Binary Trees $\\star$ 618. Students Report By Geography $\\star\\star\\star$ 619. Biggest Single Number $\\star$ 620. Not Boring Movies $\\star$","title":"0611-0620"},{"location":"cpp/0601-0700/0611-0620/#611-valid-triangle-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int triangleNumber ( vector < int >& nums ) { int ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int k = nums . size () - 1 ; k > 1 ; -- k ) for ( int i = 0 , j = k - 1 ; i < j ;) { if ( nums [ i ] + nums [ j ] > nums [ k ]) { ans += j - i ; -- j ; } else ++ i ; } return ans ; } };","title":"611. Valid Triangle Number $\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#612-shortest-distance-in-a-plane-starstar","text":"","title":"612. Shortest Distance in a Plane $\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#613-shortest-distance-in-a-line-star","text":"","title":"613. Shortest Distance in a Line $\\star$"},{"location":"cpp/0601-0700/0611-0620/#614-second-degree-follower-starstar","text":"","title":"614. Second Degree Follower $\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#615-average-salary-departments-vs-company-starstarstar","text":"","title":"615. Average Salary: Departments VS Company $\\star\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#616-add-bold-tag-in-string-starstar","text":"","title":"616. Add Bold Tag in String $\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#617-merge-two-binary-trees-star","text":"","title":"617. Merge Two Binary Trees $\\star$"},{"location":"cpp/0601-0700/0611-0620/#618-students-report-by-geography-starstarstar","text":"","title":"618. Students Report By Geography $\\star\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#619-biggest-single-number-star","text":"","title":"619. Biggest Single Number $\\star$"},{"location":"cpp/0601-0700/0611-0620/#620-not-boring-movies-star","text":"","title":"620. Not Boring Movies $\\star$"},{"location":"cpp/0601-0700/0621-0630/","text":"621. Task Scheduler $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int leastInterval ( vector < char >& tasks , int n ) { vector < int > count ( 26 , 0 ); for ( char task : tasks ) ++ count [ task - 'A' ]; const int maxCount = * max_element ( count . begin (), count . end ()); int ans = ( maxCount - 1 ) * ( n + 1 ); ans += count_if ( count . begin (), count . end (), [ maxCount ]( int freq ) { return freq == maxCount ; }); return max ( ans , ( int ) tasks . size ()); } }; 622. Design Circular Queue $\\star\\star$ 623. Add One Row to Tree $\\star\\star$ 624. Maximum Distance in Arrays $\\star$ 625. Minimum Factorization $\\star\\star$ 626. Exchange Seats $\\star\\star$ 627. Swap Salary $\\star$ 628. Maximum Product of Three Numbers $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int maximumProduct ( vector < int >& nums ) { int min = INT_MAX ; int secondMin = INT_MAX ; int max = INT_MIN ; int secondMax = INT_MIN ; int thirdMax = INT_MIN ; for ( int num : nums ) { if ( num <= min ) { secondMin = min ; min = num ; } else if ( num <= secondMin ) secondMin = num ; if ( num >= max ) { thirdMax = secondMax ; secondMax = max ; max = num ; } else if ( num >= secondMax ) { thirdMax = secondMax ; secondMax = num ; } else if ( num >= thirdMax ) thirdMax = num ; } return std :: max ( min * secondMin * max , max * secondMax * thirdMax ); } }; 629. K Inverse Pairs Array $\\star\\star\\star$ 630. Course Schedule III $\\star\\star\\star$","title":"0621-0630"},{"location":"cpp/0601-0700/0621-0630/#621-task-scheduler-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int leastInterval ( vector < char >& tasks , int n ) { vector < int > count ( 26 , 0 ); for ( char task : tasks ) ++ count [ task - 'A' ]; const int maxCount = * max_element ( count . begin (), count . end ()); int ans = ( maxCount - 1 ) * ( n + 1 ); ans += count_if ( count . begin (), count . end (), [ maxCount ]( int freq ) { return freq == maxCount ; }); return max ( ans , ( int ) tasks . size ()); } };","title":"621. Task Scheduler $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#622-design-circular-queue-starstar","text":"","title":"622. Design Circular Queue $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#623-add-one-row-to-tree-starstar","text":"","title":"623. Add One Row to Tree $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#624-maximum-distance-in-arrays-star","text":"","title":"624. Maximum Distance in Arrays $\\star$"},{"location":"cpp/0601-0700/0621-0630/#625-minimum-factorization-starstar","text":"","title":"625. Minimum Factorization $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#626-exchange-seats-starstar","text":"","title":"626. Exchange Seats $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#627-swap-salary-star","text":"","title":"627. Swap Salary $\\star$"},{"location":"cpp/0601-0700/0621-0630/#628-maximum-product-of-three-numbers-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int maximumProduct ( vector < int >& nums ) { int min = INT_MAX ; int secondMin = INT_MAX ; int max = INT_MIN ; int secondMax = INT_MIN ; int thirdMax = INT_MIN ; for ( int num : nums ) { if ( num <= min ) { secondMin = min ; min = num ; } else if ( num <= secondMin ) secondMin = num ; if ( num >= max ) { thirdMax = secondMax ; secondMax = max ; max = num ; } else if ( num >= secondMax ) { thirdMax = secondMax ; secondMax = num ; } else if ( num >= thirdMax ) thirdMax = num ; } return std :: max ( min * secondMin * max , max * secondMax * thirdMax ); } };","title":"628. Maximum Product of Three Numbers $\\star$"},{"location":"cpp/0601-0700/0621-0630/#629-k-inverse-pairs-array-starstarstar","text":"","title":"629. K Inverse Pairs Array $\\star\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#630-course-schedule-iii-starstarstar","text":"","title":"630. Course Schedule III $\\star\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/","text":"631. Design Excel Sum Formula $\\star\\star\\star$ 632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$ 633. Sum of Square Numbers $\\star$ 634. Find the Derangement of An Array $\\star\\star$ 635. Design Log Storage System $\\star\\star$ 636. Exclusive Time of Functions $\\star\\star$ 637. Average of Levels in Binary Tree $\\star$ 638. Shopping Offers $\\star\\star$ 639. Decode Ways II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int numDecodings ( string s ) { if ( s . empty ()) return 0 ; long dp1 = count ( s [ 0 ]); long dp2 = 1 ; for ( int i = 1 ; i < s . length (); ++ i ) { long dp = count ( s [ i ]) * dp1 + count ( s [ i - 1 ], s [ i ]) * dp2 ; dp %= int ( 1e9 + 7 ); dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : int count ( char c ) { if ( c == '*' ) return 9 ; return c != '0' ; } int count ( char c1 , char c2 ) { if ( c1 == '*' && c2 == '*' ) return 15 ; if ( c1 == '*' ) return ( c2 >= '0' && c2 <= '6' ) ? 2 : 1 ; if ( c2 == '*' ) { if ( c1 == '1' ) return 9 ; if ( c1 == '2' ) return 6 ; return 0 ; } return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } }; 640. Solve the Equation $\\star\\star$","title":"0631-0640"},{"location":"cpp/0601-0700/0631-0640/#631-design-excel-sum-formula-starstarstar","text":"","title":"631. Design Excel Sum Formula $\\star\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#632-smallest-range-covering-elements-from-k-lists-starstarstar","text":"","title":"632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#633-sum-of-square-numbers-star","text":"","title":"633. Sum of Square Numbers $\\star$"},{"location":"cpp/0601-0700/0631-0640/#634-find-the-derangement-of-an-array-starstar","text":"","title":"634. Find the Derangement of An Array $\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#635-design-log-storage-system-starstar","text":"","title":"635. Design Log Storage System $\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#636-exclusive-time-of-functions-starstar","text":"","title":"636. Exclusive Time of Functions $\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#637-average-of-levels-in-binary-tree-star","text":"","title":"637. Average of Levels in Binary Tree $\\star$"},{"location":"cpp/0601-0700/0631-0640/#638-shopping-offers-starstar","text":"","title":"638. Shopping Offers $\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#639-decode-ways-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int numDecodings ( string s ) { if ( s . empty ()) return 0 ; long dp1 = count ( s [ 0 ]); long dp2 = 1 ; for ( int i = 1 ; i < s . length (); ++ i ) { long dp = count ( s [ i ]) * dp1 + count ( s [ i - 1 ], s [ i ]) * dp2 ; dp %= int ( 1e9 + 7 ); dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : int count ( char c ) { if ( c == '*' ) return 9 ; return c != '0' ; } int count ( char c1 , char c2 ) { if ( c1 == '*' && c2 == '*' ) return 15 ; if ( c1 == '*' ) return ( c2 >= '0' && c2 <= '6' ) ? 2 : 1 ; if ( c2 == '*' ) { if ( c1 == '1' ) return 9 ; if ( c1 == '2' ) return 6 ; return 0 ; } return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } };","title":"639. Decode Ways II $\\star\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#640-solve-the-equation-starstar","text":"","title":"640. Solve the Equation $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/","text":"641. Design Circular Deque $\\star\\star$ 642. Design Search Autocomplete System $\\star\\star\\star$ 643. Maximum Average Subarray I $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : double findMaxAverage ( vector < int >& nums , int k ) { double sum = accumulate ( nums . begin (), nums . begin () + k , 0 ); double ans = sum ; for ( int i = k ; i < nums . size (); ++ i ) { sum += nums [ i ] - nums [ i - k ]; ans = max ( ans , sum ); } return ans / k ; } }; 644. Maximum Average Subarray II $\\star\\star\\star$ 645. Set Mismatch $\\star$ 646. Maximum Length of Pair Chain $\\star\\star$ 647. Palindromic Substrings $\\star\\star$ 648. Replace Words $\\star\\star$ 649. Dota2 Senate $\\star\\star$ 650. 2 Keys Keyboard $\\star\\star$","title":"0641-0650"},{"location":"cpp/0601-0700/0641-0650/#641-design-circular-deque-starstar","text":"","title":"641. Design Circular Deque $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#642-design-search-autocomplete-system-starstarstar","text":"","title":"642. Design Search Autocomplete System $\\star\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#643-maximum-average-subarray-i-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : double findMaxAverage ( vector < int >& nums , int k ) { double sum = accumulate ( nums . begin (), nums . begin () + k , 0 ); double ans = sum ; for ( int i = k ; i < nums . size (); ++ i ) { sum += nums [ i ] - nums [ i - k ]; ans = max ( ans , sum ); } return ans / k ; } };","title":"643. Maximum Average Subarray I $\\star$"},{"location":"cpp/0601-0700/0641-0650/#644-maximum-average-subarray-ii-starstarstar","text":"","title":"644. Maximum Average Subarray II $\\star\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#645-set-mismatch-star","text":"","title":"645. Set Mismatch $\\star$"},{"location":"cpp/0601-0700/0641-0650/#646-maximum-length-of-pair-chain-starstar","text":"","title":"646. Maximum Length of Pair Chain $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#647-palindromic-substrings-starstar","text":"","title":"647. Palindromic Substrings $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#648-replace-words-starstar","text":"","title":"648. Replace Words $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#649-dota2-senate-starstar","text":"","title":"649. Dota2 Senate $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#650-2-keys-keyboard-starstar","text":"","title":"650. 2 Keys Keyboard $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/","text":"651. 4 Keys Keyboard $\\star\\star$ 652. Find Duplicate Subtrees $\\star\\star$ 653. Two Sum IV - Input is a BST $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool findTarget ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == k ) return true ; if ( sum < k ) ++ l ; else -- r ; } return false ; } void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } }; 654. Maximum Binary Tree $\\star\\star$ 655. Print Binary Tree $\\star\\star$ 656. Coin Path $\\star\\star\\star$ 657. Robot Return to Origin $\\star$ 658. Find K Closest Elements $\\star\\star$ 659. Split Array into Consecutive Subsequences $\\star\\star$ 660. Remove 9 $\\star\\star\\star$","title":"0651-0660"},{"location":"cpp/0601-0700/0651-0660/#651-4-keys-keyboard-starstar","text":"","title":"651. 4 Keys Keyboard $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#652-find-duplicate-subtrees-starstar","text":"","title":"652. Find Duplicate Subtrees $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#653-two-sum-iv-input-is-a-bst-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool findTarget ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == k ) return true ; if ( sum < k ) ++ l ; else -- r ; } return false ; } void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } };","title":"653. Two Sum IV - Input is a BST $\\star$"},{"location":"cpp/0601-0700/0651-0660/#654-maximum-binary-tree-starstar","text":"","title":"654. Maximum Binary Tree $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#655-print-binary-tree-starstar","text":"","title":"655. Print Binary Tree $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#656-coin-path-starstarstar","text":"","title":"656. Coin Path $\\star\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#657-robot-return-to-origin-star","text":"","title":"657. Robot Return to Origin $\\star$"},{"location":"cpp/0601-0700/0651-0660/#658-find-k-closest-elements-starstar","text":"","title":"658. Find K Closest Elements $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#659-split-array-into-consecutive-subsequences-starstar","text":"","title":"659. Split Array into Consecutive Subsequences $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#660-remove-9-starstarstar","text":"","title":"660. Remove 9 $\\star\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/","text":"661. Image Smoother $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> imageSmoother ( vector < vector < int >>& M ) { const int m = M . size (); const int n = M [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) { ones += M [ y ][ x ]; ++ count ; } ans [ i ][ j ] = ones / count ; } return ans ; } }; 662. Maximum Width of Binary Tree $\\star\\star$ 663. Equal Tree Partition $\\star\\star$ 664. Strange Printer $\\star\\star\\star$ 665. Non-decreasing Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool checkPossibility ( vector < int >& nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) if ( nums [ i ] > nums [ i + 1 ]) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . size () - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ]; } }; 666. Path Sum IV $\\star\\star$ 667. Beautiful Arrangement II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > constructArray ( int n , int k ) { vector < int > ans ; for ( int i = 0 ; i < n - k ; ++ i ) ans . push_back ( i + 1 ); for ( int i = 0 ; i < k ; ++ i ) { if ( i % 2 == 0 ) ans . push_back ( n - i / 2 ); else ans . push_back ( n - k + ( i + 1 ) / 2 ); } return ans ; } }; 668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$ 669. Trim a Binary Search Tree $\\star$ 670. Maximum Swap $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maximumSwap ( int num ) { string s = to_string ( num ); unordered_map < char , int > map ; for ( int i = 0 ; i < s . length (); ++ i ) map [ s [ i ]] = i ; for ( int i = 0 ; i < s . length (); ++ i ) for ( char digit = '9' ; digit > s [ i ]; -- digit ) if ( map [ digit ] > i ) { s [ map [ digit ]] = s [ i ]; s [ i ] = digit ; return stoi ( s ); } return num ; } };","title":"0661-0670"},{"location":"cpp/0601-0700/0661-0670/#661-image-smoother-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> imageSmoother ( vector < vector < int >>& M ) { const int m = M . size (); const int n = M [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) { ones += M [ y ][ x ]; ++ count ; } ans [ i ][ j ] = ones / count ; } return ans ; } };","title":"661. Image Smoother $\\star$"},{"location":"cpp/0601-0700/0661-0670/#662-maximum-width-of-binary-tree-starstar","text":"","title":"662. Maximum Width of Binary Tree $\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#663-equal-tree-partition-starstar","text":"","title":"663. Equal Tree Partition $\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#664-strange-printer-starstarstar","text":"","title":"664. Strange Printer $\\star\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#665-non-decreasing-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool checkPossibility ( vector < int >& nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) if ( nums [ i ] > nums [ i + 1 ]) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . size () - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ]; } };","title":"665. Non-decreasing Array $\\star$"},{"location":"cpp/0601-0700/0661-0670/#666-path-sum-iv-starstar","text":"","title":"666. Path Sum IV $\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#667-beautiful-arrangement-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > constructArray ( int n , int k ) { vector < int > ans ; for ( int i = 0 ; i < n - k ; ++ i ) ans . push_back ( i + 1 ); for ( int i = 0 ; i < k ; ++ i ) { if ( i % 2 == 0 ) ans . push_back ( n - i / 2 ); else ans . push_back ( n - k + ( i + 1 ) / 2 ); } return ans ; } };","title":"667. Beautiful Arrangement II $\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#668-kth-smallest-number-in-multiplication-table-starstarstar","text":"","title":"668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#669-trim-a-binary-search-tree-star","text":"","title":"669. Trim a Binary Search Tree $\\star$"},{"location":"cpp/0601-0700/0661-0670/#670-maximum-swap-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maximumSwap ( int num ) { string s = to_string ( num ); unordered_map < char , int > map ; for ( int i = 0 ; i < s . length (); ++ i ) map [ s [ i ]] = i ; for ( int i = 0 ; i < s . length (); ++ i ) for ( char digit = '9' ; digit > s [ i ]; -- digit ) if ( map [ digit ] > i ) { s [ map [ digit ]] = s [ i ]; s [ i ] = digit ; return stoi ( s ); } return num ; } };","title":"670. Maximum Swap $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/","text":"671. Second Minimum Node In a Binary Tree $\\star$ 672. Bulb Switcher II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int flipLights ( int n , int m ) { n = min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return n == 1 ? 2 : n == 2 ? 3 : 4 ; if ( m == 2 ) return n == 1 ? 2 : n == 2 ? 4 : 7 ; return n == 1 ? 2 : n == 2 ? 4 : 8 ; } }; 673. Number of Longest Increasing Subsequence $\\star\\star$ 674. Longest Continuous Increasing Subsequence $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int findLengthOfLCIS ( vector < int >& nums ) { int ans = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ]) j = i ; ans = max ( ans , i - j + 1 ); } return ans ; } }; 675. Cut Off Trees for Golf Event $\\star\\star\\star$ 676. Implement Magic Dictionary $\\star\\star$ 677. Map Sum Pairs $\\star\\star$ 678. Valid Parenthesis String $\\star\\star$ 679. 24 Game $\\star\\star\\star$ 680. Valid Palindrome II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool validPalindrome ( string s ) { const int n = s . length (); for ( int i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] != s [ n - 1 - i ]) return validPalindrome ( s , i + 1 , n - 1 - i ) || validPalindrome ( s , i , n - 2 - i ); return true ; } private : bool validPalindrome ( string & s , int l , int r ) { for ( int i = l ; i <= l + ( r - l ) / 2 ; ++ i ) if ( s [ i ] != s [ r - i + l ]) return false ; return true ; } };","title":"0671-0680"},{"location":"cpp/0601-0700/0671-0680/#671-second-minimum-node-in-a-binary-tree-star","text":"","title":"671. Second Minimum Node In a Binary Tree $\\star$"},{"location":"cpp/0601-0700/0671-0680/#672-bulb-switcher-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int flipLights ( int n , int m ) { n = min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return n == 1 ? 2 : n == 2 ? 3 : 4 ; if ( m == 2 ) return n == 1 ? 2 : n == 2 ? 4 : 7 ; return n == 1 ? 2 : n == 2 ? 4 : 8 ; } };","title":"672. Bulb Switcher II $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#673-number-of-longest-increasing-subsequence-starstar","text":"","title":"673. Number of Longest Increasing Subsequence $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#674-longest-continuous-increasing-subsequence-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int findLengthOfLCIS ( vector < int >& nums ) { int ans = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ]) j = i ; ans = max ( ans , i - j + 1 ); } return ans ; } };","title":"674. Longest Continuous Increasing Subsequence $\\star$"},{"location":"cpp/0601-0700/0671-0680/#675-cut-off-trees-for-golf-event-starstarstar","text":"","title":"675. Cut Off Trees for Golf Event $\\star\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#676-implement-magic-dictionary-starstar","text":"","title":"676. Implement Magic Dictionary $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#677-map-sum-pairs-starstar","text":"","title":"677. Map Sum Pairs $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#678-valid-parenthesis-string-starstar","text":"","title":"678. Valid Parenthesis String $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#679-24-game-starstarstar","text":"","title":"679. 24 Game $\\star\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#680-valid-palindrome-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool validPalindrome ( string s ) { const int n = s . length (); for ( int i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] != s [ n - 1 - i ]) return validPalindrome ( s , i + 1 , n - 1 - i ) || validPalindrome ( s , i , n - 2 - i ); return true ; } private : bool validPalindrome ( string & s , int l , int r ) { for ( int i = l ; i <= l + ( r - l ) / 2 ; ++ i ) if ( s [ i ] != s [ r - i + l ]) return false ; return true ; } };","title":"680. Valid Palindrome II $\\star$"},{"location":"cpp/0601-0700/0681-0690/","text":"681. Next Closest Time $\\star\\star$ 682. Baseball Game $\\star$ 683. K Empty Slots $\\star\\star\\star$ 684. Redundant Connection $\\star\\star$ 685. Redundant Connection II $\\star\\star\\star$ 686. Repeated String Match $\\star$ 687. Longest Univalue Path $\\star$ 688. Knight Probability in Chessboard $\\star\\star$ 689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : vector < int > maxSumOfThreeSubarrays ( vector < int >& nums , int k ) { vector < int > ans = { - 1 , - 1 , - 1 }; int subarrayCount = nums . size () - k + 1 ; vector < int > dp ( subarrayCount ); int sum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; if ( i >= k ) sum -= nums [ i - k ]; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } vector < int > left ( subarrayCount ); int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; ++ i ) { if ( dp [ i ] > dp [ maxIndex ]) maxIndex = i ; left [ i ] = maxIndex ; } vector < int > right ( subarrayCount ); maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; -- i ) { if ( dp [ i ] >= dp [ maxIndex ]) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; ++ i ) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]) ans = { left [ i - k ], i , right [ i + k ]}; return ans ; } }; 690. Employee Importance $\\star$","title":"0681-0690"},{"location":"cpp/0601-0700/0681-0690/#681-next-closest-time-starstar","text":"","title":"681. Next Closest Time $\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#682-baseball-game-star","text":"","title":"682. Baseball Game $\\star$"},{"location":"cpp/0601-0700/0681-0690/#683-k-empty-slots-starstarstar","text":"","title":"683. K Empty Slots $\\star\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#684-redundant-connection-starstar","text":"","title":"684. Redundant Connection $\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#685-redundant-connection-ii-starstarstar","text":"","title":"685. Redundant Connection II $\\star\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#686-repeated-string-match-star","text":"","title":"686. Repeated String Match $\\star$"},{"location":"cpp/0601-0700/0681-0690/#687-longest-univalue-path-star","text":"","title":"687. Longest Univalue Path $\\star$"},{"location":"cpp/0601-0700/0681-0690/#688-knight-probability-in-chessboard-starstar","text":"","title":"688. Knight Probability in Chessboard $\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#689-maximum-sum-of-3-non-overlapping-subarrays-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : vector < int > maxSumOfThreeSubarrays ( vector < int >& nums , int k ) { vector < int > ans = { - 1 , - 1 , - 1 }; int subarrayCount = nums . size () - k + 1 ; vector < int > dp ( subarrayCount ); int sum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; if ( i >= k ) sum -= nums [ i - k ]; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } vector < int > left ( subarrayCount ); int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; ++ i ) { if ( dp [ i ] > dp [ maxIndex ]) maxIndex = i ; left [ i ] = maxIndex ; } vector < int > right ( subarrayCount ); maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; -- i ) { if ( dp [ i ] >= dp [ maxIndex ]) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; ++ i ) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]) ans = { left [ i - k ], i , right [ i + k ]}; return ans ; } };","title":"689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#690-employee-importance-star","text":"","title":"690. Employee Importance $\\star$"},{"location":"cpp/0601-0700/0691-0700/","text":"691. Stickers to Spell Word $\\star\\star\\star$ 692. Top K Frequent Words $\\star\\star$ 693. Binary Number with Alternating Bits $\\star$ 694. Number of Distinct Islands $\\star\\star$ 695. Max Area of Island $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> visited ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = max ( ans , dfs ( grid , i , j , visited )); return ans ; } private : int dfs ( vector < vector < int >>& grid , int i , int j , vector < vector < bool >>& visited ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || visited [ i ][ j ] || grid [ i ][ j ] == 0 ) return 0 ; visited [ i ][ j ] = true ; return 1 + dfs ( grid , i + 1 , j , visited ) + dfs ( grid , i - 1 , j , visited ) + dfs ( grid , i , j + 1 , visited ) + dfs ( grid , i , j - 1 , visited ); } }; 696. Count Binary Substrings $\\star$ 697. Degree of an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findShortestSubArray ( vector < int >& nums ) { int ans = 0 ; int degree = 0 ; unordered_map < int , int > firstSeen ; unordered_map < int , int > numCounts ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! firstSeen . count ( nums [ i ])) firstSeen [ nums [ i ]] = i ; ++ numCounts [ nums [ i ]]; if ( numCounts [ nums [ i ]] > degree ) { degree = numCounts [ nums [ i ]]; ans = i - firstSeen [ nums [ i ]] + 1 ; } else if ( numCounts [ nums [ i ]] == degree ) ans = min ( ans , i - firstSeen [ nums [ i ]] + 1 ); } return ans ; } }; 698. Partition to K Equal Sum Subsets $\\star\\star$ 699. Falling Squares $\\star\\star\\star$ 700. Search in a Binary Search Tree $\\star$","title":"0691-0700"},{"location":"cpp/0601-0700/0691-0700/#691-stickers-to-spell-word-starstarstar","text":"","title":"691. Stickers to Spell Word $\\star\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#692-top-k-frequent-words-starstar","text":"","title":"692. Top K Frequent Words $\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#693-binary-number-with-alternating-bits-star","text":"","title":"693. Binary Number with Alternating Bits $\\star$"},{"location":"cpp/0601-0700/0691-0700/#694-number-of-distinct-islands-starstar","text":"","title":"694. Number of Distinct Islands $\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#695-max-area-of-island-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> visited ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = max ( ans , dfs ( grid , i , j , visited )); return ans ; } private : int dfs ( vector < vector < int >>& grid , int i , int j , vector < vector < bool >>& visited ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || visited [ i ][ j ] || grid [ i ][ j ] == 0 ) return 0 ; visited [ i ][ j ] = true ; return 1 + dfs ( grid , i + 1 , j , visited ) + dfs ( grid , i - 1 , j , visited ) + dfs ( grid , i , j + 1 , visited ) + dfs ( grid , i , j - 1 , visited ); } };","title":"695. Max Area of Island $\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#696-count-binary-substrings-star","text":"","title":"696. Count Binary Substrings $\\star$"},{"location":"cpp/0601-0700/0691-0700/#697-degree-of-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findShortestSubArray ( vector < int >& nums ) { int ans = 0 ; int degree = 0 ; unordered_map < int , int > firstSeen ; unordered_map < int , int > numCounts ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! firstSeen . count ( nums [ i ])) firstSeen [ nums [ i ]] = i ; ++ numCounts [ nums [ i ]]; if ( numCounts [ nums [ i ]] > degree ) { degree = numCounts [ nums [ i ]]; ans = i - firstSeen [ nums [ i ]] + 1 ; } else if ( numCounts [ nums [ i ]] == degree ) ans = min ( ans , i - firstSeen [ nums [ i ]] + 1 ); } return ans ; } };","title":"697. Degree of an Array $\\star$"},{"location":"cpp/0601-0700/0691-0700/#698-partition-to-k-equal-sum-subsets-starstar","text":"","title":"698. Partition to K Equal Sum Subsets $\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#699-falling-squares-starstarstar","text":"","title":"699. Falling Squares $\\star\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#700-search-in-a-binary-search-tree-star","text":"","title":"700. Search in a Binary Search Tree $\\star$"},{"location":"cpp/0701-0800/0701-0710/","text":"701. Insert into a Binary Search Tree $\\star\\star$ 702. Search in a Sorted Array of Unknown Size $\\star\\star$ 703. Kth Largest Element in a Stream $\\star$ 704. Binary Search $\\star$ 705. Design HashSet $\\star$ 706. Design HashMap $\\star$ 707. Design Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class MyLinkedList { public : MyLinkedList () : length ( 0 ) { head = new ListNode ( 0 ); } int get ( int index ) { if ( index < 0 || index >= length ) return - 1 ; ListNode * curr = head -> next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; return curr -> val ; } void addAtHead ( int val ) { ListNode * curr = head -> next ; head -> next = new ListNode ( val ); head -> next -> next = curr ; ++ length ; } void addAtTail ( int val ) { ListNode * curr = head ; while ( curr -> next ) curr = curr -> next ; curr -> next = new ListNode ( val ); ++ length ; } void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode * curr = head ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = new ListNode ( val ); curr -> next -> next = temp ; ++ length ; } void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode * curr = head ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = temp -> next ; -- length ; delete temp ; } private : struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( nullptr ) {} }; int length ; ListNode * head ; }; 708. Insert into a Sorted Circular Linked List $\\star\\star$ 709. To Lower Case $\\star$ 710. Random Pick with Blacklist $\\star\\star\\star$","title":"0701-0710"},{"location":"cpp/0701-0800/0701-0710/#701-insert-into-a-binary-search-tree-starstar","text":"","title":"701. Insert into a Binary Search Tree $\\star\\star$"},{"location":"cpp/0701-0800/0701-0710/#702-search-in-a-sorted-array-of-unknown-size-starstar","text":"","title":"702. Search in a Sorted Array of Unknown Size $\\star\\star$"},{"location":"cpp/0701-0800/0701-0710/#703-kth-largest-element-in-a-stream-star","text":"","title":"703. Kth Largest Element in a Stream $\\star$"},{"location":"cpp/0701-0800/0701-0710/#704-binary-search-star","text":"","title":"704. Binary Search $\\star$"},{"location":"cpp/0701-0800/0701-0710/#705-design-hashset-star","text":"","title":"705. Design HashSet $\\star$"},{"location":"cpp/0701-0800/0701-0710/#706-design-hashmap-star","text":"","title":"706. Design HashMap $\\star$"},{"location":"cpp/0701-0800/0701-0710/#707-design-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class MyLinkedList { public : MyLinkedList () : length ( 0 ) { head = new ListNode ( 0 ); } int get ( int index ) { if ( index < 0 || index >= length ) return - 1 ; ListNode * curr = head -> next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; return curr -> val ; } void addAtHead ( int val ) { ListNode * curr = head -> next ; head -> next = new ListNode ( val ); head -> next -> next = curr ; ++ length ; } void addAtTail ( int val ) { ListNode * curr = head ; while ( curr -> next ) curr = curr -> next ; curr -> next = new ListNode ( val ); ++ length ; } void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode * curr = head ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = new ListNode ( val ); curr -> next -> next = temp ; ++ length ; } void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode * curr = head ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = temp -> next ; -- length ; delete temp ; } private : struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( nullptr ) {} }; int length ; ListNode * head ; };","title":"707. Design Linked List $\\star\\star$"},{"location":"cpp/0701-0800/0701-0710/#708-insert-into-a-sorted-circular-linked-list-starstar","text":"","title":"708. Insert into a Sorted Circular Linked List $\\star\\star$"},{"location":"cpp/0701-0800/0701-0710/#709-to-lower-case-star","text":"","title":"709. To Lower Case $\\star$"},{"location":"cpp/0701-0800/0701-0710/#710-random-pick-with-blacklist-starstarstar","text":"","title":"710. Random Pick with Blacklist $\\star\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/","text":"711. Number of Distinct Islands II $\\star\\star\\star$ 712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$ 713. Subarray Product Less Than K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { prod *= nums [ i ]; while ( prod >= k ) prod /= nums [ j ++ ]; ans += i - j + 1 ; } return ans ; } }; 714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices , int fee ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price - fee ); } return sell ; } }; 715. Range Module $\\star\\star\\star$ 716. Max Stack $\\star$ 717. 1-bit and 2-bit Characters $\\star$ 1 2 3 4 5 6 7 8 9 class Solution { public : bool isOneBitCharacter ( vector < int >& bits ) { int i = 0 ; while ( i < bits . size () - 1 ) i += bits [ i ] + 1 ; return i == bits . size () - 1 ; } }; 718. Maximum Length of Repeated Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findLength ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); int ans = 0 ; vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , 0 )); for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) if ( A [ i ] == B [ j ]) dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; for ( vector < int >& row : dp ) ans = max ( ans , * max_element ( row . begin (), row . end ())); return ans ; } }; 719. Find K-th Smallest Pair Distance $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { sort ( nums . begin (), nums . end ()); int l = 0 ; int r = nums . back () - nums . front (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { while ( j < nums . size () && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } }; 720. Longest Word in Dictionary $\\star$","title":"0711-0720"},{"location":"cpp/0701-0800/0711-0720/#711-number-of-distinct-islands-ii-starstarstar","text":"","title":"711. Number of Distinct Islands II $\\star\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#712-minimum-ascii-delete-sum-for-two-strings-starstar","text":"","title":"712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#713-subarray-product-less-than-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { prod *= nums [ i ]; while ( prod >= k ) prod /= nums [ j ++ ]; ans += i - j + 1 ; } return ans ; } };","title":"713. Subarray Product Less Than K $\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#714-best-time-to-buy-and-sell-stock-with-transaction-fee-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices , int fee ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price - fee ); } return sell ; } };","title":"714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#715-range-module-starstarstar","text":"","title":"715. Range Module $\\star\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#716-max-stack-star","text":"","title":"716. Max Stack $\\star$"},{"location":"cpp/0701-0800/0711-0720/#717-1-bit-and-2-bit-characters-star","text":"1 2 3 4 5 6 7 8 9 class Solution { public : bool isOneBitCharacter ( vector < int >& bits ) { int i = 0 ; while ( i < bits . size () - 1 ) i += bits [ i ] + 1 ; return i == bits . size () - 1 ; } };","title":"717. 1-bit and 2-bit Characters $\\star$"},{"location":"cpp/0701-0800/0711-0720/#718-maximum-length-of-repeated-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findLength ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); int ans = 0 ; vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , 0 )); for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) if ( A [ i ] == B [ j ]) dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; for ( vector < int >& row : dp ) ans = max ( ans , * max_element ( row . begin (), row . end ())); return ans ; } };","title":"718. Maximum Length of Repeated Subarray $\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#719-find-k-th-smallest-pair-distance-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { sort ( nums . begin (), nums . end ()); int l = 0 ; int r = nums . back () - nums . front (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { while ( j < nums . size () && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } };","title":"719. Find K-th Smallest Pair Distance $\\star\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#720-longest-word-in-dictionary-star","text":"","title":"720. Longest Word in Dictionary $\\star$"},{"location":"cpp/0701-0800/0721-0730/","text":"721. Accounts Merge $\\star\\star$ 722. Remove Comments $\\star\\star$ 723. Candy Crush $\\star\\star$ 724. Find Pivot Index $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int pivotIndex ( vector < int >& nums ) { int sum = accumulate ( nums . begin (), nums . end (), 0 ); int presum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( presum == sum - presum - nums [ i ]) return i ; presum += nums [ i ]; } return - 1 ; } }; 725. Split Linked List in Parts $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < ListNode *> splitListToParts ( ListNode * root , int k ) { vector < ListNode *> ans ( k , NULL ); int length = 0 ; for ( auto curr = root ; curr ; curr = curr -> next ) ++ length ; int l = length / k ; int r = length % k ; ListNode * head = root ; ListNode * prev = NULL ; for ( int i = 0 ; i < k ; ++ i , -- r ) { ans [ i ] = head ; for ( int j = 0 ; j < l + ( r > 0 ); ++ j ) { prev = head ; head = head -> next ; } if ( prev ) prev -> next = NULL ; } return ans ; } }; 726. Number of Atoms $\\star\\star\\star$ 727. Minimum Window Subsequence $\\star\\star\\star$ 728. Self Dividing Numbers $\\star$ 729. My Calendar I $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class MyCalendar { public : bool book ( int start , int end ) { for ( pair < int , int >& book : books ) if ( max ( book . first , start ) < min ( book . second , end )) return false ; books . push_back ({ start , end }); return true ; } private : vector < pair < int , int >> books ; }; 730. Count Different Palindromic Subsequences $\\star\\star\\star$","title":"0721-0730"},{"location":"cpp/0701-0800/0721-0730/#721-accounts-merge-starstar","text":"","title":"721. Accounts Merge $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#722-remove-comments-starstar","text":"","title":"722. Remove Comments $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#723-candy-crush-starstar","text":"","title":"723. Candy Crush $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#724-find-pivot-index-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int pivotIndex ( vector < int >& nums ) { int sum = accumulate ( nums . begin (), nums . end (), 0 ); int presum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( presum == sum - presum - nums [ i ]) return i ; presum += nums [ i ]; } return - 1 ; } };","title":"724. Find Pivot Index $\\star$"},{"location":"cpp/0701-0800/0721-0730/#725-split-linked-list-in-parts-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < ListNode *> splitListToParts ( ListNode * root , int k ) { vector < ListNode *> ans ( k , NULL ); int length = 0 ; for ( auto curr = root ; curr ; curr = curr -> next ) ++ length ; int l = length / k ; int r = length % k ; ListNode * head = root ; ListNode * prev = NULL ; for ( int i = 0 ; i < k ; ++ i , -- r ) { ans [ i ] = head ; for ( int j = 0 ; j < l + ( r > 0 ); ++ j ) { prev = head ; head = head -> next ; } if ( prev ) prev -> next = NULL ; } return ans ; } };","title":"725. Split Linked List in Parts $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#726-number-of-atoms-starstarstar","text":"","title":"726. Number of Atoms $\\star\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#727-minimum-window-subsequence-starstarstar","text":"","title":"727. Minimum Window Subsequence $\\star\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#728-self-dividing-numbers-star","text":"","title":"728. Self Dividing Numbers $\\star$"},{"location":"cpp/0701-0800/0721-0730/#729-my-calendar-i-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class MyCalendar { public : bool book ( int start , int end ) { for ( pair < int , int >& book : books ) if ( max ( book . first , start ) < min ( book . second , end )) return false ; books . push_back ({ start , end }); return true ; } private : vector < pair < int , int >> books ; };","title":"729. My Calendar I $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#730-count-different-palindromic-subsequences-starstarstar","text":"","title":"730. Count Different Palindromic Subsequences $\\star\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/","text":"731. My Calendar II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyCalendarTwo { public : MyCalendarTwo () {} bool book ( int start , int end ) { for ( auto & [ first , second ] : overlaps ) if ( max ( start , first ) < min ( end , second )) return false ; for ( auto & [ first , second ] : booked ) { int s = max ( start , first ); int e = min ( end , second ); if ( s < e ) overlaps . emplace_back ( s , e ); } booked . emplace_back ( start , end ); return true ; } private : vector < pair < int , int >> booked ; vector < pair < int , int >> overlaps ; }; 732. My Calendar III $\\star\\star\\star$ 733. Flood Fill $\\star$ 734. Sentence Similarity $\\star$ 735. Asteroid Collision $\\star\\star$ 736. Parse Lisp Expression $\\star\\star\\star$ 737. Sentence Similarity II $\\star\\star$ 738. Monotone Increasing Digits $\\star\\star$ 739. Daily Temperatures $\\star\\star$ 740. Delete and Earn $\\star\\star$","title":"0731-0740"},{"location":"cpp/0701-0800/0731-0740/#731-my-calendar-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyCalendarTwo { public : MyCalendarTwo () {} bool book ( int start , int end ) { for ( auto & [ first , second ] : overlaps ) if ( max ( start , first ) < min ( end , second )) return false ; for ( auto & [ first , second ] : booked ) { int s = max ( start , first ); int e = min ( end , second ); if ( s < e ) overlaps . emplace_back ( s , e ); } booked . emplace_back ( start , end ); return true ; } private : vector < pair < int , int >> booked ; vector < pair < int , int >> overlaps ; };","title":"731. My Calendar II $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#732-my-calendar-iii-starstarstar","text":"","title":"732. My Calendar III $\\star\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#733-flood-fill-star","text":"","title":"733. Flood Fill $\\star$"},{"location":"cpp/0701-0800/0731-0740/#734-sentence-similarity-star","text":"","title":"734. Sentence Similarity $\\star$"},{"location":"cpp/0701-0800/0731-0740/#735-asteroid-collision-starstar","text":"","title":"735. Asteroid Collision $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#736-parse-lisp-expression-starstarstar","text":"","title":"736. Parse Lisp Expression $\\star\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#737-sentence-similarity-ii-starstar","text":"","title":"737. Sentence Similarity II $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#738-monotone-increasing-digits-starstar","text":"","title":"738. Monotone Increasing Digits $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#739-daily-temperatures-starstar","text":"","title":"739. Daily Temperatures $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#740-delete-and-earn-starstar","text":"","title":"740. Delete and Earn $\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/","text":"741. Cherry Pickup $\\star\\star\\star$ 742. Closest Leaf in a Binary Tree $\\star\\star$ 743. Network Delay Time $\\star\\star$ 744. Find Smallest Letter Greater Than Target $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : char nextGreatestLetter ( vector < char >& letters , char target ) { int l = 0 ; int r = letters . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( letters [ m ] <= target ) l = m + 1 ; else r = m ; } return letters [ l % letters . size ()]; } }; 745. Prefix and Suffix Search $\\star\\star\\star$ 746. Min Cost Climbing Stairs $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int minCostClimbingStairs ( vector < int >& cost ) { const int n = cost . size (); for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]); return min ( cost [ n - 1 ], cost [ n - 2 ]); } }; 747. Largest Number At Least Twice of Others $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int dominantIndex ( vector < int >& nums ) { int ans ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ]; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ]; } return max >= 2 * secondMax ? ans : - 1 ; } }; 748. Shortest Completing Word $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string shortestCompletingWord ( string licensePlate , vector < string >& words ) { string ans ; vector < int > map ( 26 ); for ( char c : licensePlate ) if ( isalpha ( c )) ++ map [ tolower ( c ) - 'a' ]; int min = INT_MAX ; for ( string & word : words ) { if ( word . length () >= min ) continue ; if ( ! isMatch ( word , map )) continue ; min = word . length (); ans = word ; } return ans ; } private : bool isMatch ( string & word , vector < int >& map ) { vector < int > wordMap ( 26 ); for ( char c : word ) ++ wordMap [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) if ( wordMap [ i ] < map [ i ]) return false ; return true ; } }; 749. Contain Virus $\\star\\star\\star$ 750. Number Of Corner Rectangles $\\star\\star$","title":"0741-0750"},{"location":"cpp/0701-0800/0741-0750/#741-cherry-pickup-starstarstar","text":"","title":"741. Cherry Pickup $\\star\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#742-closest-leaf-in-a-binary-tree-starstar","text":"","title":"742. Closest Leaf in a Binary Tree $\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#743-network-delay-time-starstar","text":"","title":"743. Network Delay Time $\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#744-find-smallest-letter-greater-than-target-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : char nextGreatestLetter ( vector < char >& letters , char target ) { int l = 0 ; int r = letters . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( letters [ m ] <= target ) l = m + 1 ; else r = m ; } return letters [ l % letters . size ()]; } };","title":"744. Find Smallest Letter Greater Than Target $\\star$"},{"location":"cpp/0701-0800/0741-0750/#745-prefix-and-suffix-search-starstarstar","text":"","title":"745. Prefix and Suffix Search $\\star\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#746-min-cost-climbing-stairs-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int minCostClimbingStairs ( vector < int >& cost ) { const int n = cost . size (); for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]); return min ( cost [ n - 1 ], cost [ n - 2 ]); } };","title":"746. Min Cost Climbing Stairs $\\star$"},{"location":"cpp/0701-0800/0741-0750/#747-largest-number-at-least-twice-of-others-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int dominantIndex ( vector < int >& nums ) { int ans ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ]; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ]; } return max >= 2 * secondMax ? ans : - 1 ; } };","title":"747. Largest Number At Least Twice of Others $\\star$"},{"location":"cpp/0701-0800/0741-0750/#748-shortest-completing-word-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string shortestCompletingWord ( string licensePlate , vector < string >& words ) { string ans ; vector < int > map ( 26 ); for ( char c : licensePlate ) if ( isalpha ( c )) ++ map [ tolower ( c ) - 'a' ]; int min = INT_MAX ; for ( string & word : words ) { if ( word . length () >= min ) continue ; if ( ! isMatch ( word , map )) continue ; min = word . length (); ans = word ; } return ans ; } private : bool isMatch ( string & word , vector < int >& map ) { vector < int > wordMap ( 26 ); for ( char c : word ) ++ wordMap [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) if ( wordMap [ i ] < map [ i ]) return false ; return true ; } };","title":"748. Shortest Completing Word $\\star$"},{"location":"cpp/0701-0800/0741-0750/#749-contain-virus-starstarstar","text":"","title":"749. Contain Virus $\\star\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#750-number-of-corner-rectangles-starstar","text":"","title":"750. Number Of Corner Rectangles $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/","text":"751. IP to CIDR $\\star$ 752. Open the Lock $\\star\\star$ 753. Cracking the Safe $\\star\\star\\star$ 754. Reach a Number $\\star\\star$ 755. Pour Water $\\star\\star$ 756. Pyramid Transition Matrix $\\star\\star$ 757. Set Intersection Size At Least Two $\\star\\star\\star$ 758. Bold Words in String $\\star$ 759. Employee Free Time $\\star\\star\\star$ 760. Find Anagram Mappings $\\star$","title":"0751-0760"},{"location":"cpp/0701-0800/0751-0760/#751-ip-to-cidr-star","text":"","title":"751. IP to CIDR $\\star$"},{"location":"cpp/0701-0800/0751-0760/#752-open-the-lock-starstar","text":"","title":"752. Open the Lock $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#753-cracking-the-safe-starstarstar","text":"","title":"753. Cracking the Safe $\\star\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#754-reach-a-number-starstar","text":"","title":"754. Reach a Number $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#755-pour-water-starstar","text":"","title":"755. Pour Water $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#756-pyramid-transition-matrix-starstar","text":"","title":"756. Pyramid Transition Matrix $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#757-set-intersection-size-at-least-two-starstarstar","text":"","title":"757. Set Intersection Size At Least Two $\\star\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#758-bold-words-in-string-star","text":"","title":"758. Bold Words in String $\\star$"},{"location":"cpp/0701-0800/0751-0760/#759-employee-free-time-starstarstar","text":"","title":"759. Employee Free Time $\\star\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#760-find-anagram-mappings-star","text":"","title":"760. Find Anagram Mappings $\\star$"},{"location":"cpp/0701-0800/0761-0770/","text":"761. Special Binary String $\\star\\star\\star$ 762. Prime Number of Set Bits in Binary Representation $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int countPrimeSetBits ( int L , int R ) { // (10100010100010101100)2 = (665772)10 constexpr int magic = 665772 ; int ans = 0 ; for ( int n = L ; n <= R ; ++ n ) if ( magic & ( 1 << __builtin_popcountll ( n ))) ++ ans ; return ans ; } }; 763. Partition Labels $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > partitionLabels ( string S ) { vector < int > ans ; vector < int > map ( 26 ); for ( int i = 0 ; i < S . length (); ++ i ) map [ S [ i ] - 'a' ] = i ; int start = 0 ; int end = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { end = max ( end , map [ S [ i ] - 'a' ]); if ( i == end ) { ans . push_back ( end - start + 1 ); start = end + 1 ; } } return ans ; } }; 764. Largest Plus Sign $\\star\\star$ 765. Couples Holding Hands $\\star\\star\\star$ 766. Toeplitz Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { for ( int i = 0 ; i + 1 < matrix . size (); ++ i ) for ( int j = 0 ; j + 1 < matrix [ 0 ]. size (); ++ j ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]) return false ; return true ; } }; 767. Reorganize String $\\star\\star$ 768. Max Chunks To Make Sorted II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { const int n = arr . size (); int ans = 0 ; int max = INT_MIN ; vector < int > min ( n , arr . back ()); for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], arr [ i ]); for ( int i = 0 ; i < n - 1 ; ++ i ) { max = std :: max ( max , arr [ i ]); if ( max <= min [ i + 1 ]) ++ ans ; } return ans + 1 ; } }; 769. Max Chunks To Make Sorted $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 0 ; int max = INT_MIN ; for ( int i = 0 ; i < arr . size (); ++ i ) { max = std :: max ( max , arr [ i ]); if ( max == i ) ++ ans ; } return ans ; } }; 770. Basic Calculator IV $\\star\\star\\star$","title":"0761-0770"},{"location":"cpp/0701-0800/0761-0770/#761-special-binary-string-starstarstar","text":"","title":"761. Special Binary String $\\star\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#762-prime-number-of-set-bits-in-binary-representation-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int countPrimeSetBits ( int L , int R ) { // (10100010100010101100)2 = (665772)10 constexpr int magic = 665772 ; int ans = 0 ; for ( int n = L ; n <= R ; ++ n ) if ( magic & ( 1 << __builtin_popcountll ( n ))) ++ ans ; return ans ; } };","title":"762. Prime Number of Set Bits in Binary Representation $\\star$"},{"location":"cpp/0701-0800/0761-0770/#763-partition-labels-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > partitionLabels ( string S ) { vector < int > ans ; vector < int > map ( 26 ); for ( int i = 0 ; i < S . length (); ++ i ) map [ S [ i ] - 'a' ] = i ; int start = 0 ; int end = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { end = max ( end , map [ S [ i ] - 'a' ]); if ( i == end ) { ans . push_back ( end - start + 1 ); start = end + 1 ; } } return ans ; } };","title":"763. Partition Labels $\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#764-largest-plus-sign-starstar","text":"","title":"764. Largest Plus Sign $\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#765-couples-holding-hands-starstarstar","text":"","title":"765. Couples Holding Hands $\\star\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#766-toeplitz-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { for ( int i = 0 ; i + 1 < matrix . size (); ++ i ) for ( int j = 0 ; j + 1 < matrix [ 0 ]. size (); ++ j ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]) return false ; return true ; } };","title":"766. Toeplitz Matrix $\\star$"},{"location":"cpp/0701-0800/0761-0770/#767-reorganize-string-starstar","text":"","title":"767. Reorganize String $\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#768-max-chunks-to-make-sorted-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { const int n = arr . size (); int ans = 0 ; int max = INT_MIN ; vector < int > min ( n , arr . back ()); for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], arr [ i ]); for ( int i = 0 ; i < n - 1 ; ++ i ) { max = std :: max ( max , arr [ i ]); if ( max <= min [ i + 1 ]) ++ ans ; } return ans + 1 ; } };","title":"768. Max Chunks To Make Sorted II $\\star\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#769-max-chunks-to-make-sorted-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 0 ; int max = INT_MIN ; for ( int i = 0 ; i < arr . size (); ++ i ) { max = std :: max ( max , arr [ i ]); if ( max == i ) ++ ans ; } return ans ; } };","title":"769. Max Chunks To Make Sorted $\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#770-basic-calculator-iv-starstarstar","text":"","title":"770. Basic Calculator IV $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/","text":"771. Jewels and Stones $\\star$ 772. Basic Calculator III $\\star\\star\\star$ 773. Sliding Puzzle $\\star\\star\\star$ 774. Minimize Max Distance to Gas Station $\\star\\star\\star$ 775. Global and Local Inversions $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution { public : bool isIdealPermutation ( vector < int >& A ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( abs ( A [ i ] - i ) > 1 ) return false ; return true ; } }; 776. Split BST $\\star\\star$ 777. Swap Adjacent in LR String $\\star\\star$ 778. Swim in Rising Water $\\star\\star\\star$ 779. K-th Symbol in Grammar $\\star\\star$ 780. Reaching Points $\\star\\star\\star$","title":"0771-0780"},{"location":"cpp/0701-0800/0771-0780/#771-jewels-and-stones-star","text":"","title":"771. Jewels and Stones $\\star$"},{"location":"cpp/0701-0800/0771-0780/#772-basic-calculator-iii-starstarstar","text":"","title":"772. Basic Calculator III $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#773-sliding-puzzle-starstarstar","text":"","title":"773. Sliding Puzzle $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#774-minimize-max-distance-to-gas-station-starstarstar","text":"","title":"774. Minimize Max Distance to Gas Station $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#775-global-and-local-inversions-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution { public : bool isIdealPermutation ( vector < int >& A ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( abs ( A [ i ] - i ) > 1 ) return false ; return true ; } };","title":"775. Global and Local Inversions $\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#776-split-bst-starstar","text":"","title":"776. Split BST $\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#777-swap-adjacent-in-lr-string-starstar","text":"","title":"777. Swap Adjacent in LR String $\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#778-swim-in-rising-water-starstarstar","text":"","title":"778. Swim in Rising Water $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#779-k-th-symbol-in-grammar-starstar","text":"","title":"779. K-th Symbol in Grammar $\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#780-reaching-points-starstarstar","text":"","title":"780. Reaching Points $\\star\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/","text":"781. Rabbits in Forest $\\star\\star$ 782. Transform to Chessboard $\\star\\star\\star$ 783. Minimum Distance Between BST Nodes $\\star$ 784. Letter Case Permutation $\\star$ 785. Is Graph Bipartite? $\\star\\star$ 786. K-th Smallest Prime Fraction $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < int > kthSmallestPrimeFraction ( vector < int >& A , int K ) { const int n = A . size (); vector < int > ans = { 0 , 1 }; double l = 0 ; double r = 1 ; while ( true ) { double m = ( l + r ) / 2 ; ans [ 0 ] = 0 ; int count = 0 ; int j = 1 ; for ( int i = 0 ; i < n ; ++ i ) { while ( j < n && A [ i ] > m * A [ j ]) ++ j ; count += n - j ; if ( j == n ) break ; if ( ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ]) { ans [ 0 ] = A [ i ]; ans [ 1 ] = A [ j ]; } } if ( count < K ) l = m ; else if ( count > K ) r = m ; else return ans ; } } }; 787. Cheapest Flights Within K Stops $\\star\\star$ 788. Rotated Digits $\\star$ 789. Escape The Ghosts $\\star\\star$ 790. Domino and Tromino Tiling $\\star\\star$","title":"0781-0790"},{"location":"cpp/0701-0800/0781-0790/#781-rabbits-in-forest-starstar","text":"","title":"781. Rabbits in Forest $\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#782-transform-to-chessboard-starstarstar","text":"","title":"782. Transform to Chessboard $\\star\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#783-minimum-distance-between-bst-nodes-star","text":"","title":"783. Minimum Distance Between BST Nodes $\\star$"},{"location":"cpp/0701-0800/0781-0790/#784-letter-case-permutation-star","text":"","title":"784. Letter Case Permutation $\\star$"},{"location":"cpp/0701-0800/0781-0790/#785-is-graph-bipartite-starstar","text":"","title":"785. Is Graph Bipartite? $\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#786-k-th-smallest-prime-fraction-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < int > kthSmallestPrimeFraction ( vector < int >& A , int K ) { const int n = A . size (); vector < int > ans = { 0 , 1 }; double l = 0 ; double r = 1 ; while ( true ) { double m = ( l + r ) / 2 ; ans [ 0 ] = 0 ; int count = 0 ; int j = 1 ; for ( int i = 0 ; i < n ; ++ i ) { while ( j < n && A [ i ] > m * A [ j ]) ++ j ; count += n - j ; if ( j == n ) break ; if ( ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ]) { ans [ 0 ] = A [ i ]; ans [ 1 ] = A [ j ]; } } if ( count < K ) l = m ; else if ( count > K ) r = m ; else return ans ; } } };","title":"786. K-th Smallest Prime Fraction $\\star\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#787-cheapest-flights-within-k-stops-starstar","text":"","title":"787. Cheapest Flights Within K Stops $\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#788-rotated-digits-star","text":"","title":"788. Rotated Digits $\\star$"},{"location":"cpp/0701-0800/0781-0790/#789-escape-the-ghosts-starstar","text":"","title":"789. Escape The Ghosts $\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#790-domino-and-tromino-tiling-starstar","text":"","title":"790. Domino and Tromino Tiling $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/","text":"791. Custom Sort String $\\star\\star$ 792. Number of Matching Subsequences $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : int numMatchingSubseq ( string S , vector < string >& words ) { for ( const string & word : words ) insert ( word ); return dfs ( S , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), count ( 0 ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; int count ; }; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } ++ node -> count ; } int dfs ( const string & S , int s , TrieNode * node ) { int ans = node -> count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ]) { int index = indexOf ( S , i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node -> children [ i ]); } return ans ; } int indexOf ( const string & S , char c , int s ) { for ( int i = s ; i < S . length (); ++ i ) if ( S [ i ] == c ) return i ; return - 1 ; } TrieNode root ; }; 793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$ 794. Valid Tic-Tac-Toe State $\\star\\star$ 795. Number of Subarrays with Bounded Maximum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numSubarrayBoundedMax ( vector < int >& A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } }; 796. Rotate String $\\star$ 797. All Paths From Source to Target $\\star\\star$ 798. Smallest Rotation with Highest Score $\\star\\star\\star$ 799. Champagne Tower $\\star\\star$ 800. Similar RGB Color $\\star$","title":"0791-0800"},{"location":"cpp/0701-0800/0791-0800/#791-custom-sort-string-starstar","text":"","title":"791. Custom Sort String $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#792-number-of-matching-subsequences-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : int numMatchingSubseq ( string S , vector < string >& words ) { for ( const string & word : words ) insert ( word ); return dfs ( S , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), count ( 0 ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; int count ; }; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } ++ node -> count ; } int dfs ( const string & S , int s , TrieNode * node ) { int ans = node -> count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ]) { int index = indexOf ( S , i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node -> children [ i ]); } return ans ; } int indexOf ( const string & S , char c , int s ) { for ( int i = s ; i < S . length (); ++ i ) if ( S [ i ] == c ) return i ; return - 1 ; } TrieNode root ; };","title":"792. Number of Matching Subsequences $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#793-preimage-size-of-factorial-zeroes-function-starstarstar","text":"","title":"793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#794-valid-tic-tac-toe-state-starstar","text":"","title":"794. Valid Tic-Tac-Toe State $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#795-number-of-subarrays-with-bounded-maximum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numSubarrayBoundedMax ( vector < int >& A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } };","title":"795. Number of Subarrays with Bounded Maximum $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#796-rotate-string-star","text":"","title":"796. Rotate String $\\star$"},{"location":"cpp/0701-0800/0791-0800/#797-all-paths-from-source-to-target-starstar","text":"","title":"797. All Paths From Source to Target $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#798-smallest-rotation-with-highest-score-starstarstar","text":"","title":"798. Smallest Rotation with Highest Score $\\star\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#799-champagne-tower-starstar","text":"","title":"799. Champagne Tower $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#800-similar-rgb-color-star","text":"","title":"800. Similar RGB Color $\\star$"},{"location":"cpp/0801-0900/0801-0810/","text":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$ 802. Find Eventual Safe States $\\star\\star$ 803. Bricks Falling When Hit $\\star\\star\\star$ 804. Unique Morse Code Words $\\star$ 805. Split Array With Same Average $\\star\\star\\star$ 806. Number of Lines To Write String $\\star$ 807. Max Increase to Keep City Skyline $\\star\\star$ 808. Soup Servings $\\star\\star$ 809. Expressive Words $\\star\\star$ 810. Chalkboard XOR Game $\\star\\star\\star$","title":"0801-0810"},{"location":"cpp/0801-0900/0801-0810/#801-minimum-swaps-to-make-sequences-increasing-starstar","text":"","title":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#802-find-eventual-safe-states-starstar","text":"","title":"802. Find Eventual Safe States $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#803-bricks-falling-when-hit-starstarstar","text":"","title":"803. Bricks Falling When Hit $\\star\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#804-unique-morse-code-words-star","text":"","title":"804. Unique Morse Code Words $\\star$"},{"location":"cpp/0801-0900/0801-0810/#805-split-array-with-same-average-starstarstar","text":"","title":"805. Split Array With Same Average $\\star\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#806-number-of-lines-to-write-string-star","text":"","title":"806. Number of Lines To Write String $\\star$"},{"location":"cpp/0801-0900/0801-0810/#807-max-increase-to-keep-city-skyline-starstar","text":"","title":"807. Max Increase to Keep City Skyline $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#808-soup-servings-starstar","text":"","title":"808. Soup Servings $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#809-expressive-words-starstar","text":"","title":"809. Expressive Words $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#810-chalkboard-xor-game-starstarstar","text":"","title":"810. Chalkboard XOR Game $\\star\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/","text":"811. Subdomain Visit Count $\\star$ 812. Largest Triangle Area $\\star$ 813. Largest Sum of Averages $\\star\\star$ 814. Binary Tree Pruning $\\star\\star$ 815. Bus Routes $\\star\\star\\star$ 816. Ambiguous Coordinates $\\star\\star$ 817. Linked List Components $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numComponents ( ListNode * head , vector < int >& G ) { int ans = 0 ; unordered_set < int > g ( G . begin (), G . end ()); while ( head ) { if ( g . count ( head -> val ) && ( ! head -> next || ! g . count ( head -> next -> val ))) ++ ans ; head = head -> next ; } return ans ; } }; 818. Race Car $\\star\\star\\star$ 819. Most Common Word $\\star$ 820. Short Encoding of Words $\\star\\star$","title":"0811-0820"},{"location":"cpp/0801-0900/0811-0820/#811-subdomain-visit-count-star","text":"","title":"811. Subdomain Visit Count $\\star$"},{"location":"cpp/0801-0900/0811-0820/#812-largest-triangle-area-star","text":"","title":"812. Largest Triangle Area $\\star$"},{"location":"cpp/0801-0900/0811-0820/#813-largest-sum-of-averages-starstar","text":"","title":"813. Largest Sum of Averages $\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#814-binary-tree-pruning-starstar","text":"","title":"814. Binary Tree Pruning $\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#815-bus-routes-starstarstar","text":"","title":"815. Bus Routes $\\star\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#816-ambiguous-coordinates-starstar","text":"","title":"816. Ambiguous Coordinates $\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#817-linked-list-components-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numComponents ( ListNode * head , vector < int >& G ) { int ans = 0 ; unordered_set < int > g ( G . begin (), G . end ()); while ( head ) { if ( g . count ( head -> val ) && ( ! head -> next || ! g . count ( head -> next -> val ))) ++ ans ; head = head -> next ; } return ans ; } };","title":"817. Linked List Components $\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#818-race-car-starstarstar","text":"","title":"818. Race Car $\\star\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#819-most-common-word-star","text":"","title":"819. Most Common Word $\\star$"},{"location":"cpp/0801-0900/0811-0820/#820-short-encoding-of-words-starstar","text":"","title":"820. Short Encoding of Words $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/","text":"821. Shortest Distance to a Character $\\star$ 822. Card Flipping Game $\\star\\star$ 823. Binary Trees With Factors $\\star\\star$ 824. Goat Latin $\\star$ 825. Friends Of Appropriate Ages $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numFriendRequests ( vector < int >& ages ) { int ans = 0 ; vector < int > count ( 121 ); for ( int age : ages ) ++ count [ age ]; for ( int i = 15 ; i <= 120 ; ++ i ) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; ++ i ) for ( int j = i / 2 + 8 ; j < i ; ++ j ) ans += count [ i ] * count [ j ]; return ans ; } }; 826. Most Profit Assigning Work $\\star\\star$ 827. Making A Large Island $\\star\\star\\star$ 828. Unique Letter String $\\star\\star\\star$ 829. Consecutive Numbers Sum $\\star\\star\\star$ 830. Positions of Large Groups $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> largeGroupPositions ( string S ) { const int n = S . length (); vector < vector < int >> ans ; for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S [ j ] == S [ i ]) ++ j ; if ( j - i >= 3 ) ans . push_back ({ i , j - 1 }); } return ans ; } };","title":"0821-0830"},{"location":"cpp/0801-0900/0821-0830/#821-shortest-distance-to-a-character-star","text":"","title":"821. Shortest Distance to a Character $\\star$"},{"location":"cpp/0801-0900/0821-0830/#822-card-flipping-game-starstar","text":"","title":"822. Card Flipping Game $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#823-binary-trees-with-factors-starstar","text":"","title":"823. Binary Trees With Factors $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#824-goat-latin-star","text":"","title":"824. Goat Latin $\\star$"},{"location":"cpp/0801-0900/0821-0830/#825-friends-of-appropriate-ages-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numFriendRequests ( vector < int >& ages ) { int ans = 0 ; vector < int > count ( 121 ); for ( int age : ages ) ++ count [ age ]; for ( int i = 15 ; i <= 120 ; ++ i ) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; ++ i ) for ( int j = i / 2 + 8 ; j < i ; ++ j ) ans += count [ i ] * count [ j ]; return ans ; } };","title":"825. Friends Of Appropriate Ages $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#826-most-profit-assigning-work-starstar","text":"","title":"826. Most Profit Assigning Work $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#827-making-a-large-island-starstarstar","text":"","title":"827. Making A Large Island $\\star\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#828-unique-letter-string-starstarstar","text":"","title":"828. Unique Letter String $\\star\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#829-consecutive-numbers-sum-starstarstar","text":"","title":"829. Consecutive Numbers Sum $\\star\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#830-positions-of-large-groups-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> largeGroupPositions ( string S ) { const int n = S . length (); vector < vector < int >> ans ; for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S [ j ] == S [ i ]) ++ j ; if ( j - i >= 3 ) ans . push_back ({ i , j - 1 }); } return ans ; } };","title":"830. Positions of Large Groups $\\star$"},{"location":"cpp/0801-0900/0831-0840/","text":"831. Masking Personal Information $\\star\\star$ 832. Flipping an Image $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { int temp = A [ i ][ j ]; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } }; 833. Find And Replace in String $\\star\\star$ 834. Sum of Distances in Tree $\\star\\star\\star$ 835. Image Overlap $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int largestOverlap ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int n = A . size (); const int magic = 100 ; int ans = 0 ; vector < pair < int , int >> onesA ; vector < pair < int , int >> onesB ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ][ j ] == 1 ) onesA . push_back ({ i , j }); if ( B [ i ][ j ] == 1 ) onesB . push_back ({ i , j }); } for ( pair < int , int >& a : onesA ) for ( pair < int , int >& b : onesB ) ++ map [( a . first - b . first ) * magic + ( a . second - b . second )]; for ( auto & [ _ , value ] : map ) ans = max ( ans , value ); return ans ; } }; 836. Rectangle Overlap $\\star$ 837. New 21 Game $\\star\\star$ 838. Push Dominoes $\\star\\star$ 839. Similar String Groups $\\star\\star\\star$ 840. Magic Squares In Grid $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numMagicSquaresInside ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . size (); ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private : int isMagic ( vector < vector < int >>& grid , int i , int j ) { string s ; for ( int num : { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += to_string ( grid [ i + num / 3 ][ j + num % 3 ]); return string ( \"4381672943816729\" ). find ( s ) != string :: npos || string ( \"9276183492761834\" ). find ( s ) != string :: npos ; } };","title":"0831-0840"},{"location":"cpp/0801-0900/0831-0840/#831-masking-personal-information-starstar","text":"","title":"831. Masking Personal Information $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#832-flipping-an-image-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { int temp = A [ i ][ j ]; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } };","title":"832. Flipping an Image $\\star$"},{"location":"cpp/0801-0900/0831-0840/#833-find-and-replace-in-string-starstar","text":"","title":"833. Find And Replace in String $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#834-sum-of-distances-in-tree-starstarstar","text":"","title":"834. Sum of Distances in Tree $\\star\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#835-image-overlap-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int largestOverlap ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int n = A . size (); const int magic = 100 ; int ans = 0 ; vector < pair < int , int >> onesA ; vector < pair < int , int >> onesB ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ][ j ] == 1 ) onesA . push_back ({ i , j }); if ( B [ i ][ j ] == 1 ) onesB . push_back ({ i , j }); } for ( pair < int , int >& a : onesA ) for ( pair < int , int >& b : onesB ) ++ map [( a . first - b . first ) * magic + ( a . second - b . second )]; for ( auto & [ _ , value ] : map ) ans = max ( ans , value ); return ans ; } };","title":"835. Image Overlap $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#836-rectangle-overlap-star","text":"","title":"836. Rectangle Overlap $\\star$"},{"location":"cpp/0801-0900/0831-0840/#837-new-21-game-starstar","text":"","title":"837. New 21 Game $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#838-push-dominoes-starstar","text":"","title":"838. Push Dominoes $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#839-similar-string-groups-starstarstar","text":"","title":"839. Similar String Groups $\\star\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#840-magic-squares-in-grid-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numMagicSquaresInside ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . size (); ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private : int isMagic ( vector < vector < int >>& grid , int i , int j ) { string s ; for ( int num : { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += to_string ( grid [ i + num / 3 ][ j + num % 3 ]); return string ( \"4381672943816729\" ). find ( s ) != string :: npos || string ( \"9276183492761834\" ). find ( s ) != string :: npos ; } };","title":"840. Magic Squares In Grid $\\star$"},{"location":"cpp/0801-0900/0841-0850/","text":"841. Keys and Rooms $\\star\\star$ 842. Split Array into Fibonacci Sequence $\\star\\star$ 843. Guess the Word $\\star\\star\\star$ 844. Backspace String Compare $\\star$ 845. Longest Mountain in Array $\\star\\star$ 846. Hand of Straights $\\star\\star$ 847. Shortest Path Visiting All Nodes $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int shortestPathLength ( vector < vector < int >>& graph ) { const int n = graph . size (); const int goal = ( 1 << n ) - 1 ; int ans = 0 ; queue < pair < int , int >> q ; vector < vector < int >> visited ( n , vector < int > ( 1 << n )); for ( int i = 0 ; i < graph . size (); ++ i ) q . push ({ i , 1 << i }); while ( ! q . empty ()) { int s = q . size (); while ( s -- ) { auto p = q . front (); q . pop (); int node = p . first ; int state = p . second ; if ( state == goal ) return ans ; if ( visited [ node ][ state ]) continue ; visited [ node ][ state ] = 1 ; for ( int next : graph [ node ]) q . push ({ next , state | ( 1 << next )}); } ++ ans ; } return - 1 ; } }; 848. Shifting Letters $\\star\\star$ 849. Maximize Distance to Closest Person $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxDistToClosest ( vector < int >& seats ) { const int n = seats . size (); int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : max ( ans , ( i - j ) / 2 ); j = i ; } return max ( ans , n - j - 1 ); } }; 850. Rectangle Area II $\\star\\star\\star$","title":"0841-0850"},{"location":"cpp/0801-0900/0841-0850/#841-keys-and-rooms-starstar","text":"","title":"841. Keys and Rooms $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#842-split-array-into-fibonacci-sequence-starstar","text":"","title":"842. Split Array into Fibonacci Sequence $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#843-guess-the-word-starstarstar","text":"","title":"843. Guess the Word $\\star\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#844-backspace-string-compare-star","text":"","title":"844. Backspace String Compare $\\star$"},{"location":"cpp/0801-0900/0841-0850/#845-longest-mountain-in-array-starstar","text":"","title":"845. Longest Mountain in Array $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#846-hand-of-straights-starstar","text":"","title":"846. Hand of Straights $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#847-shortest-path-visiting-all-nodes-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int shortestPathLength ( vector < vector < int >>& graph ) { const int n = graph . size (); const int goal = ( 1 << n ) - 1 ; int ans = 0 ; queue < pair < int , int >> q ; vector < vector < int >> visited ( n , vector < int > ( 1 << n )); for ( int i = 0 ; i < graph . size (); ++ i ) q . push ({ i , 1 << i }); while ( ! q . empty ()) { int s = q . size (); while ( s -- ) { auto p = q . front (); q . pop (); int node = p . first ; int state = p . second ; if ( state == goal ) return ans ; if ( visited [ node ][ state ]) continue ; visited [ node ][ state ] = 1 ; for ( int next : graph [ node ]) q . push ({ next , state | ( 1 << next )}); } ++ ans ; } return - 1 ; } };","title":"847. Shortest Path Visiting All Nodes $\\star\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#848-shifting-letters-starstar","text":"","title":"848. Shifting Letters $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#849-maximize-distance-to-closest-person-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxDistToClosest ( vector < int >& seats ) { const int n = seats . size (); int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : max ( ans , ( i - j ) / 2 ); j = i ; } return max ( ans , n - j - 1 ); } };","title":"849. Maximize Distance to Closest Person $\\star$"},{"location":"cpp/0801-0900/0841-0850/#850-rectangle-area-ii-starstarstar","text":"","title":"850. Rectangle Area II $\\star\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/","text":"851. Loud and Rich $\\star\\star$ 852. Peak Index in a Mountain Array $\\star$ 853. Car Fleet $\\star\\star$ 854. K-Similar Strings $\\star\\star\\star$ 855. Exam Room $\\star\\star$ 856. Score of Parentheses $\\star\\star$ 857. Minimum Cost to Hire K Workers $\\star\\star\\star$ 858. Mirror Reflection $\\star\\star$ 859. Buddy Strings $\\star$ 860. Lemonade Change $\\star$","title":"0851-0860"},{"location":"cpp/0801-0900/0851-0860/#851-loud-and-rich-starstar","text":"","title":"851. Loud and Rich $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#852-peak-index-in-a-mountain-array-star","text":"","title":"852. Peak Index in a Mountain Array $\\star$"},{"location":"cpp/0801-0900/0851-0860/#853-car-fleet-starstar","text":"","title":"853. Car Fleet $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#854-k-similar-strings-starstarstar","text":"","title":"854. K-Similar Strings $\\star\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#855-exam-room-starstar","text":"","title":"855. Exam Room $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#856-score-of-parentheses-starstar","text":"","title":"856. Score of Parentheses $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#857-minimum-cost-to-hire-k-workers-starstarstar","text":"","title":"857. Minimum Cost to Hire K Workers $\\star\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#858-mirror-reflection-starstar","text":"","title":"858. Mirror Reflection $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#859-buddy-strings-star","text":"","title":"859. Buddy Strings $\\star$"},{"location":"cpp/0801-0900/0851-0860/#860-lemonade-change-star","text":"","title":"860. Lemonade Change $\\star$"},{"location":"cpp/0801-0900/0861-0870/","text":"861. Score After Flipping Matrix $\\star\\star$ 862. Shortest Subarray with Sum at Least K $\\star\\star\\star$ 863. All Nodes Distance K in Binary Tree $\\star\\star$ 864. Shortest Path to Get All Keys $\\star\\star\\star$ 865. Smallest Subtree with all the Deepest Nodes $\\star\\star$ 866. Prime Palindrome $\\star\\star$ 867. Transpose Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < vector < int >> transpose ( vector < vector < int >>& A ) { vector < vector < int >> ans ( A [ 0 ]. size (), vector < int > ( A . size ())); for ( int i = 0 ; i < A . size (); ++ i ) for ( int j = 0 ; j < A [ 0 ]. size (); ++ j ) ans [ j ][ i ] = A [ i ][ j ]; return ans ; } }; 868. Binary Gap $\\star$ 869. Reordered Power of 2 $\\star\\star$ 870. Advantage Shuffle $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > advantageCount ( vector < int >& A , vector < int >& B ) { multiset < int > set ( A . begin (), A . end ()); for ( int i = 0 ; i < B . size (); ++ i ) { auto p = * set . rbegin () <= B [ i ] ? set . begin () : set . upper_bound ( B [ i ]); A [ i ] = * p ; set . erase ( p ); } return A ; } };","title":"0861-0870"},{"location":"cpp/0801-0900/0861-0870/#861-score-after-flipping-matrix-starstar","text":"","title":"861. Score After Flipping Matrix $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#862-shortest-subarray-with-sum-at-least-k-starstarstar","text":"","title":"862. Shortest Subarray with Sum at Least K $\\star\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#863-all-nodes-distance-k-in-binary-tree-starstar","text":"","title":"863. All Nodes Distance K in Binary Tree $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#864-shortest-path-to-get-all-keys-starstarstar","text":"","title":"864. Shortest Path to Get All Keys $\\star\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#865-smallest-subtree-with-all-the-deepest-nodes-starstar","text":"","title":"865. Smallest Subtree with all the Deepest Nodes $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#866-prime-palindrome-starstar","text":"","title":"866. Prime Palindrome $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#867-transpose-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < vector < int >> transpose ( vector < vector < int >>& A ) { vector < vector < int >> ans ( A [ 0 ]. size (), vector < int > ( A . size ())); for ( int i = 0 ; i < A . size (); ++ i ) for ( int j = 0 ; j < A [ 0 ]. size (); ++ j ) ans [ j ][ i ] = A [ i ][ j ]; return ans ; } };","title":"867. Transpose Matrix $\\star$"},{"location":"cpp/0801-0900/0861-0870/#868-binary-gap-star","text":"","title":"868. Binary Gap $\\star$"},{"location":"cpp/0801-0900/0861-0870/#869-reordered-power-of-2-starstar","text":"","title":"869. Reordered Power of 2 $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#870-advantage-shuffle-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > advantageCount ( vector < int >& A , vector < int >& B ) { multiset < int > set ( A . begin (), A . end ()); for ( int i = 0 ; i < B . size (); ++ i ) { auto p = * set . rbegin () <= B [ i ] ? set . begin () : set . upper_bound ( B [ i ]); A [ i ] = * p ; set . erase ( p ); } return A ; } };","title":"870. Advantage Shuffle $\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/","text":"871. Minimum Number of Refueling Stops $\\star\\star\\star$ 872. Leaf-Similar Trees $\\star$ 873. Length of Longest Fibonacci Subsequence $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) map [ A [ i ]] = i ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && map . count ( ai )) { int i = map [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; 874. Walking Robot Simulation $\\star$ 875. Koko Eating Bananas $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int minEatingSpeed ( vector < int >& piles , int H ) { int l = 1 ; int r = * max_element ( piles . begin (), piles . end ()) + 1 ; while ( l < r ) { int m = ( l + r ) >> 1 ; int hour = 0 ; for ( int pile : piles ) hour += ( pile - 1 ) / m + 1 ; if ( hour <= H ) r = m ; else l = m + 1 ; } return l ; } }; 876. Middle of the Linked List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * middleNode ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; auto slow = head ; auto fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; 877. Stone Game $\\star\\star$ 878. Nth Magical Number $\\star\\star\\star$ 879. Profitable Schemes $\\star\\star\\star$ 880. Decoded String at Index $\\star\\star$","title":"0871-0880"},{"location":"cpp/0801-0900/0871-0880/#871-minimum-number-of-refueling-stops-starstarstar","text":"","title":"871. Minimum Number of Refueling Stops $\\star\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#872-leaf-similar-trees-star","text":"","title":"872. Leaf-Similar Trees $\\star$"},{"location":"cpp/0801-0900/0871-0880/#873-length-of-longest-fibonacci-subsequence-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) map [ A [ i ]] = i ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && map . count ( ai )) { int i = map [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } };","title":"873. Length of Longest Fibonacci Subsequence $\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#874-walking-robot-simulation-star","text":"","title":"874. Walking Robot Simulation $\\star$"},{"location":"cpp/0801-0900/0871-0880/#875-koko-eating-bananas-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int minEatingSpeed ( vector < int >& piles , int H ) { int l = 1 ; int r = * max_element ( piles . begin (), piles . end ()) + 1 ; while ( l < r ) { int m = ( l + r ) >> 1 ; int hour = 0 ; for ( int pile : piles ) hour += ( pile - 1 ) / m + 1 ; if ( hour <= H ) r = m ; else l = m + 1 ; } return l ; } };","title":"875. Koko Eating Bananas $\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#876-middle-of-the-linked-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * middleNode ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; auto slow = head ; auto fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } };","title":"876. Middle of the Linked List $\\star$"},{"location":"cpp/0801-0900/0871-0880/#877-stone-game-starstar","text":"","title":"877. Stone Game $\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#878-nth-magical-number-starstarstar","text":"","title":"878. Nth Magical Number $\\star\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#879-profitable-schemes-starstarstar","text":"","title":"879. Profitable Schemes $\\star\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#880-decoded-string-at-index-starstar","text":"","title":"880. Decoded String at Index $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/","text":"881. Boats to Save People $\\star\\star$ 882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$ 883. Projection Area of 3D Shapes $\\star$ 884. Uncommon Words from Two Sentences $\\star$ 885. Spiral Matrix III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> spiralMatrixIII ( int R , int C , int r0 , int c0 ) { vector < vector < int >> ans = {{ r0 , c0 }}; int x = 0 ; int y = 1 ; for ( int i = 0 ; ans . size () < R * C ; ++ i ) { for ( int j = 0 ; j < i / 2 + 1 ; ++ j ) { r0 += x ; c0 += y ; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . push_back ({ r0 , c0 }); } swap ( x , y ); y *= - 1 ; } return ans ; } }; 886. Possible Bipartition $\\star\\star$ 887. Super Egg Drop $\\star\\star\\star$ 888. Fair Candy Swap $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > fairCandySwap ( vector < int >& A , vector < int >& B ) { int diff = ( accumulate ( A . begin (), A . end (), 0 ) - accumulate ( B . begin (), B . end (), 0 )) / 2 ; unordered_set < int > set ( B . begin (), B . end ()); for ( int a : A ) if ( set . count ( a - diff )) return { a , a - diff }; throw ; } }; 889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : TreeNode * constructFromPrePost ( vector < int >& pre , vector < int >& post ) { return helper ( 0 , 0 , pre . size (), pre , post ); } private : TreeNode * helper ( int i , int j , int n , vector < int >& pre , vector < int >& post ) { if ( n == 0 ) return NULL ; TreeNode * root = new TreeNode ( pre [ i ]); if ( n == 1 ) return root ; int k = j ; while ( post [ k ] != pre [ i + 1 ]) ++ k ; int l = k - j + 1 ; root -> left = helper ( i + 1 , j , l , pre , post ); root -> right = helper ( i + l + 1 , j + l , n - l - 1 , pre , post ); return root ; } }; 890. Find and Replace Pattern $\\star\\star$","title":"0881-0890"},{"location":"cpp/0801-0900/0881-0890/#881-boats-to-save-people-starstar","text":"","title":"881. Boats to Save People $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#882-reachable-nodes-in-subdivided-graph-starstarstar","text":"","title":"882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#883-projection-area-of-3d-shapes-star","text":"","title":"883. Projection Area of 3D Shapes $\\star$"},{"location":"cpp/0801-0900/0881-0890/#884-uncommon-words-from-two-sentences-star","text":"","title":"884. Uncommon Words from Two Sentences $\\star$"},{"location":"cpp/0801-0900/0881-0890/#885-spiral-matrix-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> spiralMatrixIII ( int R , int C , int r0 , int c0 ) { vector < vector < int >> ans = {{ r0 , c0 }}; int x = 0 ; int y = 1 ; for ( int i = 0 ; ans . size () < R * C ; ++ i ) { for ( int j = 0 ; j < i / 2 + 1 ; ++ j ) { r0 += x ; c0 += y ; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . push_back ({ r0 , c0 }); } swap ( x , y ); y *= - 1 ; } return ans ; } };","title":"885. Spiral Matrix III $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#886-possible-bipartition-starstar","text":"","title":"886. Possible Bipartition $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#887-super-egg-drop-starstarstar","text":"","title":"887. Super Egg Drop $\\star\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#888-fair-candy-swap-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > fairCandySwap ( vector < int >& A , vector < int >& B ) { int diff = ( accumulate ( A . begin (), A . end (), 0 ) - accumulate ( B . begin (), B . end (), 0 )) / 2 ; unordered_set < int > set ( B . begin (), B . end ()); for ( int a : A ) if ( set . count ( a - diff )) return { a , a - diff }; throw ; } };","title":"888. Fair Candy Swap $\\star$"},{"location":"cpp/0801-0900/0881-0890/#889-construct-binary-tree-from-preorder-and-postorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : TreeNode * constructFromPrePost ( vector < int >& pre , vector < int >& post ) { return helper ( 0 , 0 , pre . size (), pre , post ); } private : TreeNode * helper ( int i , int j , int n , vector < int >& pre , vector < int >& post ) { if ( n == 0 ) return NULL ; TreeNode * root = new TreeNode ( pre [ i ]); if ( n == 1 ) return root ; int k = j ; while ( post [ k ] != pre [ i + 1 ]) ++ k ; int l = k - j + 1 ; root -> left = helper ( i + 1 , j , l , pre , post ); root -> right = helper ( i + l + 1 , j + l , n - l - 1 , pre , post ); return root ; } };","title":"889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#890-find-and-replace-pattern-starstar","text":"","title":"890. Find and Replace Pattern $\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/","text":"891. Sum of Subsequence Widths $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int sumSubseqWidths ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; long exp = 1 ; sort ( A . begin (), A . end ()); for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ans ; } }; 892. Surface Area of 3D Shapes $\\star$ 893. Groups of Special-Equivalent Strings $\\star$ 894. All Possible Full Binary Trees $\\star\\star$ 895. Maximum Frequency Stack $\\star\\star\\star$ 896. Monotonic Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isMonotonic ( vector < int >& A ) { bool increasing = true ; bool decreasing = true ; for ( int i = 1 ; i < A . size (); ++ i ) { increasing &= A [ i - 1 ] <= A [ i ]; decreasing &= A [ i - 1 ] >= A [ i ]; } return increasing || decreasing ; } }; 897. Increasing Order Search Tree $\\star$ 898. Bitwise ORs of Subarrays $\\star\\star$ 899. Orderly Queue $\\star\\star\\star$ 900. RLE Iterator $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class RLEIterator { public : RLEIterator ( vector < int >& A ) { this -> A = A ; } int next ( int n ) { while ( index < A . size () && A [ index ] < n ) { n -= A [ index ]; index += 2 ; } if ( index == A . size ()) return - 1 ; A [ index ] -= n ; return A [ index + 1 ]; } private : int index = 0 ; vector < int > A ; };","title":"0891-0900"},{"location":"cpp/0801-0900/0891-0900/#891-sum-of-subsequence-widths-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int sumSubseqWidths ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; long exp = 1 ; sort ( A . begin (), A . end ()); for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ans ; } };","title":"891. Sum of Subsequence Widths $\\star\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#892-surface-area-of-3d-shapes-star","text":"","title":"892. Surface Area of 3D Shapes $\\star$"},{"location":"cpp/0801-0900/0891-0900/#893-groups-of-special-equivalent-strings-star","text":"","title":"893. Groups of Special-Equivalent Strings $\\star$"},{"location":"cpp/0801-0900/0891-0900/#894-all-possible-full-binary-trees-starstar","text":"","title":"894. All Possible Full Binary Trees $\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#895-maximum-frequency-stack-starstarstar","text":"","title":"895. Maximum Frequency Stack $\\star\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#896-monotonic-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isMonotonic ( vector < int >& A ) { bool increasing = true ; bool decreasing = true ; for ( int i = 1 ; i < A . size (); ++ i ) { increasing &= A [ i - 1 ] <= A [ i ]; decreasing &= A [ i - 1 ] >= A [ i ]; } return increasing || decreasing ; } };","title":"896. Monotonic Array $\\star$"},{"location":"cpp/0801-0900/0891-0900/#897-increasing-order-search-tree-star","text":"","title":"897. Increasing Order Search Tree $\\star$"},{"location":"cpp/0801-0900/0891-0900/#898-bitwise-ors-of-subarrays-starstar","text":"","title":"898. Bitwise ORs of Subarrays $\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#899-orderly-queue-starstarstar","text":"","title":"899. Orderly Queue $\\star\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#900-rle-iterator-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class RLEIterator { public : RLEIterator ( vector < int >& A ) { this -> A = A ; } int next ( int n ) { while ( index < A . size () && A [ index ] < n ) { n -= A [ index ]; index += 2 ; } if ( index == A . size ()) return - 1 ; A [ index ] -= n ; return A [ index + 1 ]; } private : int index = 0 ; vector < int > A ; };","title":"900. RLE Iterator $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/","text":"901. Online Stock Span $\\star\\star$ 902. Numbers At Most N Given Digit Set $\\star\\star\\star$ 903. Valid Permutations for DI Sequence $\\star\\star\\star$ 904. Fruit Into Baskets $\\star\\star$ 905. Sort Array By Parity $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > sortArrayByParity ( vector < int >& A ) { int l = 0 ; int r = A . size () - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) swap ( A [ l ], A [ r ]); if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } }; 906. Super Palindromes $\\star\\star\\star$ 907. Sum of Subarray Minimums $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int sumSubarrayMins ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; vector < int > prev ( n , - 1 ); vector < int > next ( n , n ); stack < int > stack1 ; stack < int > stack2 ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! stack1 . empty () && A [ stack1 . top ()] > A [ i ]) stack1 . pop (); prev [ i ] = stack1 . empty () ? - 1 : stack1 . top (); stack1 . push ( i ); while ( ! stack2 . empty () && A [ stack2 . top ()] > A [ i ]) { int index = stack2 . top (); stack2 . pop (); next [ index ] = i ; } stack2 . push ( i ); } for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + A [ i ] * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod ; return ans ; } }; 908. Smallest Range I $\\star$ 909. Snakes and Ladders $\\star\\star$ 910. Smallest Range II $\\star\\star$","title":"0901-0910"},{"location":"cpp/0901-1000/0901-0910/#901-online-stock-span-starstar","text":"","title":"901. Online Stock Span $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#902-numbers-at-most-n-given-digit-set-starstarstar","text":"","title":"902. Numbers At Most N Given Digit Set $\\star\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#903-valid-permutations-for-di-sequence-starstarstar","text":"","title":"903. Valid Permutations for DI Sequence $\\star\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#904-fruit-into-baskets-starstar","text":"","title":"904. Fruit Into Baskets $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#905-sort-array-by-parity-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > sortArrayByParity ( vector < int >& A ) { int l = 0 ; int r = A . size () - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) swap ( A [ l ], A [ r ]); if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } };","title":"905. Sort Array By Parity $\\star$"},{"location":"cpp/0901-1000/0901-0910/#906-super-palindromes-starstarstar","text":"","title":"906. Super Palindromes $\\star\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#907-sum-of-subarray-minimums-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int sumSubarrayMins ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; vector < int > prev ( n , - 1 ); vector < int > next ( n , n ); stack < int > stack1 ; stack < int > stack2 ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! stack1 . empty () && A [ stack1 . top ()] > A [ i ]) stack1 . pop (); prev [ i ] = stack1 . empty () ? - 1 : stack1 . top (); stack1 . push ( i ); while ( ! stack2 . empty () && A [ stack2 . top ()] > A [ i ]) { int index = stack2 . top (); stack2 . pop (); next [ index ] = i ; } stack2 . push ( i ); } for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + A [ i ] * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod ; return ans ; } };","title":"907. Sum of Subarray Minimums $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#908-smallest-range-i-star","text":"","title":"908. Smallest Range I $\\star$"},{"location":"cpp/0901-1000/0901-0910/#909-snakes-and-ladders-starstar","text":"","title":"909. Snakes and Ladders $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#910-smallest-range-ii-starstar","text":"","title":"910. Smallest Range II $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/","text":"911. Online Election $\\star\\star$ 912. Sort an Array $\\star\\star$ 913. Cat and Mouse $\\star\\star\\star$ 914. X of a Kind in a Deck of Cards $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool hasGroupsSizeX ( vector < int >& deck ) { unordered_map < int , int > numCounts ; for ( int d : deck ) ++ numCounts [ d ]; int gcd = 0 ; for ( auto & [ _ , value ] : numCounts ) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } }; 915. Partition Array into Disjoint Intervals $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int partitionDisjoint ( vector < int >& A ) { const int n = A . size (); vector < int > min ( n ); min [ n - 1 ] = A [ n - 1 ]; int max = INT_MIN ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], A [ i ]); for ( int i = 0 ; i < n ; ++ i ) { max = std :: max ( max , A [ i ]); if ( max <= min [ i + 1 ]) return i + 1 ; } throw ; } }; 916. Word Subsets $\\star\\star$ 917. Reverse Only Letters $\\star$ 918. Maximum Sum Circular Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int maxSubarraySumCircular ( vector < int >& A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = INT_MIN ; int minSum = INT_MAX ; for ( int a : A ) { totalSum += a ; currMaxSum = max ( currMaxSum + a , a ); currMinSum = min ( currMinSum + a , a ); maxSum = max ( maxSum , currMaxSum ); minSum = min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : max ( maxSum , totalSum - minSum ); } }; 919. Complete Binary Tree Inserter $\\star\\star$ 920. Number of Music Playlists $\\star\\star\\star$","title":"0911-0920"},{"location":"cpp/0901-1000/0911-0920/#911-online-election-starstar","text":"","title":"911. Online Election $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#912-sort-an-array-starstar","text":"","title":"912. Sort an Array $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#913-cat-and-mouse-starstarstar","text":"","title":"913. Cat and Mouse $\\star\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#914-x-of-a-kind-in-a-deck-of-cards-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool hasGroupsSizeX ( vector < int >& deck ) { unordered_map < int , int > numCounts ; for ( int d : deck ) ++ numCounts [ d ]; int gcd = 0 ; for ( auto & [ _ , value ] : numCounts ) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } };","title":"914. X of a Kind in a Deck of Cards $\\star$"},{"location":"cpp/0901-1000/0911-0920/#915-partition-array-into-disjoint-intervals-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int partitionDisjoint ( vector < int >& A ) { const int n = A . size (); vector < int > min ( n ); min [ n - 1 ] = A [ n - 1 ]; int max = INT_MIN ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], A [ i ]); for ( int i = 0 ; i < n ; ++ i ) { max = std :: max ( max , A [ i ]); if ( max <= min [ i + 1 ]) return i + 1 ; } throw ; } };","title":"915. Partition Array into Disjoint Intervals $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#916-word-subsets-starstar","text":"","title":"916. Word Subsets $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#917-reverse-only-letters-star","text":"","title":"917. Reverse Only Letters $\\star$"},{"location":"cpp/0901-1000/0911-0920/#918-maximum-sum-circular-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int maxSubarraySumCircular ( vector < int >& A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = INT_MIN ; int minSum = INT_MAX ; for ( int a : A ) { totalSum += a ; currMaxSum = max ( currMaxSum + a , a ); currMinSum = min ( currMinSum + a , a ); maxSum = max ( maxSum , currMaxSum ); minSum = min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : max ( maxSum , totalSum - minSum ); } };","title":"918. Maximum Sum Circular Subarray $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#919-complete-binary-tree-inserter-starstar","text":"","title":"919. Complete Binary Tree Inserter $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#920-number-of-music-playlists-starstarstar","text":"","title":"920. Number of Music Playlists $\\star\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/","text":"921. Minimum Add to Make Parentheses Valid $\\star\\star$ 922. Sort Array By Parity II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortArrayByParityII ( vector < int >& A ) { const int n = A . size (); for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) swap ( A [ i ], A [ j ]); } return A ; } }; 923. 3Sum With Multiplicity $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int threeSumMulti ( vector < int >& A , int target ) { long ans = 0 ; unordered_map < int , long > map ; for ( int a : A ) ++ map [ a ]; for ( auto & [ i , x ] : map ) for ( auto & [ j , y ] : map ) { int k = target - i - j ; if ( ! map . count ( k )) continue ; if ( i == j && j == k ) ans += x * ( x - 1 ) * ( x - 2 ) / 6 ; else if ( i == j && j != k ) ans += x * ( x - 1 ) / 2 * map [ k ]; else if ( i < j && j < k ) ans += x * y * map [ k ]; } return ans % int ( 1e9 + 7 ); } }; 924. Minimize Malware Spread $\\star\\star\\star$ 925. Long Pressed Name $\\star$ 926. Flip String to Monotone Increasing $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int minFlipsMonoIncr ( string S ) { vector < int > dp ( 2 ); for ( int i = 0 ; i < S . length (); ++ i ) { int temp = dp [ 0 ] + ( S [ i ] == '1' ); dp [ 1 ] = min ( dp [ 0 ], dp [ 1 ]) + ( S [ i ] == '0' ); dp [ 0 ] = temp ; } return min ( dp [ 0 ], dp [ 1 ]); } }; 927. Three Equal Parts $\\star\\star\\star$ 928. Minimize Malware Spread II $\\star\\star\\star$ 929. Unique Email Addresses $\\star$ 930. Binary Subarrays With Sum $\\star\\star$","title":"0921-0930"},{"location":"cpp/0901-1000/0921-0930/#921-minimum-add-to-make-parentheses-valid-starstar","text":"","title":"921. Minimum Add to Make Parentheses Valid $\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#922-sort-array-by-parity-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortArrayByParityII ( vector < int >& A ) { const int n = A . size (); for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) swap ( A [ i ], A [ j ]); } return A ; } };","title":"922. Sort Array By Parity II $\\star$"},{"location":"cpp/0901-1000/0921-0930/#923-3sum-with-multiplicity-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int threeSumMulti ( vector < int >& A , int target ) { long ans = 0 ; unordered_map < int , long > map ; for ( int a : A ) ++ map [ a ]; for ( auto & [ i , x ] : map ) for ( auto & [ j , y ] : map ) { int k = target - i - j ; if ( ! map . count ( k )) continue ; if ( i == j && j == k ) ans += x * ( x - 1 ) * ( x - 2 ) / 6 ; else if ( i == j && j != k ) ans += x * ( x - 1 ) / 2 * map [ k ]; else if ( i < j && j < k ) ans += x * y * map [ k ]; } return ans % int ( 1e9 + 7 ); } };","title":"923. 3Sum With Multiplicity $\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#924-minimize-malware-spread-starstarstar","text":"","title":"924. Minimize Malware Spread $\\star\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#925-long-pressed-name-star","text":"","title":"925. Long Pressed Name $\\star$"},{"location":"cpp/0901-1000/0921-0930/#926-flip-string-to-monotone-increasing-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int minFlipsMonoIncr ( string S ) { vector < int > dp ( 2 ); for ( int i = 0 ; i < S . length (); ++ i ) { int temp = dp [ 0 ] + ( S [ i ] == '1' ); dp [ 1 ] = min ( dp [ 0 ], dp [ 1 ]) + ( S [ i ] == '0' ); dp [ 0 ] = temp ; } return min ( dp [ 0 ], dp [ 1 ]); } };","title":"926. Flip String to Monotone Increasing $\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#927-three-equal-parts-starstarstar","text":"","title":"927. Three Equal Parts $\\star\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#928-minimize-malware-spread-ii-starstarstar","text":"","title":"928. Minimize Malware Spread II $\\star\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#929-unique-email-addresses-star","text":"","title":"929. Unique Email Addresses $\\star$"},{"location":"cpp/0901-1000/0921-0930/#930-binary-subarrays-with-sum-starstar","text":"","title":"930. Binary Subarrays With Sum $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/","text":"931. Minimum Falling Path Sum $\\star\\star$ 932. Beautiful Array $\\star\\star$ 933. Number of Recent Calls $\\star$ 934. Shortest Bridge $\\star\\star$ 935. Knight Dialer $\\star\\star$ 936. Stamping The Sequence $\\star\\star\\star$ 937. Reorder Data in Log Files $\\star$ 938. Range Sum of BST $\\star$ 939. Minimum Area Rectangle $\\star\\star$ 940. Distinct Subsequences II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int distinctSubseqII ( string S ) { vector < long > map ( 26 ); for ( char c : S ) map [ c - 'a' ] = accumulate ( map . begin (), map . end (), 1L ) % int ( 1e9 + 7 ); return accumulate ( map . begin (), map . end (), 0L ) % int ( 1e9 + 7 ); } };","title":"0931-0940"},{"location":"cpp/0901-1000/0931-0940/#931-minimum-falling-path-sum-starstar","text":"","title":"931. Minimum Falling Path Sum $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#932-beautiful-array-starstar","text":"","title":"932. Beautiful Array $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#933-number-of-recent-calls-star","text":"","title":"933. Number of Recent Calls $\\star$"},{"location":"cpp/0901-1000/0931-0940/#934-shortest-bridge-starstar","text":"","title":"934. Shortest Bridge $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#935-knight-dialer-starstar","text":"","title":"935. Knight Dialer $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#936-stamping-the-sequence-starstarstar","text":"","title":"936. Stamping The Sequence $\\star\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#937-reorder-data-in-log-files-star","text":"","title":"937. Reorder Data in Log Files $\\star$"},{"location":"cpp/0901-1000/0931-0940/#938-range-sum-of-bst-star","text":"","title":"938. Range Sum of BST $\\star$"},{"location":"cpp/0901-1000/0931-0940/#939-minimum-area-rectangle-starstar","text":"","title":"939. Minimum Area Rectangle $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#940-distinct-subsequences-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int distinctSubseqII ( string S ) { vector < long > map ( 26 ); for ( char c : S ) map [ c - 'a' ] = accumulate ( map . begin (), map . end (), 1L ) % int ( 1e9 + 7 ); return accumulate ( map . begin (), map . end (), 0L ) % int ( 1e9 + 7 ); } };","title":"940. Distinct Subsequences II $\\star\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/","text":"941. Valid Mountain Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool validMountainArray ( vector < int >& A ) { if ( A . size () < 3 ) return false ; int l = 0 ; int r = A . size () - 1 ; while ( l + 1 < A . size () && A [ l ] < A [ l + 1 ]) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ]) -- r ; return l > 0 && r < A . size () - 1 && l == r ; } }; 942. DI String Match $\\star$ 943. Find the Shortest Superstring $\\star\\star\\star$ 944. Delete Columns to Make Sorted $\\star$ 945. Minimum Increment to Make Array Unique $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int minIncrementForUnique ( vector < int >& A ) { int ans = 0 ; int minAvailable = 0 ; sort ( A . begin (), A . end ()); for ( int a : A ) { ans += max ( minAvailable - a , 0 ); minAvailable = max ( minAvailable , a ) + 1 ; } return ans ; } }; 946. Validate Stack Sequences $\\star\\star$ 947. Most Stones Removed with Same Row or Column $\\star\\star$ 948. Bag of Tokens $\\star\\star$ 949. Largest Time for Given Digits $\\star$ 950. Reveal Cards In Increasing Order $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > deckRevealedIncreasing ( vector < int >& deck ) { sort ( deck . begin (), deck . end (), greater < int > ()); deque < int > deque = { deck [ 0 ]}; for ( int i = 1 ; i < deck . size (); ++ i ) { deque . push_front ( deque . back ()); deque . pop_back (); deque . push_front ( deck [ i ]); } return vector < int > ( deque . begin (), deque . end ()); } };","title":"0941-0950"},{"location":"cpp/0901-1000/0941-0950/#941-valid-mountain-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool validMountainArray ( vector < int >& A ) { if ( A . size () < 3 ) return false ; int l = 0 ; int r = A . size () - 1 ; while ( l + 1 < A . size () && A [ l ] < A [ l + 1 ]) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ]) -- r ; return l > 0 && r < A . size () - 1 && l == r ; } };","title":"941. Valid Mountain Array $\\star$"},{"location":"cpp/0901-1000/0941-0950/#942-di-string-match-star","text":"","title":"942. DI String Match $\\star$"},{"location":"cpp/0901-1000/0941-0950/#943-find-the-shortest-superstring-starstarstar","text":"","title":"943. Find the Shortest Superstring $\\star\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#944-delete-columns-to-make-sorted-star","text":"","title":"944. Delete Columns to Make Sorted $\\star$"},{"location":"cpp/0901-1000/0941-0950/#945-minimum-increment-to-make-array-unique-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int minIncrementForUnique ( vector < int >& A ) { int ans = 0 ; int minAvailable = 0 ; sort ( A . begin (), A . end ()); for ( int a : A ) { ans += max ( minAvailable - a , 0 ); minAvailable = max ( minAvailable , a ) + 1 ; } return ans ; } };","title":"945. Minimum Increment to Make Array Unique $\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#946-validate-stack-sequences-starstar","text":"","title":"946. Validate Stack Sequences $\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#947-most-stones-removed-with-same-row-or-column-starstar","text":"","title":"947. Most Stones Removed with Same Row or Column $\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#948-bag-of-tokens-starstar","text":"","title":"948. Bag of Tokens $\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#949-largest-time-for-given-digits-star","text":"","title":"949. Largest Time for Given Digits $\\star$"},{"location":"cpp/0901-1000/0941-0950/#950-reveal-cards-in-increasing-order-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > deckRevealedIncreasing ( vector < int >& deck ) { sort ( deck . begin (), deck . end (), greater < int > ()); deque < int > deque = { deck [ 0 ]}; for ( int i = 1 ; i < deck . size (); ++ i ) { deque . push_front ( deque . back ()); deque . pop_back (); deque . push_front ( deck [ i ]); } return vector < int > ( deque . begin (), deque . end ()); } };","title":"950. Reveal Cards In Increasing Order $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/","text":"951. Flip Equivalent Binary Trees $\\star\\star$ 952. Largest Component Size by Common Factor $\\star\\star\\star$ 953. Verifying an Alien Dictionary $\\star$ 954. Array of Doubled Pairs $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool canReorderDoubled ( vector < int >& A ) { unordered_map < int , int > count ; for ( int a : A ) ++ count [ a ]; sort ( A . begin (), A . end (), []( int a , int b ) { return abs ( a ) < abs ( b ); }); for ( int a : A ) { if ( count [ a ] == 0 ) continue ; if ( count [ 2 * a ] == 0 ) return false ; -- count [ a ]; -- count [ 2 * a ]; } return true ; } }; 955. Delete Columns to Make Sorted II $\\star\\star$ 956. Tallest Billboard $\\star\\star\\star$ 957. Prison Cells After N Days $\\star\\star$ 958. Check Completeness of a Binary Tree $\\star\\star$ 959. Regions Cut By Slashes $\\star\\star$ 960. Delete Columns to Make Sorted III $\\star\\star\\star$","title":"0951-0960"},{"location":"cpp/0901-1000/0951-0960/#951-flip-equivalent-binary-trees-starstar","text":"","title":"951. Flip Equivalent Binary Trees $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#952-largest-component-size-by-common-factor-starstarstar","text":"","title":"952. Largest Component Size by Common Factor $\\star\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#953-verifying-an-alien-dictionary-star","text":"","title":"953. Verifying an Alien Dictionary $\\star$"},{"location":"cpp/0901-1000/0951-0960/#954-array-of-doubled-pairs-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool canReorderDoubled ( vector < int >& A ) { unordered_map < int , int > count ; for ( int a : A ) ++ count [ a ]; sort ( A . begin (), A . end (), []( int a , int b ) { return abs ( a ) < abs ( b ); }); for ( int a : A ) { if ( count [ a ] == 0 ) continue ; if ( count [ 2 * a ] == 0 ) return false ; -- count [ a ]; -- count [ 2 * a ]; } return true ; } };","title":"954. Array of Doubled Pairs $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#955-delete-columns-to-make-sorted-ii-starstar","text":"","title":"955. Delete Columns to Make Sorted II $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#956-tallest-billboard-starstarstar","text":"","title":"956. Tallest Billboard $\\star\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#957-prison-cells-after-n-days-starstar","text":"","title":"957. Prison Cells After N Days $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#958-check-completeness-of-a-binary-tree-starstar","text":"","title":"958. Check Completeness of a Binary Tree $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#959-regions-cut-by-slashes-starstar","text":"","title":"959. Regions Cut By Slashes $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#960-delete-columns-to-make-sorted-iii-starstarstar","text":"","title":"960. Delete Columns to Make Sorted III $\\star\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/","text":"961. N-Repeated Element in Size 2N Array $\\star$ 962. Maximum Width Ramp $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxWidthRamp ( vector < int >& A ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i < A . size (); ++ i ) if ( stack . empty () || A [ i ] < A [ stack . top ()]) stack . push ( i ); for ( int i = A . size () - 1 ; i > ans ; -- i ) while ( ! stack . empty () && A [ i ] >= A [ stack . top ()]) ans = max ( ans , i - stack . top ()), stack . pop (); return ans ; } }; 963. Minimum Area Rectangle II $\\star\\star$ 964. Least Operators to Express Number $\\star\\star\\star$ 965. Univalued Binary Tree $\\star$ 966. Vowel Spellchecker $\\star\\star$ 967. Numbers With Same Consecutive Differences $\\star\\star$ 968. Binary Tree Cameras $\\star\\star\\star$ 969. Pancake Sorting $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > pancakeSort ( vector < int >& A ) { vector < int > ans ; for ( int target = A . size (); target >= 1 ; -- target ) { int index = find ( A , target ); reverse ( A . begin (), A . begin () + index + 1 ); reverse ( A . begin (), A . begin () + target ); ans . push_back ( index + 1 ); ans . push_back ( target ); } return ans ; } private : int find ( vector < int >& A , int target ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( A [ i ] == target ) return i ; throw ; } }; 970. Powerful Integers $\\star$","title":"0961-0970"},{"location":"cpp/0901-1000/0961-0970/#961-n-repeated-element-in-size-2n-array-star","text":"","title":"961. N-Repeated Element in Size 2N Array $\\star$"},{"location":"cpp/0901-1000/0961-0970/#962-maximum-width-ramp-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxWidthRamp ( vector < int >& A ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i < A . size (); ++ i ) if ( stack . empty () || A [ i ] < A [ stack . top ()]) stack . push ( i ); for ( int i = A . size () - 1 ; i > ans ; -- i ) while ( ! stack . empty () && A [ i ] >= A [ stack . top ()]) ans = max ( ans , i - stack . top ()), stack . pop (); return ans ; } };","title":"962. Maximum Width Ramp $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#963-minimum-area-rectangle-ii-starstar","text":"","title":"963. Minimum Area Rectangle II $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#964-least-operators-to-express-number-starstarstar","text":"","title":"964. Least Operators to Express Number $\\star\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#965-univalued-binary-tree-star","text":"","title":"965. Univalued Binary Tree $\\star$"},{"location":"cpp/0901-1000/0961-0970/#966-vowel-spellchecker-starstar","text":"","title":"966. Vowel Spellchecker $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#967-numbers-with-same-consecutive-differences-starstar","text":"","title":"967. Numbers With Same Consecutive Differences $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#968-binary-tree-cameras-starstarstar","text":"","title":"968. Binary Tree Cameras $\\star\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#969-pancake-sorting-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > pancakeSort ( vector < int >& A ) { vector < int > ans ; for ( int target = A . size (); target >= 1 ; -- target ) { int index = find ( A , target ); reverse ( A . begin (), A . begin () + index + 1 ); reverse ( A . begin (), A . begin () + target ); ans . push_back ( index + 1 ); ans . push_back ( target ); } return ans ; } private : int find ( vector < int >& A , int target ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( A [ i ] == target ) return i ; throw ; } };","title":"969. Pancake Sorting $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#970-powerful-integers-star","text":"","title":"970. Powerful Integers $\\star$"},{"location":"cpp/0901-1000/0971-0980/","text":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$ 972. Equal Rational Numbers $\\star\\star\\star$ 973. K Closest Points to Origin $\\star\\star$ 974. Subarray Sums Divisible by K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraysDivByK ( vector < int >& A , int K ) { int ans = 0 ; int presum = 0 ; vector < int > count ( K ); count [ 0 ] = 1 ; for ( int a : A ) { presum = ( presum + a % K + K ) % K ; ans += count [ presum ]; ++ count [ presum ]; } return ans ; } }; 975. Odd Even Jump $\\star\\star\\star$ 976. Largest Perimeter Triangle $\\star$ 977. Squares of a Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortedSquares ( vector < int >& A ) { int n = A . size (); int l = 0 ; int r = n - 1 ; vector < int > ans ( n ); while ( l <= r ) ans [ -- n ] = abs ( A [ l ]) > abs ( A [ r ]) ? A [ l ] * A [ l ++ ] : A [ r ] * A [ r -- ]; return ans ; } }; 978. Longest Turbulent Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxTurbulenceSize ( vector < int >& A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . size (); ++ i ) { if ( A [ i ] > A [ i - 1 ]) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ]) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = max ( ans , max ( increasing , decreasing )); } return ans ; } }; 979. Distribute Coins in Binary Tree $\\star\\star$ 980. Unique Paths III $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int uniquePathsIII ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; int empty = 1 ; int sx ; int sy ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 0 ) { ++ empty ; } else if ( grid [ i ][ j ] == 1 ) { sx = i ; sy = j ; } else if ( grid [ i ][ j ] == 2 ) { ex = i ; ey = j ; } } dfs ( grid , empty , sx , sy , ans ); return ans ; } private : int ex ; int ey ; void dfs ( vector < vector < int >>& grid , int empty , int i , int j , int & ans ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] < 0 ) return ; if ( i == ex && j == ey ) { if ( empty == 0 ) ++ ans ; return ; } grid [ i ][ j ] = - 2 ; dfs ( grid , empty - 1 , i + 1 , j , ans ); dfs ( grid , empty - 1 , i - 1 , j , ans ); dfs ( grid , empty - 1 , i , j + 1 , ans ); dfs ( grid , empty - 1 , i , j - 1 , ans ); grid [ i ][ j ] = 0 ; } };","title":"0971-0980"},{"location":"cpp/0901-1000/0971-0980/#971-flip-binary-tree-to-match-preorder-traversal-starstar","text":"","title":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#972-equal-rational-numbers-starstarstar","text":"","title":"972. Equal Rational Numbers $\\star\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#973-k-closest-points-to-origin-starstar","text":"","title":"973. K Closest Points to Origin $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#974-subarray-sums-divisible-by-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraysDivByK ( vector < int >& A , int K ) { int ans = 0 ; int presum = 0 ; vector < int > count ( K ); count [ 0 ] = 1 ; for ( int a : A ) { presum = ( presum + a % K + K ) % K ; ans += count [ presum ]; ++ count [ presum ]; } return ans ; } };","title":"974. Subarray Sums Divisible by K $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#975-odd-even-jump-starstarstar","text":"","title":"975. Odd Even Jump $\\star\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#976-largest-perimeter-triangle-star","text":"","title":"976. Largest Perimeter Triangle $\\star$"},{"location":"cpp/0901-1000/0971-0980/#977-squares-of-a-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortedSquares ( vector < int >& A ) { int n = A . size (); int l = 0 ; int r = n - 1 ; vector < int > ans ( n ); while ( l <= r ) ans [ -- n ] = abs ( A [ l ]) > abs ( A [ r ]) ? A [ l ] * A [ l ++ ] : A [ r ] * A [ r -- ]; return ans ; } };","title":"977. Squares of a Sorted Array $\\star$"},{"location":"cpp/0901-1000/0971-0980/#978-longest-turbulent-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxTurbulenceSize ( vector < int >& A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . size (); ++ i ) { if ( A [ i ] > A [ i - 1 ]) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ]) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = max ( ans , max ( increasing , decreasing )); } return ans ; } };","title":"978. Longest Turbulent Subarray $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#979-distribute-coins-in-binary-tree-starstar","text":"","title":"979. Distribute Coins in Binary Tree $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#980-unique-paths-iii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int uniquePathsIII ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; int empty = 1 ; int sx ; int sy ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 0 ) { ++ empty ; } else if ( grid [ i ][ j ] == 1 ) { sx = i ; sy = j ; } else if ( grid [ i ][ j ] == 2 ) { ex = i ; ey = j ; } } dfs ( grid , empty , sx , sy , ans ); return ans ; } private : int ex ; int ey ; void dfs ( vector < vector < int >>& grid , int empty , int i , int j , int & ans ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] < 0 ) return ; if ( i == ex && j == ey ) { if ( empty == 0 ) ++ ans ; return ; } grid [ i ][ j ] = - 2 ; dfs ( grid , empty - 1 , i + 1 , j , ans ); dfs ( grid , empty - 1 , i - 1 , j , ans ); dfs ( grid , empty - 1 , i , j + 1 , ans ); dfs ( grid , empty - 1 , i , j - 1 , ans ); grid [ i ][ j ] = 0 ; } };","title":"980. Unique Paths III $\\star\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/","text":"981. Time Based Key-Value Store $\\star\\star$ 982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$ 983. Minimum Cost For Tickets $\\star\\star$ 984. String Without AAA or BBB $\\star\\star$ 985. Sum of Even Numbers After Queries $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > sumEvenAfterQueries ( vector < int >& A , vector < vector < int >>& queries ) { vector < int > ans ; int sum = accumulate ( A . begin (), A . end (), 0 , []( int a , int b ) { return a + ( b % 2 == 0 ? b : 0 ); }); for ( vector < int >& query : queries ) { if ( A [ query [ 1 ]] % 2 == 0 ) sum -= A [ query [ 1 ]]; A [ query [ 1 ]] += query [ 0 ]; if ( A [ query [ 1 ]] % 2 == 0 ) sum += A [ query [ 1 ]]; ans . push_back ( sum ); } return ans ; } }; 986. Interval List Intersections $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> intervalIntersection ( vector < vector < int >>& A , vector < vector < int >>& B ) { vector < vector < int >> ans ; short i = 0 ; short j = 0 ; while ( i < A . size () && j < B . size ()) { int start = max ( A [ i ][ 0 ], B [ j ][ 0 ]); int end = min ( A [ i ][ 1 ], B [ j ][ 1 ]); if ( end >= start ) ans . push_back ({ start , end }); if ( A [ i ][ 1 ] > B [ j ][ 1 ]) ++ j ; else ++ i ; } return ans ; } }; 987. Vertical Order Traversal of a Binary Tree $\\star\\star$ 988. Smallest String Starting From Leaf $\\star\\star$ 989. Add to Array-Form of Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > addToArrayForm ( vector < int >& A , int K ) { for ( int i = A . size () - 1 ; i >= 0 ; -- i ) { A [ i ] += K ; K = A [ i ] / 10 ; A [ i ] %= 10 ; } while ( K > 0 ) { A . insert ( A . begin (), K % 10 ); K /= 10 ; } return A ; } }; 990. Satisfiability of Equality Equations $\\star\\star$","title":"0981-0990"},{"location":"cpp/0901-1000/0981-0990/#981-time-based-key-value-store-starstar","text":"","title":"981. Time Based Key-Value Store $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#982-triples-with-bitwise-and-equal-to-zero-starstarstar","text":"","title":"982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#983-minimum-cost-for-tickets-starstar","text":"","title":"983. Minimum Cost For Tickets $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#984-string-without-aaa-or-bbb-starstar","text":"","title":"984. String Without AAA or BBB $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#985-sum-of-even-numbers-after-queries-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > sumEvenAfterQueries ( vector < int >& A , vector < vector < int >>& queries ) { vector < int > ans ; int sum = accumulate ( A . begin (), A . end (), 0 , []( int a , int b ) { return a + ( b % 2 == 0 ? b : 0 ); }); for ( vector < int >& query : queries ) { if ( A [ query [ 1 ]] % 2 == 0 ) sum -= A [ query [ 1 ]]; A [ query [ 1 ]] += query [ 0 ]; if ( A [ query [ 1 ]] % 2 == 0 ) sum += A [ query [ 1 ]]; ans . push_back ( sum ); } return ans ; } };","title":"985. Sum of Even Numbers After Queries $\\star$"},{"location":"cpp/0901-1000/0981-0990/#986-interval-list-intersections-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> intervalIntersection ( vector < vector < int >>& A , vector < vector < int >>& B ) { vector < vector < int >> ans ; short i = 0 ; short j = 0 ; while ( i < A . size () && j < B . size ()) { int start = max ( A [ i ][ 0 ], B [ j ][ 0 ]); int end = min ( A [ i ][ 1 ], B [ j ][ 1 ]); if ( end >= start ) ans . push_back ({ start , end }); if ( A [ i ][ 1 ] > B [ j ][ 1 ]) ++ j ; else ++ i ; } return ans ; } };","title":"986. Interval List Intersections $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#987-vertical-order-traversal-of-a-binary-tree-starstar","text":"","title":"987. Vertical Order Traversal of a Binary Tree $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#988-smallest-string-starting-from-leaf-starstar","text":"","title":"988. Smallest String Starting From Leaf $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#989-add-to-array-form-of-integer-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > addToArrayForm ( vector < int >& A , int K ) { for ( int i = A . size () - 1 ; i >= 0 ; -- i ) { A [ i ] += K ; K = A [ i ] / 10 ; A [ i ] %= 10 ; } while ( K > 0 ) { A . insert ( A . begin (), K % 10 ); K /= 10 ; } return A ; } };","title":"989. Add to Array-Form of Integer $\\star$"},{"location":"cpp/0901-1000/0981-0990/#990-satisfiability-of-equality-equations-starstar","text":"","title":"990. Satisfiability of Equality Equations $\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/","text":"991. Broken Calculator $\\star\\star$ 992. Subarrays with K Different Integers $\\star\\star\\star$ 993. Cousins in Binary Tree $\\star$ 994. Rotting Oranges $\\star$ 995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$ 996. Number of Squareful Arrays $\\star\\star\\star$ 997. Find the Town Judge $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int findJudge ( int N , vector < vector < int >>& trust ) { vector < int > count ( N ); for ( vector < int >& t : trust ) { -- count [ t [ 0 ] - 1 ]; ++ count [ t [ 1 ] - 1 ]; } for ( int i = 0 ; i < N ; ++ i ) if ( count [ i ] == N - 1 ) return i + 1 ; return - 1 ; } }; 998. Maximum Binary Tree II $\\star\\star$ 999. Available Captures for Rook $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numRookCaptures ( vector < vector < char >>& board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( auto d : vector < vector < int >> ({{ 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 }})) for ( int i = i0 + d [ 0 ], j = j0 + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) { if ( board [ i ][ j ] == 'p' ) ++ ans ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } }; 1000. Minimum Cost to Merge Stones $\\star\\star\\star$","title":"0991-1000"},{"location":"cpp/0901-1000/0991-1000/#991-broken-calculator-starstar","text":"","title":"991. Broken Calculator $\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#992-subarrays-with-k-different-integers-starstarstar","text":"","title":"992. Subarrays with K Different Integers $\\star\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#993-cousins-in-binary-tree-star","text":"","title":"993. Cousins in Binary Tree $\\star$"},{"location":"cpp/0901-1000/0991-1000/#994-rotting-oranges-star","text":"","title":"994. Rotting Oranges $\\star$"},{"location":"cpp/0901-1000/0991-1000/#995-minimum-number-of-k-consecutive-bit-flips-starstarstar","text":"","title":"995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#996-number-of-squareful-arrays-starstarstar","text":"","title":"996. Number of Squareful Arrays $\\star\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#997-find-the-town-judge-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int findJudge ( int N , vector < vector < int >>& trust ) { vector < int > count ( N ); for ( vector < int >& t : trust ) { -- count [ t [ 0 ] - 1 ]; ++ count [ t [ 1 ] - 1 ]; } for ( int i = 0 ; i < N ; ++ i ) if ( count [ i ] == N - 1 ) return i + 1 ; return - 1 ; } };","title":"997. Find the Town Judge $\\star$"},{"location":"cpp/0901-1000/0991-1000/#998-maximum-binary-tree-ii-starstar","text":"","title":"998. Maximum Binary Tree II $\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#999-available-captures-for-rook-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numRookCaptures ( vector < vector < char >>& board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( auto d : vector < vector < int >> ({{ 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 }})) for ( int i = i0 + d [ 0 ], j = j0 + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) { if ( board [ i ][ j ] == 'p' ) ++ ans ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } };","title":"999. Available Captures for Rook $\\star$"},{"location":"cpp/0901-1000/0991-1000/#1000-minimum-cost-to-merge-stones-starstarstar","text":"","title":"1000. Minimum Cost to Merge Stones $\\star\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/","text":"1001. Grid Illumination $\\star\\star\\star$ 1002. Find Common Characters $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > commonChars ( vector < string >& A ) { vector < string > ans ; vector < int > commonCount ( 26 , INT_MAX ); for ( string & a : A ) { vector < int > count ( 26 ); for ( char c : a ) ++ count [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = min ( commonCount [ i ], count [ i ]); } for ( char c = 'a' ; c <= 'z' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - 'a' ]; ++ i ) ans . push_back ( string ( 1 , c )); return ans ; } }; 1003. Check If Word Is Valid After Substitutions $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool isValid ( string S ) { vector < char > stack ; for ( char c : S ) { if ( c == 'c' ) { int n = stack . size (); if ( n < 2 || stack [ n - 2 ] != 'a' || stack [ n - 1 ] != 'b' ) return false ; stack . pop_back (); stack . pop_back (); } else { stack . push_back ( c ); } } return stack . empty (); } }; 1004. Max Consecutive Ones III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int longestOnes ( vector < int >& A , int K ) { int i = 0 ; for ( int a : A ) { if ( a == 0 ) -- K ; if ( K < 0 ) { if ( A [ i ] == 0 ) ++ K ; ++ i ; } } return A . size () - i ; } }; 1005. Maximize Sum Of Array After K Negations $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int largestSumAfterKNegations ( vector < int >& A , int K ) { sort ( A . begin (), A . end ()); for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > 0 || K == 0 ) break ; A [ i ] = - A [ i ]; -- K ; } return accumulate ( A . begin (), A . end (), 0 ) - ( K % 2 ) * * min_element ( A . begin (), A . end ()) * 2 ; } }; 1006. Clumsy Factorial $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int clumsy ( int N ) { if ( N <= 2 ) return N ; if ( N <= 4 ) return N + 3 ; if (( N - 4 ) % 4 == 0 ) return N + 1 ; if (( N - 4 ) % 4 <= 2 ) return N + 2 ; return N - 1 ; } }; 1007. Minimum Domino Rotations For Equal Row $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minDominoRotations ( vector < int >& A , vector < int >& B ) { const int n = A . size (); vector < int > countA ( 7 ); vector < int > countB ( 7 ); vector < int > countBoth ( 7 ); for ( int i = 0 ; i < n ; ++ i ) { ++ countA [ A [ i ]]; ++ countB [ B [ i ]]; if ( A [ i ] == B [ i ]) ++ countBoth [ A [ i ]]; } for ( int i = 1 ; i <= 6 ; ++ i ) if ( countA [ i ] + countB [ i ] - countBoth [ i ] == n ) return n - max ( countA [ i ], countB [ i ]); return - 1 ; } }; 1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$ 1009. Complement of Base 10 Integer $\\star$ 1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numPairsDivisibleBy60 ( vector < int >& time ) { int ans = 0 ; vector < int > count ( 60 ); for ( int t : time ) { t %= 60 ; ans += t == 0 ? count [ 0 ] : count [ 60 - t ]; ++ count [ t ]; } return ans ; } };","title":"1001-1010"},{"location":"cpp/1001-1100/1001-1010/#1001-grid-illumination-starstarstar","text":"","title":"1001. Grid Illumination $\\star\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1002-find-common-characters-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > commonChars ( vector < string >& A ) { vector < string > ans ; vector < int > commonCount ( 26 , INT_MAX ); for ( string & a : A ) { vector < int > count ( 26 ); for ( char c : a ) ++ count [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = min ( commonCount [ i ], count [ i ]); } for ( char c = 'a' ; c <= 'z' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - 'a' ]; ++ i ) ans . push_back ( string ( 1 , c )); return ans ; } };","title":"1002. Find Common Characters $\\star$"},{"location":"cpp/1001-1100/1001-1010/#1003-check-if-word-is-valid-after-substitutions-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool isValid ( string S ) { vector < char > stack ; for ( char c : S ) { if ( c == 'c' ) { int n = stack . size (); if ( n < 2 || stack [ n - 2 ] != 'a' || stack [ n - 1 ] != 'b' ) return false ; stack . pop_back (); stack . pop_back (); } else { stack . push_back ( c ); } } return stack . empty (); } };","title":"1003. Check If Word Is Valid After Substitutions $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1004-max-consecutive-ones-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int longestOnes ( vector < int >& A , int K ) { int i = 0 ; for ( int a : A ) { if ( a == 0 ) -- K ; if ( K < 0 ) { if ( A [ i ] == 0 ) ++ K ; ++ i ; } } return A . size () - i ; } };","title":"1004. Max Consecutive Ones III $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1005-maximize-sum-of-array-after-k-negations-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int largestSumAfterKNegations ( vector < int >& A , int K ) { sort ( A . begin (), A . end ()); for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > 0 || K == 0 ) break ; A [ i ] = - A [ i ]; -- K ; } return accumulate ( A . begin (), A . end (), 0 ) - ( K % 2 ) * * min_element ( A . begin (), A . end ()) * 2 ; } };","title":"1005. Maximize Sum Of Array After K Negations $\\star$"},{"location":"cpp/1001-1100/1001-1010/#1006-clumsy-factorial-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int clumsy ( int N ) { if ( N <= 2 ) return N ; if ( N <= 4 ) return N + 3 ; if (( N - 4 ) % 4 == 0 ) return N + 1 ; if (( N - 4 ) % 4 <= 2 ) return N + 2 ; return N - 1 ; } };","title":"1006. Clumsy Factorial $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1007-minimum-domino-rotations-for-equal-row-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minDominoRotations ( vector < int >& A , vector < int >& B ) { const int n = A . size (); vector < int > countA ( 7 ); vector < int > countB ( 7 ); vector < int > countBoth ( 7 ); for ( int i = 0 ; i < n ; ++ i ) { ++ countA [ A [ i ]]; ++ countB [ B [ i ]]; if ( A [ i ] == B [ i ]) ++ countBoth [ A [ i ]]; } for ( int i = 1 ; i <= 6 ; ++ i ) if ( countA [ i ] + countB [ i ] - countBoth [ i ] == n ) return n - max ( countA [ i ], countB [ i ]); return - 1 ; } };","title":"1007. Minimum Domino Rotations For Equal Row $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1008-construct-binary-search-tree-from-preorder-traversal-starstar","text":"","title":"1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1009-complement-of-base-10-integer-star","text":"","title":"1009. Complement of Base 10 Integer $\\star$"},{"location":"cpp/1001-1100/1001-1010/#1010-pairs-of-songs-with-total-durations-divisible-by-60-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numPairsDivisibleBy60 ( vector < int >& time ) { int ans = 0 ; vector < int > count ( 60 ); for ( int t : time ) { t %= 60 ; ans += t == 0 ? count [ 0 ] : count [ 60 - t ]; ++ count [ t ]; } return ans ; } };","title":"1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$"},{"location":"cpp/1001-1100/1011-1020/","text":"1011. Capacity To Ship Packages Within D Days $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int shipWithinDays ( vector < int >& weights , int D ) { int l = * max_element ( weights . begin (), weights . end ()); int r = accumulate ( weights . begin (), weights . end (), 0 ); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { ++ day ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } }; 1012. Numbers With Repeated Digits $\\star\\star\\star$ 1013. Partition Array Into Three Parts With Equal Sum $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canThreePartsEqualSum ( vector < int >& A ) { int sum = accumulate ( A . begin (), A . end (), 0 ); int presum = 0 ; int parts = 1 ; for ( int a : A ) { presum += a ; if ( presum == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } }; 1014. Best Sightseeing Pair $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxScoreSightseeingPair ( vector < int >& A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = max ( ans , a + bestPrev ); bestPrev = max ( bestPrev , a ) - 1 ; } return ans ; } }; 1015. Smallest Integer Divisible by K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; unordered_set < int > set ; int mod = 0 ; for ( int N = 1 ; N <= K ; ++ N ) { mod = ( mod * 10 + 1 ) % K ; if ( mod == 0 ) return N ; if ( set . count ( mod )) return - 1 ; set . insert ( mod ); } return - 1 ; } }; 1016. Binary String With Substrings Representing 1 To N $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool queryString ( string S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) { string binary = bitset < 32 > ( i ). to_string (); binary = binary . substr ( binary . find ( \"1\" )); if ( S . find ( binary ) == string :: npos ) return false ; } return true ; } }; 1017. Convert to Base -2 $\\star\\star$ 1018. Binary Prefix Divisible By 5 $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < bool > prefixesDivBy5 ( vector < int >& A ) { vector < bool > ans ; int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . push_back ( num % 5 == 0 ); } return ans ; } }; 1019. Next Greater Node In Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > nextLargerNodes ( ListNode * head ) { vector < int > ans ; vector < int > stack ; for ( auto curr = head ; curr ; curr = curr -> next ) { while ( stack . size () && ans [ stack . back ()] < curr -> val ) { ans [ stack . back ()] = curr -> val ; stack . pop_back (); } stack . push_back ( ans . size ()); ans . push_back ( curr -> val ); } for ( int i : stack ) ans [ i ] = 0 ; return ans ; } }; 1020. Number of Enclaves $\\star\\star$","title":"1011-1020"},{"location":"cpp/1001-1100/1011-1020/#1011-capacity-to-ship-packages-within-d-days-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int shipWithinDays ( vector < int >& weights , int D ) { int l = * max_element ( weights . begin (), weights . end ()); int r = accumulate ( weights . begin (), weights . end (), 0 ); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { ++ day ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } };","title":"1011. Capacity To Ship Packages Within D Days $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1012-numbers-with-repeated-digits-starstarstar","text":"","title":"1012. Numbers With Repeated Digits $\\star\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1013-partition-array-into-three-parts-with-equal-sum-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canThreePartsEqualSum ( vector < int >& A ) { int sum = accumulate ( A . begin (), A . end (), 0 ); int presum = 0 ; int parts = 1 ; for ( int a : A ) { presum += a ; if ( presum == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } };","title":"1013. Partition Array Into Three Parts With Equal Sum $\\star$"},{"location":"cpp/1001-1100/1011-1020/#1014-best-sightseeing-pair-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxScoreSightseeingPair ( vector < int >& A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = max ( ans , a + bestPrev ); bestPrev = max ( bestPrev , a ) - 1 ; } return ans ; } };","title":"1014. Best Sightseeing Pair $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1015-smallest-integer-divisible-by-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; unordered_set < int > set ; int mod = 0 ; for ( int N = 1 ; N <= K ; ++ N ) { mod = ( mod * 10 + 1 ) % K ; if ( mod == 0 ) return N ; if ( set . count ( mod )) return - 1 ; set . insert ( mod ); } return - 1 ; } };","title":"1015. Smallest Integer Divisible by K $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1016-binary-string-with-substrings-representing-1-to-n-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool queryString ( string S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) { string binary = bitset < 32 > ( i ). to_string (); binary = binary . substr ( binary . find ( \"1\" )); if ( S . find ( binary ) == string :: npos ) return false ; } return true ; } };","title":"1016. Binary String With Substrings Representing 1 To N $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1017-convert-to-base-2-starstar","text":"","title":"1017. Convert to Base -2 $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1018-binary-prefix-divisible-by-5-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < bool > prefixesDivBy5 ( vector < int >& A ) { vector < bool > ans ; int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . push_back ( num % 5 == 0 ); } return ans ; } };","title":"1018. Binary Prefix Divisible By 5 $\\star$"},{"location":"cpp/1001-1100/1011-1020/#1019-next-greater-node-in-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > nextLargerNodes ( ListNode * head ) { vector < int > ans ; vector < int > stack ; for ( auto curr = head ; curr ; curr = curr -> next ) { while ( stack . size () && ans [ stack . back ()] < curr -> val ) { ans [ stack . back ()] = curr -> val ; stack . pop_back (); } stack . push_back ( ans . size ()); ans . push_back ( curr -> val ); } for ( int i : stack ) ans [ i ] = 0 ; return ans ; } };","title":"1019. Next Greater Node In Linked List $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1020-number-of-enclaves-starstar","text":"","title":"1020. Number of Enclaves $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/","text":"1021. Remove Outermost Parentheses $\\star$ 1022. Sum of Root To Leaf Binary Numbers $\\star$ 1023. Camelcase Matching $\\star\\star$ 1024. Video Stitching $\\star\\star$ 1025. Divisor Game $\\star$ 1026. Maximum Difference Between Node and Ancestor $\\star\\star$ 1027. Longest Arithmetic Sequence $\\star\\star$ 1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$ 1029. Two City Scheduling $\\star$ 1030. Matrix Cells in Distance Order $\\star$","title":"1021-1030"},{"location":"cpp/1001-1100/1021-1030/#1021-remove-outermost-parentheses-star","text":"","title":"1021. Remove Outermost Parentheses $\\star$"},{"location":"cpp/1001-1100/1021-1030/#1022-sum-of-root-to-leaf-binary-numbers-star","text":"","title":"1022. Sum of Root To Leaf Binary Numbers $\\star$"},{"location":"cpp/1001-1100/1021-1030/#1023-camelcase-matching-starstar","text":"","title":"1023. Camelcase Matching $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1024-video-stitching-starstar","text":"","title":"1024. Video Stitching $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1025-divisor-game-star","text":"","title":"1025. Divisor Game $\\star$"},{"location":"cpp/1001-1100/1021-1030/#1026-maximum-difference-between-node-and-ancestor-starstar","text":"","title":"1026. Maximum Difference Between Node and Ancestor $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1027-longest-arithmetic-sequence-starstar","text":"","title":"1027. Longest Arithmetic Sequence $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1028-recover-a-tree-from-preorder-traversal-starstarstar","text":"","title":"1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1029-two-city-scheduling-star","text":"","title":"1029. Two City Scheduling $\\star$"},{"location":"cpp/1001-1100/1021-1030/#1030-matrix-cells-in-distance-order-star","text":"","title":"1030. Matrix Cells in Distance Order $\\star$"},{"location":"cpp/1001-1100/1031-1040/","text":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int maxSumTwoNoOverlap ( vector < int >& A , int L , int M ) { return max ( helper ( A , L , M ), helper ( A , M , L )); } private : int helper ( vector < int >& A , int l , int r ) { const int n = A . size (); vector < int > left ( n ); int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ]; if ( i >= l ) sum -= A [ i - l ]; if ( i >= l - 1 ) left [ i ] = i > 0 ? max ( left [ i - 1 ], sum ) : sum ; } vector < int > right ( n ); sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ]; if ( i <= n - r - 1 ) sum -= A [ i + r ]; if ( i <= n - r ) right [ i ] = i < n - 1 ? max ( right [ i + 1 ], sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = max ( ans , left [ i ] + right [ i + 1 ]); return ans ; } }; 1032. Stream of Characters $\\star\\star\\star$ 1033. Moving Stones Until Consecutive $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < int > numMovesStones ( int a , int b , int c ) { vector < int > nums = { a , b , c }; sort ( nums . begin (), nums . end ()); if ( nums [ 2 ] - nums [ 0 ] == 2 ) return { 0 , 0 }; return { min ( nums [ 1 ] - nums [ 0 ], nums [ 2 ] - nums [ 1 ]) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 }; } }; 1034. Coloring A Border $\\star\\star$ 1035. Uncrossed Lines $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxUncrossedLines ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] + 1 : max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); return dp [ m ][ n ]; } }; 1036. Escape a Large Maze $\\star\\star\\star$ 1037. Valid Boomerang $\\star$ 1038. Binary Search Tree to Greater Sum Tree $\\star\\star$ 1039. Minimum Score Triangulation of Polygon $\\star\\star$ 1040. Moving Stones Until Consecutive II $\\star\\star$","title":"1031-1040"},{"location":"cpp/1001-1100/1031-1040/#1031-maximum-sum-of-two-non-overlapping-subarrays-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int maxSumTwoNoOverlap ( vector < int >& A , int L , int M ) { return max ( helper ( A , L , M ), helper ( A , M , L )); } private : int helper ( vector < int >& A , int l , int r ) { const int n = A . size (); vector < int > left ( n ); int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ]; if ( i >= l ) sum -= A [ i - l ]; if ( i >= l - 1 ) left [ i ] = i > 0 ? max ( left [ i - 1 ], sum ) : sum ; } vector < int > right ( n ); sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ]; if ( i <= n - r - 1 ) sum -= A [ i + r ]; if ( i <= n - r ) right [ i ] = i < n - 1 ? max ( right [ i + 1 ], sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = max ( ans , left [ i ] + right [ i + 1 ]); return ans ; } };","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1032-stream-of-characters-starstarstar","text":"","title":"1032. Stream of Characters $\\star\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1033-moving-stones-until-consecutive-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < int > numMovesStones ( int a , int b , int c ) { vector < int > nums = { a , b , c }; sort ( nums . begin (), nums . end ()); if ( nums [ 2 ] - nums [ 0 ] == 2 ) return { 0 , 0 }; return { min ( nums [ 1 ] - nums [ 0 ], nums [ 2 ] - nums [ 1 ]) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 }; } };","title":"1033. Moving Stones Until Consecutive $\\star$"},{"location":"cpp/1001-1100/1031-1040/#1034-coloring-a-border-starstar","text":"","title":"1034. Coloring A Border $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1035-uncrossed-lines-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxUncrossedLines ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] + 1 : max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); return dp [ m ][ n ]; } };","title":"1035. Uncrossed Lines $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1036-escape-a-large-maze-starstarstar","text":"","title":"1036. Escape a Large Maze $\\star\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1037-valid-boomerang-star","text":"","title":"1037. Valid Boomerang $\\star$"},{"location":"cpp/1001-1100/1031-1040/#1038-binary-search-tree-to-greater-sum-tree-starstar","text":"","title":"1038. Binary Search Tree to Greater Sum Tree $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1039-minimum-score-triangulation-of-polygon-starstar","text":"","title":"1039. Minimum Score Triangulation of Polygon $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1040-moving-stones-until-consecutive-ii-starstar","text":"","title":"1040. Moving Stones Until Consecutive II $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/","text":"1041. Robot Bounded In Circle $\\star\\star$ 1042. Flower Planting With No Adjacent $\\star$ 1043. Partition Array for Maximum Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxSumAfterPartitioning ( vector < int >& A , int K ) { const int n = A . size (); vector < int > dp ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { int min = INT_MIN ; for ( int j = 1 ; j <= std :: min ( i , K ); ++ j ) { min = max ( min , A [ i - j ]); dp [ i ] = max ( dp [ i ], dp [ i - j ] + min * j ); } } return dp [ n ]; } }; 1044. Longest Duplicate Substring $\\star\\star\\star$ 1045. Customers Who Bought All Products $\\star\\star$ 1046. Last Stone Weight $\\star$ 1047. Remove All Adjacent Duplicates In String $\\star$ 1048. Longest String Chain $\\star\\star$ 1049. Last Stone Weight II $\\star\\star$ 1050. Actors and Directors Who Cooperated At Least Three Times $\\star$","title":"1041-1050"},{"location":"cpp/1001-1100/1041-1050/#1041-robot-bounded-in-circle-starstar","text":"","title":"1041. Robot Bounded In Circle $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1042-flower-planting-with-no-adjacent-star","text":"","title":"1042. Flower Planting With No Adjacent $\\star$"},{"location":"cpp/1001-1100/1041-1050/#1043-partition-array-for-maximum-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxSumAfterPartitioning ( vector < int >& A , int K ) { const int n = A . size (); vector < int > dp ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { int min = INT_MIN ; for ( int j = 1 ; j <= std :: min ( i , K ); ++ j ) { min = max ( min , A [ i - j ]); dp [ i ] = max ( dp [ i ], dp [ i - j ] + min * j ); } } return dp [ n ]; } };","title":"1043. Partition Array for Maximum Sum $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1044-longest-duplicate-substring-starstarstar","text":"","title":"1044. Longest Duplicate Substring $\\star\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1045-customers-who-bought-all-products-starstar","text":"","title":"1045. Customers Who Bought All Products $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1046-last-stone-weight-star","text":"","title":"1046. Last Stone Weight $\\star$"},{"location":"cpp/1001-1100/1041-1050/#1047-remove-all-adjacent-duplicates-in-string-star","text":"","title":"1047. Remove All Adjacent Duplicates In String $\\star$"},{"location":"cpp/1001-1100/1041-1050/#1048-longest-string-chain-starstar","text":"","title":"1048. Longest String Chain $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1049-last-stone-weight-ii-starstar","text":"","title":"1049. Last Stone Weight II $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1050-actors-and-directors-who-cooperated-at-least-three-times-star","text":"","title":"1050. Actors and Directors Who Cooperated At Least Three Times $\\star$"},{"location":"cpp/1001-1100/1051-1060/","text":"1051. Height Checker $\\star$ 1052. Grumpy Bookstore Owner $\\star\\star$ 1053. Previous Permutation With One Swap $\\star\\star$ 1054. Distant Barcodes $\\star\\star$ 1055. Shortest Way to Form String $\\star\\star$ 1056. Confusing Number $\\star$ 1057. Campus Bikes $\\star\\star$ 1058. Minimize Rounding Error to Meet Target $\\star\\star$ 1059. All Paths from Source Lead to Destination $\\star\\star$ 1060. Missing Element in Sorted Array $\\star\\star$","title":"1051-1060"},{"location":"cpp/1001-1100/1051-1060/#1051-height-checker-star","text":"","title":"1051. Height Checker $\\star$"},{"location":"cpp/1001-1100/1051-1060/#1052-grumpy-bookstore-owner-starstar","text":"","title":"1052. Grumpy Bookstore Owner $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1053-previous-permutation-with-one-swap-starstar","text":"","title":"1053. Previous Permutation With One Swap $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1054-distant-barcodes-starstar","text":"","title":"1054. Distant Barcodes $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1055-shortest-way-to-form-string-starstar","text":"","title":"1055. Shortest Way to Form String $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1056-confusing-number-star","text":"","title":"1056. Confusing Number $\\star$"},{"location":"cpp/1001-1100/1051-1060/#1057-campus-bikes-starstar","text":"","title":"1057. Campus Bikes $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1058-minimize-rounding-error-to-meet-target-starstar","text":"","title":"1058. Minimize Rounding Error to Meet Target $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1059-all-paths-from-source-lead-to-destination-starstar","text":"","title":"1059. All Paths from Source Lead to Destination $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1060-missing-element-in-sorted-array-starstar","text":"","title":"1060. Missing Element in Sorted Array $\\star\\star$"},{"location":"cpp/1001-1100/1061-1070/","text":"1061. Lexicographically Smallest Equivalent String $\\star\\star$ 1062. Longest Repeating Substring $\\star\\star$ 1063. Number of Valid Subarrays $\\star\\star\\star$ 1064. Fixed Point $\\star$ 1065. Index Pairs of a String $\\star$ 1066. Campus Bikes II $\\star\\star$ 1067. Digit Count in Range $\\star\\star\\star$ 1068. Product Sales Analysis I $\\star$ 1069. Product Sales Analysis II $\\star$ 1070. Product Sales Analysis III $\\star\\star$","title":"1061-1070"},{"location":"cpp/1001-1100/1061-1070/#1061-lexicographically-smallest-equivalent-string-starstar","text":"","title":"1061. Lexicographically Smallest Equivalent String $\\star\\star$"},{"location":"cpp/1001-1100/1061-1070/#1062-longest-repeating-substring-starstar","text":"","title":"1062. Longest Repeating Substring $\\star\\star$"},{"location":"cpp/1001-1100/1061-1070/#1063-number-of-valid-subarrays-starstarstar","text":"","title":"1063. Number of Valid Subarrays $\\star\\star\\star$"},{"location":"cpp/1001-1100/1061-1070/#1064-fixed-point-star","text":"","title":"1064. Fixed Point $\\star$"},{"location":"cpp/1001-1100/1061-1070/#1065-index-pairs-of-a-string-star","text":"","title":"1065. Index Pairs of a String $\\star$"},{"location":"cpp/1001-1100/1061-1070/#1066-campus-bikes-ii-starstar","text":"","title":"1066. Campus Bikes II $\\star\\star$"},{"location":"cpp/1001-1100/1061-1070/#1067-digit-count-in-range-starstarstar","text":"","title":"1067. Digit Count in Range $\\star\\star\\star$"},{"location":"cpp/1001-1100/1061-1070/#1068-product-sales-analysis-i-star","text":"","title":"1068. Product Sales Analysis I $\\star$"},{"location":"cpp/1001-1100/1061-1070/#1069-product-sales-analysis-ii-star","text":"","title":"1069. Product Sales Analysis II $\\star$"},{"location":"cpp/1001-1100/1061-1070/#1070-product-sales-analysis-iii-starstar","text":"","title":"1070. Product Sales Analysis III $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/","text":"1071. Greatest Common Divisor of Strings $\\star$ 1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$ 1073. Adding Two Negabinary Numbers $\\star\\star$ 1074. Number of Submatrices That Sum to Target $\\star\\star\\star$ 1075. Project Employees I $\\star$ 1076. Project Employees II $\\star$ 1077. Project Employees III $\\star\\star$ 1078. Occurrences After Bigram $\\star$ 1079. Letter Tile Possibilities $\\star\\star$ 1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$","title":"1071-1080"},{"location":"cpp/1001-1100/1071-1080/#1071-greatest-common-divisor-of-strings-star","text":"","title":"1071. Greatest Common Divisor of Strings $\\star$"},{"location":"cpp/1001-1100/1071-1080/#1072-flip-columns-for-maximum-number-of-equal-rows-starstar","text":"","title":"1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1073-adding-two-negabinary-numbers-starstar","text":"","title":"1073. Adding Two Negabinary Numbers $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1074-number-of-submatrices-that-sum-to-target-starstarstar","text":"","title":"1074. Number of Submatrices That Sum to Target $\\star\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1075-project-employees-i-star","text":"","title":"1075. Project Employees I $\\star$"},{"location":"cpp/1001-1100/1071-1080/#1076-project-employees-ii-star","text":"","title":"1076. Project Employees II $\\star$"},{"location":"cpp/1001-1100/1071-1080/#1077-project-employees-iii-starstar","text":"","title":"1077. Project Employees III $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1078-occurrences-after-bigram-star","text":"","title":"1078. Occurrences After Bigram $\\star$"},{"location":"cpp/1001-1100/1071-1080/#1079-letter-tile-possibilities-starstar","text":"","title":"1079. Letter Tile Possibilities $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1080-insufficient-nodes-in-root-to-leaf-paths-starstar","text":"","title":"1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$"},{"location":"cpp/1001-1100/1081-1090/","text":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$ 1082. Sales Analysis I $\\star$ 1083. Sales Analysis II $\\star$ 1084. Sales Analysis III $\\star$ 1085. Sum of Digits in the Minimum Number $\\star$ 1086. High Five $\\star$ 1087. Brace Expansion $\\star\\star$ 1088. Confusing Number II $\\star\\star\\star$ 1089. Duplicate Zeros $\\star$ 1090. Largest Values From Labels $\\star\\star$","title":"1081-1090"},{"location":"cpp/1001-1100/1081-1090/#1081-smallest-subsequence-of-distinct-characters-starstar","text":"","title":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$"},{"location":"cpp/1001-1100/1081-1090/#1082-sales-analysis-i-star","text":"","title":"1082. Sales Analysis I $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1083-sales-analysis-ii-star","text":"","title":"1083. Sales Analysis II $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1084-sales-analysis-iii-star","text":"","title":"1084. Sales Analysis III $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1085-sum-of-digits-in-the-minimum-number-star","text":"","title":"1085. Sum of Digits in the Minimum Number $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1086-high-five-star","text":"","title":"1086. High Five $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1087-brace-expansion-starstar","text":"","title":"1087. Brace Expansion $\\star\\star$"},{"location":"cpp/1001-1100/1081-1090/#1088-confusing-number-ii-starstarstar","text":"","title":"1088. Confusing Number II $\\star\\star\\star$"},{"location":"cpp/1001-1100/1081-1090/#1089-duplicate-zeros-star","text":"","title":"1089. Duplicate Zeros $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1090-largest-values-from-labels-starstar","text":"","title":"1090. Largest Values From Labels $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/","text":"1091. Shortest Path in Binary Matrix $\\star\\star$ 1092. Shortest Common Supersequence $\\star\\star\\star$ 1093. Statistics from a Large Sample $\\star\\star$ 1094. Car Pooling $\\star\\star$ 1095. Find in Mountain Array $\\star\\star\\star$ 1096. Brace Expansion II $\\star\\star\\star$ 1097. Game Play Analysis V $\\star\\star\\star$ 1098. Unpopular Books $\\star\\star$ 1099. Two Sum Less Than K $\\star$ 1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$","title":"1091-1100"},{"location":"cpp/1001-1100/1091-1100/#1091-shortest-path-in-binary-matrix-starstar","text":"","title":"1091. Shortest Path in Binary Matrix $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1092-shortest-common-supersequence-starstarstar","text":"","title":"1092. Shortest Common Supersequence  $\\star\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1093-statistics-from-a-large-sample-starstar","text":"","title":"1093. Statistics from a Large Sample $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1094-car-pooling-starstar","text":"","title":"1094. Car Pooling $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1095-find-in-mountain-array-starstarstar","text":"","title":"1095. Find in Mountain Array $\\star\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1096-brace-expansion-ii-starstarstar","text":"","title":"1096. Brace Expansion II $\\star\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1097-game-play-analysis-v-starstarstar","text":"","title":"1097. Game Play Analysis V $\\star\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1098-unpopular-books-starstar","text":"","title":"1098. Unpopular Books $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1099-two-sum-less-than-k-star","text":"","title":"1099. Two Sum Less Than K $\\star$"},{"location":"cpp/1001-1100/1091-1100/#1100-find-k-length-substrings-with-no-repeated-characters-starstar","text":"","title":"1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/","text":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$ 1102. Path With Maximum Minimum Value $\\star\\star$ 1103. Distribute Candies to People $\\star$ 1104. Path In Zigzag Labelled Binary Tree $\\star\\star$ 1105. Filling Bookcase Shelves $\\star\\star$ 1106. Parsing A Boolean Expression $\\star\\star\\star$ 1107. New Users Daily Count $\\star\\star$ 1108. Defanging an IP Address $\\star$ 1109. Corporate Flight Bookings $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > corpFlightBookings ( vector < vector < int >>& bookings , int n ) { vector < int > ans ( n ); for ( vector < int >& booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ]; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ]; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ]; return ans ; } }; 1110. Delete Nodes And Return Forest $\\star\\star$","title":"1101-1110"},{"location":"cpp/1101-1200/1101-1110/#1101-the-earliest-moment-when-everyone-become-friends-starstar","text":"","title":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1102-path-with-maximum-minimum-value-starstar","text":"","title":"1102. Path With Maximum Minimum Value $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1103-distribute-candies-to-people-star","text":"","title":"1103. Distribute Candies to People $\\star$"},{"location":"cpp/1101-1200/1101-1110/#1104-path-in-zigzag-labelled-binary-tree-starstar","text":"","title":"1104. Path In Zigzag Labelled Binary Tree $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1105-filling-bookcase-shelves-starstar","text":"","title":"1105. Filling Bookcase Shelves $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1106-parsing-a-boolean-expression-starstarstar","text":"","title":"1106. Parsing A Boolean Expression $\\star\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1107-new-users-daily-count-starstar","text":"","title":"1107. New Users Daily Count $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1108-defanging-an-ip-address-star","text":"","title":"1108. Defanging an IP Address $\\star$"},{"location":"cpp/1101-1200/1101-1110/#1109-corporate-flight-bookings-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > corpFlightBookings ( vector < vector < int >>& bookings , int n ) { vector < int > ans ( n ); for ( vector < int >& booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ]; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ]; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ]; return ans ; } };","title":"1109. Corporate Flight Bookings $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1110-delete-nodes-and-return-forest-starstar","text":"","title":"1110. Delete Nodes And Return Forest $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/","text":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$ 1112. Highest Grade For Each Student $\\star\\star$ 1113. Reported Posts $\\star$ 1114. Print in Order $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Foo { public : Foo () { mutex2 . lock (); mutex3 . lock (); } void first ( function < void () > printFirst ) { printFirst (); mutex2 . unlock (); } void second ( function < void () > printSecond ) { mutex2 . lock (); printSecond (); mutex3 . unlock (); } void third ( function < void () > printThird ) { mutex3 . lock (); printThird (); } private : mutex mutex2 ; mutex mutex3 ; }; 1115. Print FooBar Alternately $\\star\\star$ 1116. Print Zero Even Odd $\\star\\star$ 1117. Building H2O $\\star\\star$ 1118. Number of Days in a Month $\\star$ 1119. Remove Vowels from a String $\\star$ 1120. Maximum Average Subtree $\\star\\star$","title":"1111-1120"},{"location":"cpp/1101-1200/1111-1120/#1111-maximum-nesting-depth-of-two-valid-parentheses-strings-starstar","text":"","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1112-highest-grade-for-each-student-starstar","text":"","title":"1112. Highest Grade For Each Student $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1113-reported-posts-star","text":"","title":"1113. Reported Posts $\\star$"},{"location":"cpp/1101-1200/1111-1120/#1114-print-in-order-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Foo { public : Foo () { mutex2 . lock (); mutex3 . lock (); } void first ( function < void () > printFirst ) { printFirst (); mutex2 . unlock (); } void second ( function < void () > printSecond ) { mutex2 . lock (); printSecond (); mutex3 . unlock (); } void third ( function < void () > printThird ) { mutex3 . lock (); printThird (); } private : mutex mutex2 ; mutex mutex3 ; };","title":"1114. Print in Order $\\star$"},{"location":"cpp/1101-1200/1111-1120/#1115-print-foobar-alternately-starstar","text":"","title":"1115. Print FooBar Alternately $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1116-print-zero-even-odd-starstar","text":"","title":"1116. Print Zero Even Odd $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1117-building-h2o-starstar","text":"","title":"1117. Building H2O $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1118-number-of-days-in-a-month-star","text":"","title":"1118. Number of Days in a Month $\\star$"},{"location":"cpp/1101-1200/1111-1120/#1119-remove-vowels-from-a-string-star","text":"","title":"1119. Remove Vowels from a String $\\star$"},{"location":"cpp/1101-1200/1111-1120/#1120-maximum-average-subtree-starstar","text":"","title":"1120. Maximum Average Subtree $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/","text":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$ 1122. Relative Sort Array $\\star$ 1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$ 1124. Longest Well-Performing Interval $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int longestWPI ( vector < int >& hours ) { int ans = 0 ; int presum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < hours . size (); ++ i ) { presum += hours [ i ] > 8 ? 1 : - 1 ; if ( presum > 0 ) { ans = i + 1 ; } else { if ( ! map . count ( presum )) map [ presum ] = i ; if ( map . count ( presum - 1 )) ans = max ( ans , i - map [ presum - 1 ]); } } return ans ; } }; 1125. Smallest Sufficient Team $\\star\\star\\star$ 1126. Active Businesses $\\star\\star$ 1127. User Purchase Platform $\\star\\star\\star$ 1128. Number of Equivalent Domino Pairs $\\star$ 1129. Shortest Path with Alternating Colors $\\star\\star$ 1130. Minimum Cost Tree From Leaf Values $\\star\\star$","title":"1121-1130"},{"location":"cpp/1101-1200/1121-1130/#1121-divide-array-into-increasing-sequences-starstarstar","text":"","title":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1122-relative-sort-array-star","text":"","title":"1122. Relative Sort Array $\\star$"},{"location":"cpp/1101-1200/1121-1130/#1123-lowest-common-ancestor-of-deepest-leaves-starstar","text":"","title":"1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1124-longest-well-performing-interval-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int longestWPI ( vector < int >& hours ) { int ans = 0 ; int presum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < hours . size (); ++ i ) { presum += hours [ i ] > 8 ? 1 : - 1 ; if ( presum > 0 ) { ans = i + 1 ; } else { if ( ! map . count ( presum )) map [ presum ] = i ; if ( map . count ( presum - 1 )) ans = max ( ans , i - map [ presum - 1 ]); } } return ans ; } };","title":"1124. Longest Well-Performing Interval $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1125-smallest-sufficient-team-starstarstar","text":"","title":"1125. Smallest Sufficient Team $\\star\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1126-active-businesses-starstar","text":"","title":"1126. Active Businesses $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1127-user-purchase-platform-starstarstar","text":"","title":"1127. User Purchase Platform $\\star\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1128-number-of-equivalent-domino-pairs-star","text":"","title":"1128. Number of Equivalent Domino Pairs $\\star$"},{"location":"cpp/1101-1200/1121-1130/#1129-shortest-path-with-alternating-colors-starstar","text":"","title":"1129. Shortest Path with Alternating Colors $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1130-minimum-cost-tree-from-leaf-values-starstar","text":"","title":"1130. Minimum Cost Tree From Leaf Values $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/","text":"1131. Maximum of Absolute Value Expression $\\star\\star$ 1132. Reported Posts II $\\star\\star$ 1133. Largest Unique Number $\\star$ 1134. Armstrong Number $\\star$ 1135. Connecting Cities With Minimum Cost $\\star\\star$ 1136. Parallel Courses $\\star\\star\\star$ 1137. N-th Tribonacci Number $\\star$ 1138. Alphabet Board Path $\\star\\star$ 1139. Largest 1-Bordered Square $\\star\\star$ 1140. Stone Game II $\\star\\star$","title":"1131-1140"},{"location":"cpp/1101-1200/1131-1140/#1131-maximum-of-absolute-value-expression-starstar","text":"","title":"1131. Maximum of Absolute Value Expression $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1132-reported-posts-ii-starstar","text":"","title":"1132. Reported Posts II $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1133-largest-unique-number-star","text":"","title":"1133. Largest Unique Number $\\star$"},{"location":"cpp/1101-1200/1131-1140/#1134-armstrong-number-star","text":"","title":"1134. Armstrong Number $\\star$"},{"location":"cpp/1101-1200/1131-1140/#1135-connecting-cities-with-minimum-cost-starstar","text":"","title":"1135. Connecting Cities With Minimum Cost $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1136-parallel-courses-starstarstar","text":"","title":"1136. Parallel Courses $\\star\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1137-n-th-tribonacci-number-star","text":"","title":"1137. N-th Tribonacci Number $\\star$"},{"location":"cpp/1101-1200/1131-1140/#1138-alphabet-board-path-starstar","text":"","title":"1138. Alphabet Board Path $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1139-largest-1-bordered-square-starstar","text":"","title":"1139. Largest 1-Bordered Square $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1140-stone-game-ii-starstar","text":"","title":"1140. Stone Game II $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/","text":"1141. User Activity for the Past 30 Days I $\\star$ 1142. User Activity for the Past 30 Days II $\\star$ 1143. Longest Common Subsequence $\\star\\star$ 1144. Decrease Elements To Make Array Zigzag $\\star\\star$ 1145. Binary Tree Coloring Game $\\star\\star$ 1146. Snapshot Array $\\star\\star$ 1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$ 1148. Article Views I $\\star$ 1149. Article Views II $\\star\\star$ 1150. Check If a Number Is Majority Element in a Sorted Array $\\star$","title":"1141-1150"},{"location":"cpp/1101-1200/1141-1150/#1141-user-activity-for-the-past-30-days-i-star","text":"","title":"1141. User Activity for the Past 30 Days I $\\star$"},{"location":"cpp/1101-1200/1141-1150/#1142-user-activity-for-the-past-30-days-ii-star","text":"","title":"1142. User Activity for the Past 30 Days II $\\star$"},{"location":"cpp/1101-1200/1141-1150/#1143-longest-common-subsequence-starstar","text":"","title":"1143. Longest Common Subsequence $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1144-decrease-elements-to-make-array-zigzag-starstar","text":"","title":"1144. Decrease Elements To Make Array Zigzag $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1145-binary-tree-coloring-game-starstar","text":"","title":"1145. Binary Tree Coloring Game $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1146-snapshot-array-starstar","text":"","title":"1146. Snapshot Array $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1147-longest-chunked-palindrome-decomposition-starstarstar","text":"","title":"1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1148-article-views-i-star","text":"","title":"1148. Article Views I $\\star$"},{"location":"cpp/1101-1200/1141-1150/#1149-article-views-ii-starstar","text":"","title":"1149. Article Views II $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1150-check-if-a-number-is-majority-element-in-a-sorted-array-star","text":"","title":"1150. Check If a Number Is Majority Element in a Sorted Array $\\star$"},{"location":"cpp/1101-1200/1151-1160/","text":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$ 1152. Analyze User Website Visit Pattern $\\star\\star$ 1153. String Transforms Into Another String $\\star\\star\\star$ 1154. Day of the Year $\\star$ 1155. Number of Dice Rolls With Target Sum $\\star\\star$ 1156. Swap For Longest Repeated Character Substring $\\star\\star$ 1157. Online Majority Element In Subarray $\\star\\star\\star$ 1158. Market Analysis I $\\star\\star$ 1159. Market Analysis II $\\star\\star\\star$ 1160. Find Words That Can Be Formed by Characters $\\star$","title":"1151-1160"},{"location":"cpp/1101-1200/1151-1160/#1151-minimum-swaps-to-group-all-1s-together-starstar","text":"","title":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1152-analyze-user-website-visit-pattern-starstar","text":"","title":"1152. Analyze User Website Visit Pattern $\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1153-string-transforms-into-another-string-starstarstar","text":"","title":"1153. String Transforms Into Another String $\\star\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1154-day-of-the-year-star","text":"","title":"1154. Day of the Year $\\star$"},{"location":"cpp/1101-1200/1151-1160/#1155-number-of-dice-rolls-with-target-sum-starstar","text":"","title":"1155. Number of Dice Rolls With Target Sum $\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1156-swap-for-longest-repeated-character-substring-starstar","text":"","title":"1156. Swap For Longest Repeated Character Substring $\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1157-online-majority-element-in-subarray-starstarstar","text":"","title":"1157. Online Majority Element In Subarray $\\star\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1158-market-analysis-i-starstar","text":"","title":"1158. Market Analysis I $\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1159-market-analysis-ii-starstarstar","text":"","title":"1159. Market Analysis II $\\star\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1160-find-words-that-can-be-formed-by-characters-star","text":"","title":"1160. Find Words That Can Be Formed by Characters $\\star$"},{"location":"cpp/1101-1200/1161-1170/","text":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$ 1162. As Far from Land as Possible $\\star\\star$ 1163. Last Substring in Lexicographical Order $\\star\\star\\star$ 1164. Product Price at a Given Date $\\star\\star$ 1165. Single-Row Keyboard $\\star$ 1166. Design File System $\\star\\star$ 1167. Minimum Cost to Connect Sticks $\\star\\star$ 1168. Optimize Water Distribution in a Village $\\star\\star\\star$ 1169. Invalid Transactions $\\star\\star$ 1170. Compare Strings by Frequency of the Smallest Character $\\star$","title":"1161-1170"},{"location":"cpp/1101-1200/1161-1170/#1161-maximum-level-sum-of-a-binary-tree-starstar","text":"","title":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1162-as-far-from-land-as-possible-starstar","text":"","title":"1162. As Far from Land as Possible $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1163-last-substring-in-lexicographical-order-starstarstar","text":"","title":"1163. Last Substring in Lexicographical Order $\\star\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1164-product-price-at-a-given-date-starstar","text":"","title":"1164. Product Price at a Given Date $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1165-single-row-keyboard-star","text":"","title":"1165. Single-Row Keyboard $\\star$"},{"location":"cpp/1101-1200/1161-1170/#1166-design-file-system-starstar","text":"","title":"1166. Design File System $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1167-minimum-cost-to-connect-sticks-starstar","text":"","title":"1167. Minimum Cost to Connect Sticks $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1168-optimize-water-distribution-in-a-village-starstarstar","text":"","title":"1168. Optimize Water Distribution in a Village $\\star\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1169-invalid-transactions-starstar","text":"","title":"1169. Invalid Transactions $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1170-compare-strings-by-frequency-of-the-smallest-character-star","text":"","title":"1170. Compare Strings by Frequency of the Smallest Character $\\star$"},{"location":"cpp/1101-1200/1171-1180/","text":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$ 1172. Dinner Plate Stacks $\\star\\star\\star$ 1173. Immediate Food Delivery I $\\star$ 1174. Immediate Food Delivery II $\\star\\star$ 1175. Prime Arrangements $\\star$ 1176. Diet Plan Performance $\\star$ 1177. Can Make Palindrome from Substring $\\star\\star$ 1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$ 1179. Reformat Department Table $\\star$ 1180. Count Substrings with Only One Distinct Letter $\\star$","title":"1171-1180"},{"location":"cpp/1101-1200/1171-1180/#1171-remove-zero-sum-consecutive-nodes-from-linked-list-starstar","text":"","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1172-dinner-plate-stacks-starstarstar","text":"","title":"1172. Dinner Plate Stacks $\\star\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1173-immediate-food-delivery-i-star","text":"","title":"1173. Immediate Food Delivery I $\\star$"},{"location":"cpp/1101-1200/1171-1180/#1174-immediate-food-delivery-ii-starstar","text":"","title":"1174. Immediate Food Delivery II $\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1175-prime-arrangements-star","text":"","title":"1175. Prime Arrangements $\\star$"},{"location":"cpp/1101-1200/1171-1180/#1176-diet-plan-performance-star","text":"","title":"1176. Diet Plan Performance $\\star$"},{"location":"cpp/1101-1200/1171-1180/#1177-can-make-palindrome-from-substring-starstar","text":"","title":"1177. Can Make Palindrome from Substring $\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1178-number-of-valid-words-for-each-puzzle-starstarstar","text":"","title":"1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1179-reformat-department-table-star","text":"","title":"1179. Reformat Department Table $\\star$"},{"location":"cpp/1101-1200/1171-1180/#1180-count-substrings-with-only-one-distinct-letter-star","text":"","title":"1180. Count Substrings with Only One Distinct Letter $\\star$"},{"location":"cpp/1101-1200/1181-1190/","text":"1181. Before and After Puzzle $\\star\\star$ 1182. Shortest Distance to Target Color $\\star\\star$ 1183. Maximum Number of Ones $\\star\\star\\star$ 1184. Distance Between Bus Stops $\\star$ 1185. Day of the Week $\\star$ 1186. Maximum Subarray Sum with One Deletion $\\star\\star$ 1187. Make Array Strictly Increasing $\\star\\star\\star$ 1188. Design Bounded Blocking Queue $\\star\\star$ 1189. Maximum Number of Balloons $\\star$ 1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$","title":"1181-1190"},{"location":"cpp/1101-1200/1181-1190/#1181-before-and-after-puzzle-starstar","text":"","title":"1181. Before and After Puzzle $\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1182-shortest-distance-to-target-color-starstar","text":"","title":"1182. Shortest Distance to Target Color $\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1183-maximum-number-of-ones-starstarstar","text":"","title":"1183. Maximum Number of Ones $\\star\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1184-distance-between-bus-stops-star","text":"","title":"1184. Distance Between Bus Stops $\\star$"},{"location":"cpp/1101-1200/1181-1190/#1185-day-of-the-week-star","text":"","title":"1185. Day of the Week $\\star$"},{"location":"cpp/1101-1200/1181-1190/#1186-maximum-subarray-sum-with-one-deletion-starstar","text":"","title":"1186. Maximum Subarray Sum with One Deletion $\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1187-make-array-strictly-increasing-starstarstar","text":"","title":"1187. Make Array Strictly Increasing $\\star\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1188-design-bounded-blocking-queue-starstar","text":"","title":"1188. Design Bounded Blocking Queue $\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1189-maximum-number-of-balloons-star","text":"","title":"1189. Maximum Number of Balloons $\\star$"},{"location":"cpp/1101-1200/1181-1190/#1190-reverse-substrings-between-each-pair-of-parentheses-starstar","text":"","title":"1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/","text":"1191. K-Concatenation Maximum Sum $\\star\\star$ 1192. Critical Connections in a Network $\\star\\star\\star$ 1193. Monthly Transactions I $\\star\\star$ 1194. Tournament Winners $\\star\\star\\star$ 1195. Fizz Buzz Multithreaded $\\star\\star$ 1196. How Many Apples Can You Put into the Basket $\\star$ 1197. Minimum Knight Moves $\\star\\star$ 1198. Find Smallest Common Element in All Rows $\\star\\star$ 1199. Minimum Time to Build Blocks $\\star\\star\\star$ 1200. Minimum Absolute Difference $\\star$","title":"1191-1200"},{"location":"cpp/1101-1200/1191-1200/#1191-k-concatenation-maximum-sum-starstar","text":"","title":"1191. K-Concatenation Maximum Sum $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1192-critical-connections-in-a-network-starstarstar","text":"","title":"1192. Critical Connections in a Network $\\star\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1193-monthly-transactions-i-starstar","text":"","title":"1193. Monthly Transactions I $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1194-tournament-winners-starstarstar","text":"","title":"1194. Tournament Winners $\\star\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1195-fizz-buzz-multithreaded-starstar","text":"","title":"1195. Fizz Buzz Multithreaded $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1196-how-many-apples-can-you-put-into-the-basket-star","text":"","title":"1196. How Many Apples Can You Put into the Basket $\\star$"},{"location":"cpp/1101-1200/1191-1200/#1197-minimum-knight-moves-starstar","text":"","title":"1197. Minimum Knight Moves $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1198-find-smallest-common-element-in-all-rows-starstar","text":"","title":"1198. Find Smallest Common Element in All Rows $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1199-minimum-time-to-build-blocks-starstarstar","text":"","title":"1199. Minimum Time to Build Blocks $\\star\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1200-minimum-absolute-difference-star","text":"","title":"1200. Minimum Absolute Difference $\\star$"},{"location":"cpp/1201-1300/1201-1210/","text":"1201. Ugly Number III $\\star\\star$ 1202. Smallest String With Swaps $\\star\\star$ 1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$ 1204. Last Person to Fit in the Elevator $\\star\\star$ 1205. Monthly Transactions II $\\star\\star$ 1206. Design Skiplist $\\star\\star\\star$ 1207. Unique Number of Occurrences $\\star$ 1208. Get Equal Substrings Within Budget $\\star\\star$ 1209. Remove All Adjacent Duplicates in String II $\\star\\star$ 1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$","title":"1201-1210"},{"location":"cpp/1201-1300/1201-1210/#1201-ugly-number-iii-starstar","text":"","title":"1201. Ugly Number III $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1202-smallest-string-with-swaps-starstar","text":"","title":"1202. Smallest String With Swaps $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1203-sort-items-by-groups-respecting-dependencies-starstarstar","text":"","title":"1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1204-last-person-to-fit-in-the-elevator-starstar","text":"","title":"1204. Last Person to Fit in the Elevator $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1205-monthly-transactions-ii-starstar","text":"","title":"1205. Monthly Transactions II $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1206-design-skiplist-starstarstar","text":"","title":"1206. Design Skiplist $\\star\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1207-unique-number-of-occurrences-star","text":"","title":"1207. Unique Number of Occurrences $\\star$"},{"location":"cpp/1201-1300/1201-1210/#1208-get-equal-substrings-within-budget-starstar","text":"","title":"1208. Get Equal Substrings Within Budget $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1209-remove-all-adjacent-duplicates-in-string-ii-starstar","text":"","title":"1209. Remove All Adjacent Duplicates in String II $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1210-minimum-moves-to-reach-target-with-rotations-starstarstar","text":"","title":"1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/","text":"1211. Queries Quality and Percentage $\\star$ 1212. Team Scores in Football Tournament $\\star\\star$ 1213. Intersection of Three Sorted Arrays $\\star$ 1214. Two Sum BSTs $\\star\\star$ 1215. Stepping Numbers $\\star\\star$ 1216. Valid Palindrome III $\\star\\star\\star$ 1217. Play with Chips $\\star$ 1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$ 1219. Path with Maximum Gold $\\star\\star$ 1220. Count Vowels Permutation $\\star\\star\\star$","title":"1211-1220"},{"location":"cpp/1201-1300/1211-1220/#1211-queries-quality-and-percentage-star","text":"","title":"1211. Queries Quality and Percentage $\\star$"},{"location":"cpp/1201-1300/1211-1220/#1212-team-scores-in-football-tournament-starstar","text":"","title":"1212. Team Scores in Football Tournament $\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1213-intersection-of-three-sorted-arrays-star","text":"","title":"1213. Intersection of Three Sorted Arrays $\\star$"},{"location":"cpp/1201-1300/1211-1220/#1214-two-sum-bsts-starstar","text":"","title":"1214. Two Sum BSTs $\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1215-stepping-numbers-starstar","text":"","title":"1215. Stepping Numbers $\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1216-valid-palindrome-iii-starstarstar","text":"","title":"1216. Valid Palindrome III $\\star\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1217-play-with-chips-star","text":"","title":"1217. Play with Chips $\\star$"},{"location":"cpp/1201-1300/1211-1220/#1218-longest-arithmetic-subsequence-of-given-difference-starstar","text":"","title":"1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1219-path-with-maximum-gold-starstar","text":"","title":"1219. Path with Maximum Gold $\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1220-count-vowels-permutation-starstarstar","text":"","title":"1220. Count Vowels Permutation $\\star\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/","text":"1221. Split a String in Balanced Strings $\\star$ 1222. Queens That Can Attack the King $\\star\\star$ 1223. Dice Roll Simulation $\\star\\star$ 1224. Maximum Equal Frequency $\\star\\star\\star$ 1225. Report Contiguous Dates $\\star\\star\\star$ 1226. The Dining Philosophers $\\star\\star$ 1227. Airplane Seat Assignment Probability $\\star\\star$ 1228. Missing Number In Arithmetic Progression $\\star$ 1229. Meeting Scheduler $\\star\\star$ 1230. Toss Strange Coins $\\star\\star$","title":"1221-1230"},{"location":"cpp/1201-1300/1221-1230/#1221-split-a-string-in-balanced-strings-star","text":"","title":"1221. Split a String in Balanced Strings $\\star$"},{"location":"cpp/1201-1300/1221-1230/#1222-queens-that-can-attack-the-king-starstar","text":"","title":"1222. Queens That Can Attack the King $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1223-dice-roll-simulation-starstar","text":"","title":"1223. Dice Roll Simulation $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1224-maximum-equal-frequency-starstarstar","text":"","title":"1224. Maximum Equal Frequency $\\star\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1225-report-contiguous-dates-starstarstar","text":"","title":"1225. Report Contiguous Dates $\\star\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1226-the-dining-philosophers-starstar","text":"","title":"1226. The Dining Philosophers $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1227-airplane-seat-assignment-probability-starstar","text":"","title":"1227. Airplane Seat Assignment Probability $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1228-missing-number-in-arithmetic-progression-star","text":"","title":"1228. Missing Number In Arithmetic Progression $\\star$"},{"location":"cpp/1201-1300/1221-1230/#1229-meeting-scheduler-starstar","text":"","title":"1229. Meeting Scheduler $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1230-toss-strange-coins-starstar","text":"","title":"1230. Toss Strange Coins $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/","text":"1231. Divide Chocolate $\\star\\star\\star$ 1232. Check If It Is a Straight Line $\\star$ 1233. Remove Sub-Folders from the Filesystem $\\star\\star$ 1234. Replace the Substring for Balanced String $\\star\\star$ 1235. Maximum Profit in Job Scheduling $\\star\\star\\star$ 1236. Web Crawler $\\star\\star$ 1237. Find Positive Integer Solution for a Given Equation $\\star$ 1238. Circular Permutation in Binary Representation $\\star\\star$ 1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$ 1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$","title":"1231-1240"},{"location":"cpp/1201-1300/1231-1240/#1231-divide-chocolate-starstarstar","text":"","title":"1231. Divide Chocolate $\\star\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1232-check-if-it-is-a-straight-line-star","text":"","title":"1232. Check If It Is a Straight Line $\\star$"},{"location":"cpp/1201-1300/1231-1240/#1233-remove-sub-folders-from-the-filesystem-starstar","text":"","title":"1233. Remove Sub-Folders from the Filesystem $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1234-replace-the-substring-for-balanced-string-starstar","text":"","title":"1234. Replace the Substring for Balanced String $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1235-maximum-profit-in-job-scheduling-starstarstar","text":"","title":"1235. Maximum Profit in Job Scheduling $\\star\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1236-web-crawler-starstar","text":"","title":"1236. Web Crawler $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1237-find-positive-integer-solution-for-a-given-equation-star","text":"","title":"1237. Find Positive Integer Solution for a Given Equation $\\star$"},{"location":"cpp/1201-1300/1231-1240/#1238-circular-permutation-in-binary-representation-starstar","text":"","title":"1238. Circular Permutation in Binary Representation $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1239-maximum-length-of-a-concatenated-string-with-unique-characters-starstar","text":"","title":"1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1240-tiling-a-rectangle-with-the-fewest-squares-starstarstar","text":"","title":"1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/","text":"1241. Number of Comments per Post $\\star$ 1242. Web Crawler Multithreaded $\\star\\star$ 1243. Array Transformation $\\star$ 1244. Design A Leaderboard $\\star\\star$ 1245. Tree Diameter $\\star\\star$ 1246. Palindrome Removal $\\star\\star\\star$ 1247. Minimum Swaps to Make Strings Equal $\\star\\star$ 1248. Count Number of Nice Subarrays $\\star\\star$ 1249. Minimum Remove to Make Valid Parentheses $\\star\\star$ 1250. Check If It Is a Good Array $\\star\\star\\star$","title":"1241-1250"},{"location":"cpp/1201-1300/1241-1250/#1241-number-of-comments-per-post-star","text":"","title":"1241. Number of Comments per Post $\\star$"},{"location":"cpp/1201-1300/1241-1250/#1242-web-crawler-multithreaded-starstar","text":"","title":"1242. Web Crawler Multithreaded $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1243-array-transformation-star","text":"","title":"1243. Array Transformation $\\star$"},{"location":"cpp/1201-1300/1241-1250/#1244-design-a-leaderboard-starstar","text":"","title":"1244. Design A Leaderboard $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1245-tree-diameter-starstar","text":"","title":"1245. Tree Diameter $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1246-palindrome-removal-starstarstar","text":"","title":"1246. Palindrome Removal $\\star\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1247-minimum-swaps-to-make-strings-equal-starstar","text":"","title":"1247. Minimum Swaps to Make Strings Equal $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1248-count-number-of-nice-subarrays-starstar","text":"","title":"1248. Count Number of Nice Subarrays $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1249-minimum-remove-to-make-valid-parentheses-starstar","text":"","title":"1249. Minimum Remove to Make Valid Parentheses $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1250-check-if-it-is-a-good-array-starstarstar","text":"","title":"1250. Check If It Is a Good Array $\\star\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/","text":"1251. Average Selling Price $\\star$ 1252. Cells with Odd Values in a Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int oddCells ( int n , int m , vector < vector < int >>& indices ) { int ans = 0 ; vector < int > rows ( n ); vector < int > cols ( m ); for ( vector < int >& indice : indices ) { rows [ indice [ 0 ]] ^= 1 ; cols [ indice [ 1 ]] ^= 1 ; } for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) ans += rows [ i ] ^ cols [ j ]; return ans ; } }; 1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$ 1254. Number of Closed Islands $\\star\\star$ 1255. Maximum Score Words Formed by Letters $\\star\\star\\star$ 1256. Encode Number $\\star\\star$ 1257. Smallest Common Region $\\star\\star$ 1258. Synonymous Sentences $\\star\\star$ 1259. Handshakes That Don't Cross $\\star\\star\\star$ 1260. Shift 2D Grid $\\star$","title":"1251-1260"},{"location":"cpp/1201-1300/1251-1260/#1251-average-selling-price-star","text":"","title":"1251. Average Selling Price $\\star$"},{"location":"cpp/1201-1300/1251-1260/#1252-cells-with-odd-values-in-a-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int oddCells ( int n , int m , vector < vector < int >>& indices ) { int ans = 0 ; vector < int > rows ( n ); vector < int > cols ( m ); for ( vector < int >& indice : indices ) { rows [ indice [ 0 ]] ^= 1 ; cols [ indice [ 1 ]] ^= 1 ; } for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) ans += rows [ i ] ^ cols [ j ]; return ans ; } };","title":"1252. Cells with Odd Values in a Matrix $\\star$"},{"location":"cpp/1201-1300/1251-1260/#1253-reconstruct-a-2-row-binary-matrix-starstar","text":"","title":"1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1254-number-of-closed-islands-starstar","text":"","title":"1254. Number of Closed Islands $\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1255-maximum-score-words-formed-by-letters-starstarstar","text":"","title":"1255. Maximum Score Words Formed by Letters $\\star\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1256-encode-number-starstar","text":"","title":"1256. Encode Number $\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1257-smallest-common-region-starstar","text":"","title":"1257. Smallest Common Region $\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1258-synonymous-sentences-starstar","text":"","title":"1258. Synonymous Sentences $\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1259-handshakes-that-dont-cross-starstarstar","text":"","title":"1259. Handshakes That Don't Cross $\\star\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1260-shift-2d-grid-star","text":"","title":"1260. Shift 2D Grid $\\star$"},{"location":"cpp/1201-1300/1261-1270/","text":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$ 1262. Greatest Sum Divisible by Three $\\star\\star$ 1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$ 1264. Page Recommendations $\\star\\star$ 1265. Print Immutable Linked List in Reverse $\\star\\star$ 1266. Minimum Time Visiting All Points $\\star$ 1267. Count Servers that Communicate $\\star\\star$ 1268. Search Suggestions System $\\star\\star$ 1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$ 1270. All People Report to the Given Manager $\\star\\star$","title":"1261-1270"},{"location":"cpp/1201-1300/1261-1270/#1261-find-elements-in-a-contaminated-binary-tree-starstar","text":"","title":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1262-greatest-sum-divisible-by-three-starstar","text":"","title":"1262. Greatest Sum Divisible by Three $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1263-minimum-moves-to-move-a-box-to-their-target-location-starstarstar","text":"","title":"1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1264-page-recommendations-starstar","text":"","title":"1264. Page Recommendations $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1265-print-immutable-linked-list-in-reverse-starstar","text":"","title":"1265. Print Immutable Linked List in Reverse $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1266-minimum-time-visiting-all-points-star","text":"","title":"1266. Minimum Time Visiting All Points $\\star$"},{"location":"cpp/1201-1300/1261-1270/#1267-count-servers-that-communicate-starstar","text":"","title":"1267. Count Servers that Communicate $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1268-search-suggestions-system-starstar","text":"","title":"1268. Search Suggestions System $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps-starstarstar","text":"","title":"1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1270-all-people-report-to-the-given-manager-starstar","text":"","title":"1270. All People Report to the Given Manager $\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/","text":"1271. Hexspeak $\\star$ 1272. Remove Interval $\\star\\star$ 1273. Delete Tree Nodes $\\star\\star$ 1274. Number of Ships in a Rectangle $\\star\\star\\star$ 1275. Find Winner on a Tic Tac Toe Game $\\star$ 1276. Number of Burgers with No Waste of Ingredients $\\star\\star$ 1277. Count Square Submatrices with All Ones $\\star\\star$ 1278. Palindrome Partitioning III $\\star\\star\\star$ 1279. Traffic Light Controlled Intersection $\\star$ 1280. Students and Examinations $\\star$","title":"1271-1280"},{"location":"cpp/1201-1300/1271-1280/#1271-hexspeak-star","text":"","title":"1271. Hexspeak $\\star$"},{"location":"cpp/1201-1300/1271-1280/#1272-remove-interval-starstar","text":"","title":"1272. Remove Interval $\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1273-delete-tree-nodes-starstar","text":"","title":"1273. Delete Tree Nodes $\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1274-number-of-ships-in-a-rectangle-starstarstar","text":"","title":"1274. Number of Ships in a Rectangle $\\star\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1275-find-winner-on-a-tic-tac-toe-game-star","text":"","title":"1275. Find Winner on a Tic Tac Toe Game $\\star$"},{"location":"cpp/1201-1300/1271-1280/#1276-number-of-burgers-with-no-waste-of-ingredients-starstar","text":"","title":"1276. Number of Burgers with No Waste of Ingredients $\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1277-count-square-submatrices-with-all-ones-starstar","text":"","title":"1277. Count Square Submatrices with All Ones $\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1278-palindrome-partitioning-iii-starstarstar","text":"","title":"1278. Palindrome Partitioning III $\\star\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1279-traffic-light-controlled-intersection-star","text":"","title":"1279. Traffic Light Controlled Intersection $\\star$"},{"location":"cpp/1201-1300/1271-1280/#1280-students-and-examinations-star","text":"","title":"1280. Students and Examinations $\\star$"},{"location":"cpp/1201-1300/1281-1290/","text":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$ 1282. Group the People Given the Group Size They Belong To $\\star\\star$ 1283. Find the Smallest Divisor Given a Threshold $\\star\\star$ 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$ 1285. Find the Start and End Number of Continuous Ranges $\\star\\star$ 1286. Iterator for Combination $\\star\\star$ 1287. Element Appearing More Than 25% In Sorted Array $\\star$ 1288. Remove Covered Intervals $\\star\\star$ 1289. Minimum Falling Path Sum II $\\star\\star\\star$ 1290. Convert Binary Number in a Linked List to Integer $\\star$","title":"1281-1290"},{"location":"cpp/1201-1300/1281-1290/#1281-subtract-the-product-and-sum-of-digits-of-an-integer-star","text":"","title":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$"},{"location":"cpp/1201-1300/1281-1290/#1282-group-the-people-given-the-group-size-they-belong-to-starstar","text":"","title":"1282. Group the People Given the Group Size They Belong To $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1283-find-the-smallest-divisor-given-a-threshold-starstar","text":"","title":"1283. Find the Smallest Divisor Given a Threshold $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1284-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix-starstarstar","text":"","title":"1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1285-find-the-start-and-end-number-of-continuous-ranges-starstar","text":"","title":"1285. Find the Start and End Number of Continuous Ranges $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1286-iterator-for-combination-starstar","text":"","title":"1286. Iterator for Combination $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1287-element-appearing-more-than-25-in-sorted-array-star","text":"","title":"1287. Element Appearing More Than 25% In Sorted Array $\\star$"},{"location":"cpp/1201-1300/1281-1290/#1288-remove-covered-intervals-starstar","text":"","title":"1288. Remove Covered Intervals $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1289-minimum-falling-path-sum-ii-starstarstar","text":"","title":"1289. Minimum Falling Path Sum II $\\star\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1290-convert-binary-number-in-a-linked-list-to-integer-star","text":"","title":"1290. Convert Binary Number in a Linked List to Integer $\\star$"},{"location":"cpp/1201-1300/1291-1300/","text":"1291. Sequential Digits $\\star\\star$ 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$ 1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$ 1294. Weather Type in Each Country $\\star$ 1295. Find Numbers with Even Number of Digits $\\star$ 1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$ 1297. Maximum Number of Occurrences of a Substring $\\star\\star$ 1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$ 1299. Replace Elements with Greatest Element on Right Side $\\star$ 1300. Sum of Mutated Array Closest to Target $\\star\\star$","title":"1291-1300"},{"location":"cpp/1201-1300/1291-1300/#1291-sequential-digits-starstar","text":"","title":"1291. Sequential Digits $\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold-starstar","text":"","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1293-shortest-path-in-a-grid-with-obstacles-elimination-starstarstar","text":"","title":"1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1294-weather-type-in-each-country-star","text":"","title":"1294. Weather Type in Each Country $\\star$"},{"location":"cpp/1201-1300/1291-1300/#1295-find-numbers-with-even-number-of-digits-star","text":"","title":"1295. Find Numbers with Even Number of Digits $\\star$"},{"location":"cpp/1201-1300/1291-1300/#1296-divide-array-in-sets-of-k-consecutive-numbers-starstar","text":"","title":"1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1297-maximum-number-of-occurrences-of-a-substring-starstar","text":"","title":"1297. Maximum Number of Occurrences of a Substring $\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1298-maximum-candies-you-can-get-from-boxes-starstarstar","text":"","title":"1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1299-replace-elements-with-greatest-element-on-right-side-star","text":"","title":"1299. Replace Elements with Greatest Element on Right Side $\\star$"},{"location":"cpp/1201-1300/1291-1300/#1300-sum-of-mutated-array-closest-to-target-starstar","text":"","title":"1300. Sum of Mutated Array Closest to Target $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/","text":"1301. Number of Paths with Max Score $\\star\\star\\star$ 1302. Deepest Leaves Sum $\\star\\star$ 1303. Find the Team Size $\\star$ 1304. Find N Unique Integers Sum up to Zero $\\star$ 1305. All Elements in Two Binary Search Trees $\\star\\star$ 1306. Jump Game III $\\star\\star$ 1307. Verbal Arithmetic Puzzle $\\star\\star\\star$ 1308. Running Total for Different Genders $\\star\\star$ 1309. Decrypt String from Alphabet to Integer Mapping $\\star$ 1310. XOR Queries of a Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > xorQueries ( vector < int >& arr , vector < vector < int >>& queries ) { vector < int > ans ; vector < int > xors ( arr . size () + 1 ); for ( int i = 0 ; i < arr . size (); ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ]; for ( vector < int >& query : queries ) ans . push_back ( xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ]); return ans ; } };","title":"1301-1310"},{"location":"cpp/1301-1400/1301-1310/#1301-number-of-paths-with-max-score-starstarstar","text":"","title":"1301. Number of Paths with Max Score $\\star\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1302-deepest-leaves-sum-starstar","text":"","title":"1302. Deepest Leaves Sum $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1303-find-the-team-size-star","text":"","title":"1303. Find the Team Size $\\star$"},{"location":"cpp/1301-1400/1301-1310/#1304-find-n-unique-integers-sum-up-to-zero-star","text":"","title":"1304. Find N Unique Integers Sum up to Zero $\\star$"},{"location":"cpp/1301-1400/1301-1310/#1305-all-elements-in-two-binary-search-trees-starstar","text":"","title":"1305. All Elements in Two Binary Search Trees $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1306-jump-game-iii-starstar","text":"","title":"1306. Jump Game III $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1307-verbal-arithmetic-puzzle-starstarstar","text":"","title":"1307. Verbal Arithmetic Puzzle $\\star\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1308-running-total-for-different-genders-starstar","text":"","title":"1308. Running Total for Different Genders $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1309-decrypt-string-from-alphabet-to-integer-mapping-star","text":"","title":"1309. Decrypt String from Alphabet to Integer Mapping $\\star$"},{"location":"cpp/1301-1400/1301-1310/#1310-xor-queries-of-a-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > xorQueries ( vector < int >& arr , vector < vector < int >>& queries ) { vector < int > ans ; vector < int > xors ( arr . size () + 1 ); for ( int i = 0 ; i < arr . size (); ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ]; for ( vector < int >& query : queries ) ans . push_back ( xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ]); return ans ; } };","title":"1310. XOR Queries of a Subarray $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/","text":"1311. Get Watched Videos by Your Friends $\\star\\star$ 1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$ 1313. Decompress Run-Length Encoded List $\\star$ 1314. Matrix Block Sum $\\star\\star$ 1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$ 1316. Distinct Echo Substrings $\\star\\star\\star$ 1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$ 1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$ 1319. Number of Operations to Make Network Connected $\\star\\star$ 1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$","title":"1311-1320"},{"location":"cpp/1301-1400/1311-1320/#1311-get-watched-videos-by-your-friends-starstar","text":"","title":"1311. Get Watched Videos by Your Friends $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1312-minimum-insertion-steps-to-make-a-string-palindrome-starstarstar","text":"","title":"1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1313-decompress-run-length-encoded-list-star","text":"","title":"1313. Decompress Run-Length Encoded List $\\star$"},{"location":"cpp/1301-1400/1311-1320/#1314-matrix-block-sum-starstar","text":"","title":"1314. Matrix Block Sum $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1315-sum-of-nodes-with-even-valued-grandparent-starstar","text":"","title":"1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1316-distinct-echo-substrings-starstarstar","text":"","title":"1316. Distinct Echo Substrings $\\star\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1317-convert-integer-to-the-sum-of-two-no-zero-integers-star","text":"","title":"1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$"},{"location":"cpp/1301-1400/1311-1320/#1318-minimum-flips-to-make-a-or-b-equal-to-c-starstar","text":"","title":"1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1319-number-of-operations-to-make-network-connected-starstar","text":"","title":"1319. Number of Operations to Make Network Connected $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1320-minimum-distance-to-type-a-word-using-two-fingers-starstarstar","text":"","title":"1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$"},{"location":"cpp/1301-1400/1321-1330/","text":"1321. Restaurant Growth $\\star\\star$ 1322. Ads Performance $\\star$ 1323. Maximum 69 Number $\\star$ 1324. Print Words Vertically $\\star\\star$ 1325. Delete Leaves With a Given Value $\\star\\star$ 1326. Minimum Number of Taps to Open to Water a Garden $\\star\\star\\star$","title":"1321-1321"},{"location":"cpp/1301-1400/1321-1330/#1321-restaurant-growth-starstar","text":"","title":"1321. Restaurant Growth $\\star\\star$"},{"location":"cpp/1301-1400/1321-1330/#1322-ads-performance-star","text":"","title":"1322. Ads Performance $\\star$"},{"location":"cpp/1301-1400/1321-1330/#1323-maximum-69-number-star","text":"","title":"1323. Maximum 69 Number $\\star$"},{"location":"cpp/1301-1400/1321-1330/#1324-print-words-vertically-starstar","text":"","title":"1324. Print Words Vertically $\\star\\star$"},{"location":"cpp/1301-1400/1321-1330/#1325-delete-leaves-with-a-given-value-starstar","text":"","title":"1325. Delete Leaves With a Given Value $\\star\\star$"},{"location":"cpp/1301-1400/1321-1330/#1326-minimum-number-of-taps-to-open-to-water-a-garden-starstarstar","text":"","title":"1326. Minimum Number of Taps to Open to Water a Garden $\\star\\star\\star$"},{"location":"golang/","text":"LeetCode in Golang","title":"Preface"},{"location":"golang/#leetcode-in-golang","text":"","title":"LeetCode in Golang"},{"location":"golang/0001-0100/0001-0010/","text":"1. Two Sum $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( map . count ( nums [ i ])) return { map [ nums [ i ]], i }; map [ target - nums [ i ]] = i ; } throw ; } }; 2. Add Two Numbers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; int carry = 0 ; while ( carry || l1 || l2 ) { carry += ( l1 ? l1 -> val : 0 ) + ( l2 ? l2 -> val : 0 ); curr -> next = new ListNode ( carry % 10 ); curr = curr -> next ; carry /= 10 ; if ( l1 ) l1 = l1 -> next ; if ( l2 ) l2 = l2 -> next ; } return dummy . next ; } }; 3. Longest Substring Without Repeating Characters $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int lengthOfLongestSubstring ( string s ) { int ans = 0 ; unordered_map < char , int > map ; int j = 0 ; for ( int i = 0 ; i < s . size (); ++ i ) { char c = s [ i ]; if ( map . count ( c )) j = max ( j , map [ c ]); ans = max ( ans , i - j + 1 ); map [ c ] = i + 1 ; } return ans ; } }; 4. Median of Two Sorted Arrays $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { const int n1 = nums1 . size (); const int n2 = nums2 . size (); if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { int partition1 = l + ( r - l ) / 2 ; int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; int maxLeft1 = partition1 == 0 ? INT_MIN : nums1 [ partition1 - 1 ]; int maxLeft2 = partition2 == 0 ? INT_MIN : nums2 [ partition2 - 1 ]; int minRight1 = partition1 == n1 ? INT_MAX : nums1 [ partition1 ]; int minRight2 = partition2 == n2 ? INT_MAX : nums2 [ partition2 ]; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 : max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw ; } }; 5. Longest Palindromic Substring $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : string longestPalindrome ( string s ) { const int length = s . length () * 2 + 3 ; // Manacher's Algorithm string T ( length , '#' ); T [ 0 ] = '$' ; T [ length - 1 ] = '@' ; for ( int i = 2 ; i < length - 2 ; i += 2 ) T [ i ] = s [ i / 2 - 1 ]; int center = 1 ; int right = 1 ; vector < int > P ( length , 0 ); for ( int i = 1 ; i < length - 1 ; ++ i ) { int mirr = 2 * center - i ; if ( i < right ) P [ i ] = min ( P [ mirr ], right - i ); while ( T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]) ++ P [ i ]; if ( i + P [ i ] > right ) { center = i ; right = i + P [ i ]; } } // find max and the center; int max = 0 ; int c = 0 ; for ( int i = 0 ; i < length ; ++ i ) if ( P [ i ] > max ) { max = P [ i ]; c = i ; } // omit '#' and get the string desired string ans ( max , '#' ); int i = 0 ; for ( int j = c - max + 1 ; j < c + max ; j += 2 ) { ans [ i ] = T [ j ]; ++ i ; } return ans ; } }; 6. ZigZag Conversion $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string convert ( string s , int numRows ) { string ans ( s ); vector < vector < char >> rows ( numRows ); int k = 0 ; int direction = ( numRows == 1 ) - 1 ; for ( char c : s ) { rows [ k ]. push_back ( c ); if ( k == 0 || k == numRows - 1 ) direction *= - 1 ; k += direction ; } k = 0 ; for ( int i = 0 ; i < numRows ; ++ i ) for ( int j = 0 ; j < rows [ i ]. size (); ++ j ) ans [ k ++ ] = rows [ i ][ j ]; return ans ; } }; 7. Reverse Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int reverse ( int x ) { long ans = 0 ; while ( x ) { ans = ans * 10 + x % 10 ; x /= 10 ; } if ( ans < INT_MIN || ans > INT_MAX ) return 0 ; return ans ; } }; 8. String to Integer (atoi) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int myAtoi ( string str ) { long long ans = 0 ; bool isNegative = false ; int j = 0 ; while ( j < str . size () && str [ j ] == ' ' ) ++ j ; if ( j == str . size ()) return 0 ; if ( str [ j ] == '-' ) { isNegative = true ; ++ j ; } else if ( str [ j ] == '+' ) { ++ j ; } for ( int i = j ; i < str . size (); ++ i ) { if ( str [ i ] < '0' || str [ i ] > '9' ) break ; else { ans = ans * 10 + ( str [ i ] - '0' ); if ( isNegative && - ans <= INT_MIN ) return INT_MIN ; if ( ! isNegative && ans >= INT_MAX ) return INT_MAX ; } } return isNegative ? - ans : ans ; } }; 9. Palindrome Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ans == x ; } }; 10. Regular Expression Matching $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isMatch ( string s , string p ) { if ( p . empty ()) return s . empty (); bool isFirstMatch = ( ! s . empty () && ( p [ 0 ] == s [ 0 ] || p [ 0 ] == '.' )); if ( p . length () >= 2 && p [ 1 ] == '*' ) return ( isMatch ( s , p . substr ( 2 )) || ( isFirstMatch && isMatch ( s . substr ( 1 ), p ))); return isFirstMatch && isMatch ( s . substr ( 1 ), p . substr ( 1 )); } };","title":"0001-0010"},{"location":"golang/0001-0100/0001-0010/#1-two-sum-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( map . count ( nums [ i ])) return { map [ nums [ i ]], i }; map [ target - nums [ i ]] = i ; } throw ; } };","title":"1. Two Sum $\\star$"},{"location":"golang/0001-0100/0001-0010/#2-add-two-numbers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; int carry = 0 ; while ( carry || l1 || l2 ) { carry += ( l1 ? l1 -> val : 0 ) + ( l2 ? l2 -> val : 0 ); curr -> next = new ListNode ( carry % 10 ); curr = curr -> next ; carry /= 10 ; if ( l1 ) l1 = l1 -> next ; if ( l2 ) l2 = l2 -> next ; } return dummy . next ; } };","title":"2. Add Two Numbers $\\star\\star$"},{"location":"golang/0001-0100/0001-0010/#3-longest-substring-without-repeating-characters-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int lengthOfLongestSubstring ( string s ) { int ans = 0 ; unordered_map < char , int > map ; int j = 0 ; for ( int i = 0 ; i < s . size (); ++ i ) { char c = s [ i ]; if ( map . count ( c )) j = max ( j , map [ c ]); ans = max ( ans , i - j + 1 ); map [ c ] = i + 1 ; } return ans ; } };","title":"3. Longest Substring Without Repeating Characters $\\star\\star$"},{"location":"golang/0001-0100/0001-0010/#4-median-of-two-sorted-arrays-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { const int n1 = nums1 . size (); const int n2 = nums2 . size (); if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { int partition1 = l + ( r - l ) / 2 ; int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; int maxLeft1 = partition1 == 0 ? INT_MIN : nums1 [ partition1 - 1 ]; int maxLeft2 = partition2 == 0 ? INT_MIN : nums2 [ partition2 - 1 ]; int minRight1 = partition1 == n1 ? INT_MAX : nums1 [ partition1 ]; int minRight2 = partition2 == n2 ? INT_MAX : nums2 [ partition2 ]; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 : max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw ; } };","title":"4. Median of Two Sorted Arrays $\\star\\star\\star$"},{"location":"golang/0001-0100/0001-0010/#5-longest-palindromic-substring-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : string longestPalindrome ( string s ) { const int length = s . length () * 2 + 3 ; // Manacher's Algorithm string T ( length , '#' ); T [ 0 ] = '$' ; T [ length - 1 ] = '@' ; for ( int i = 2 ; i < length - 2 ; i += 2 ) T [ i ] = s [ i / 2 - 1 ]; int center = 1 ; int right = 1 ; vector < int > P ( length , 0 ); for ( int i = 1 ; i < length - 1 ; ++ i ) { int mirr = 2 * center - i ; if ( i < right ) P [ i ] = min ( P [ mirr ], right - i ); while ( T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]) ++ P [ i ]; if ( i + P [ i ] > right ) { center = i ; right = i + P [ i ]; } } // find max and the center; int max = 0 ; int c = 0 ; for ( int i = 0 ; i < length ; ++ i ) if ( P [ i ] > max ) { max = P [ i ]; c = i ; } // omit '#' and get the string desired string ans ( max , '#' ); int i = 0 ; for ( int j = c - max + 1 ; j < c + max ; j += 2 ) { ans [ i ] = T [ j ]; ++ i ; } return ans ; } };","title":"5. Longest Palindromic Substring $\\star\\star$"},{"location":"golang/0001-0100/0001-0010/#6-zigzag-conversion-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string convert ( string s , int numRows ) { string ans ( s ); vector < vector < char >> rows ( numRows ); int k = 0 ; int direction = ( numRows == 1 ) - 1 ; for ( char c : s ) { rows [ k ]. push_back ( c ); if ( k == 0 || k == numRows - 1 ) direction *= - 1 ; k += direction ; } k = 0 ; for ( int i = 0 ; i < numRows ; ++ i ) for ( int j = 0 ; j < rows [ i ]. size (); ++ j ) ans [ k ++ ] = rows [ i ][ j ]; return ans ; } };","title":"6. ZigZag Conversion $\\star\\star$"},{"location":"golang/0001-0100/0001-0010/#7-reverse-integer-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int reverse ( int x ) { long ans = 0 ; while ( x ) { ans = ans * 10 + x % 10 ; x /= 10 ; } if ( ans < INT_MIN || ans > INT_MAX ) return 0 ; return ans ; } };","title":"7. Reverse Integer $\\star$"},{"location":"golang/0001-0100/0001-0010/#8-string-to-integer-atoi-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int myAtoi ( string str ) { long long ans = 0 ; bool isNegative = false ; int j = 0 ; while ( j < str . size () && str [ j ] == ' ' ) ++ j ; if ( j == str . size ()) return 0 ; if ( str [ j ] == '-' ) { isNegative = true ; ++ j ; } else if ( str [ j ] == '+' ) { ++ j ; } for ( int i = j ; i < str . size (); ++ i ) { if ( str [ i ] < '0' || str [ i ] > '9' ) break ; else { ans = ans * 10 + ( str [ i ] - '0' ); if ( isNegative && - ans <= INT_MIN ) return INT_MIN ; if ( ! isNegative && ans >= INT_MAX ) return INT_MAX ; } } return isNegative ? - ans : ans ; } };","title":"8. String to Integer (atoi) $\\star\\star$"},{"location":"golang/0001-0100/0001-0010/#9-palindrome-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ans == x ; } };","title":"9. Palindrome Number $\\star$"},{"location":"golang/0001-0100/0001-0010/#10-regular-expression-matching-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isMatch ( string s , string p ) { if ( p . empty ()) return s . empty (); bool isFirstMatch = ( ! s . empty () && ( p [ 0 ] == s [ 0 ] || p [ 0 ] == '.' )); if ( p . length () >= 2 && p [ 1 ] == '*' ) return ( isMatch ( s , p . substr ( 2 )) || ( isFirstMatch && isMatch ( s . substr ( 1 ), p ))); return isFirstMatch && isMatch ( s . substr ( 1 ), p . substr ( 1 )); } };","title":"10. Regular Expression Matching $\\star\\star\\star$"},{"location":"golang/0001-0100/0011-0020/","text":"11. Container With Most Water $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxArea ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; while ( l < r ) { int h = min ( height [ l ], height [ r ]); ans = max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) ++ l ; while ( height [ r ] <= h && l < r ) -- r ; } return ans ; } }; 12. Integer to Roman $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : string intToRoman ( int num ) { string M [ 4 ] = { \"\" , \"M\" , \"MM\" , \"MMM\" }; string C [ 10 ] = { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; string X [ 10 ] = { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; string I [ 10 ] = { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ]; } }; 13. Roman to Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int romanToInt ( string s ) { int ans = 0 ; unordered_map < char , int > map = {{ 'I' , 1 }, { 'V' , 5 }, { 'X' , 10 }, { 'L' , 50 }, { 'C' , 100 }, { 'D' , 500 }, { 'M' , 1000 }}; for ( int i = 0 ; i < s . size (); ++ i ) { if ( map [ s [ i ]] < map [ s [ i + 1 ]]) ans -= map [ s [ i ]]; else ans += map [ s [ i ]]; } return ans ; } }; 14. Longest Common Prefix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { if ( strs . size () == 0 ) return \"\" ; if ( strs . size () == 1 ) return strs [ 0 ]; string ans ; int min = strs [ 0 ]. length (); bool isMatch = true ; for ( int i = 1 ; i < strs . size (); ++ i ) min = std :: min ( min , ( int ) strs [ i ]. length ()); for ( int i = 0 ; i < min ; ++ i ) { char c = strs [ 0 ][ i ]; for ( int j = 1 ; j < strs . size (); ++ j ) if ( c != strs [ j ][ i ]) { isMatch = false ; break ; } if ( ! isMatch ) break ; ans += c ; } return ans ; } }; 15. 3Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { vector < vector < int >> ans ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == 0 ) { ans . push_back ({ nums [ i ], nums [ l ], nums [ r ]}); ++ l ; -- r ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; while ( nums [ r ] == nums [ r + 1 ] && l < r ) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } }; 16. 3Sum Closest $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ]; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == target ) return sum ; if ( abs ( sum - target ) < abs ( ans - target )) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } }; 17. Letter Combinations of a Phone Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > letterCombinations ( string digits ) { if ( digits . empty ()) return {}; vector < string > ans = { \"\" }; unordered_map < char , string > map = { { '2' , \"abc\" }, { '3' , \"def\" }, { '4' , \"ghi\" }, { '5' , \"jkl\" }, { '6' , \"mno\" }, { '7' , \"pqrs\" }, { '8' , \"tuv\" }, { '9' , \"wxyz\" }}; for ( char i : digits ) { vector < string > tmp ; for ( string & j : ans ) for ( char k : map [ i ]) tmp . push_back ( j + k ); ans = tmp ; } return ans ; } }; 18. 4Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( nums . begin (), nums . end ()); nSum ( nums , target , 0 , nums . size () - 1 , 4 , path , ans ); return ans ; } private : void nSum ( vector < int >& nums , int target , int l , int r , int n , vector < int >& path , vector < vector < int >>& ans ) { if ( r - l + 1 < n || n < 2 || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == target ) { path . push_back ( nums [ l ]); path . push_back ( nums [ r ]); ans . push_back ( path ); path . pop_back (); path . pop_back (); ++ l ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); nSum ( nums , target - nums [ i ], i + 1 , r , n - 1 , path , ans ); path . pop_back (); } } }; 19. Remove Nth Node From End of List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { auto slow = head ; auto fast = head ; while ( n -- ) fast = fast -> next ; if ( ! fast ) return head -> next ; while ( fast -> next ) { slow = slow -> next ; fast = fast -> next ; } slow -> next = slow -> next -> next ; return head ; } }; 20. Valid Parentheses $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool isValid ( string s ) { stack < char > stack ; for ( char c : s ) { if ( c == '(' || c == '{' || c == '[' ) { stack . push ( c ); } else { if ( stack . empty () || ( c == ')' && stack . top () != '(' ) || ( c == '}' && stack . top () != '{' ) || ( c == ']' && stack . top () != '[' )) return false ; stack . pop (); } } return stack . empty (); } };","title":"0011-0020"},{"location":"golang/0001-0100/0011-0020/#11-container-with-most-water-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxArea ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; while ( l < r ) { int h = min ( height [ l ], height [ r ]); ans = max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) ++ l ; while ( height [ r ] <= h && l < r ) -- r ; } return ans ; } };","title":"11. Container With Most Water $\\star\\star$"},{"location":"golang/0001-0100/0011-0020/#12-integer-to-roman-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : string intToRoman ( int num ) { string M [ 4 ] = { \"\" , \"M\" , \"MM\" , \"MMM\" }; string C [ 10 ] = { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; string X [ 10 ] = { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; string I [ 10 ] = { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ]; } };","title":"12. Integer to Roman $\\star\\star$"},{"location":"golang/0001-0100/0011-0020/#13-roman-to-integer-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int romanToInt ( string s ) { int ans = 0 ; unordered_map < char , int > map = {{ 'I' , 1 }, { 'V' , 5 }, { 'X' , 10 }, { 'L' , 50 }, { 'C' , 100 }, { 'D' , 500 }, { 'M' , 1000 }}; for ( int i = 0 ; i < s . size (); ++ i ) { if ( map [ s [ i ]] < map [ s [ i + 1 ]]) ans -= map [ s [ i ]]; else ans += map [ s [ i ]]; } return ans ; } };","title":"13. Roman to Integer $\\star$"},{"location":"golang/0001-0100/0011-0020/#14-longest-common-prefix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { if ( strs . size () == 0 ) return \"\" ; if ( strs . size () == 1 ) return strs [ 0 ]; string ans ; int min = strs [ 0 ]. length (); bool isMatch = true ; for ( int i = 1 ; i < strs . size (); ++ i ) min = std :: min ( min , ( int ) strs [ i ]. length ()); for ( int i = 0 ; i < min ; ++ i ) { char c = strs [ 0 ][ i ]; for ( int j = 1 ; j < strs . size (); ++ j ) if ( c != strs [ j ][ i ]) { isMatch = false ; break ; } if ( ! isMatch ) break ; ans += c ; } return ans ; } };","title":"14. Longest Common Prefix $\\star$"},{"location":"golang/0001-0100/0011-0020/#15-3sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { vector < vector < int >> ans ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == 0 ) { ans . push_back ({ nums [ i ], nums [ l ], nums [ r ]}); ++ l ; -- r ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; while ( nums [ r ] == nums [ r + 1 ] && l < r ) -- r ; } else if ( sum < 0 ) { ++ l ; } else { -- r ; } } } return ans ; } };","title":"15. 3Sum $\\star\\star$"},{"location":"golang/0001-0100/0011-0020/#16-3sum-closest-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ]; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i + 2 < nums . size (); ++ i ) { int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == target ) return sum ; if ( abs ( sum - target ) < abs ( ans - target )) ans = sum ; if ( sum < target ) ++ l ; else -- r ; } } return ans ; } };","title":"16. 3Sum Closest $\\star\\star$"},{"location":"golang/0001-0100/0011-0020/#17-letter-combinations-of-a-phone-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > letterCombinations ( string digits ) { if ( digits . empty ()) return {}; vector < string > ans = { \"\" }; unordered_map < char , string > map = { { '2' , \"abc\" }, { '3' , \"def\" }, { '4' , \"ghi\" }, { '5' , \"jkl\" }, { '6' , \"mno\" }, { '7' , \"pqrs\" }, { '8' , \"tuv\" }, { '9' , \"wxyz\" }}; for ( char i : digits ) { vector < string > tmp ; for ( string & j : ans ) for ( char k : map [ i ]) tmp . push_back ( j + k ); ans = tmp ; } return ans ; } };","title":"17. Letter Combinations of a Phone Number $\\star\\star$"},{"location":"golang/0001-0100/0011-0020/#18-4sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( nums . begin (), nums . end ()); nSum ( nums , target , 0 , nums . size () - 1 , 4 , path , ans ); return ans ; } private : void nSum ( vector < int >& nums , int target , int l , int r , int n , vector < int >& path , vector < vector < int >>& ans ) { if ( r - l + 1 < n || n < 2 || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == target ) { path . push_back ( nums [ l ]); path . push_back ( nums [ r ]); ans . push_back ( path ); path . pop_back (); path . pop_back (); ++ l ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) ++ l ; } else if ( sum < target ) { ++ l ; } else { -- r ; } } return ; } for ( int i = l ; i <= r ; ++ i ) { if ( i > l && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); nSum ( nums , target - nums [ i ], i + 1 , r , n - 1 , path , ans ); path . pop_back (); } } };","title":"18. 4Sum $\\star\\star$"},{"location":"golang/0001-0100/0011-0020/#19-remove-nth-node-from-end-of-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { auto slow = head ; auto fast = head ; while ( n -- ) fast = fast -> next ; if ( ! fast ) return head -> next ; while ( fast -> next ) { slow = slow -> next ; fast = fast -> next ; } slow -> next = slow -> next -> next ; return head ; } };","title":"19. Remove Nth Node From End of List $\\star\\star$"},{"location":"golang/0001-0100/0011-0020/#20-valid-parentheses-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool isValid ( string s ) { stack < char > stack ; for ( char c : s ) { if ( c == '(' || c == '{' || c == '[' ) { stack . push ( c ); } else { if ( stack . empty () || ( c == ')' && stack . top () != '(' ) || ( c == '}' && stack . top () != '{' ) || ( c == ']' && stack . top () != '[' )) return false ; stack . pop (); } } return stack . empty (); } };","title":"20. Valid Parentheses $\\star$"},{"location":"golang/0001-0100/0021-0030/","text":"21. Merge Two Sorted Lists $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( ! l1 || ! l2 ) return l1 ? l1 : l2 ; if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); l1 -> next = mergeTwoLists ( l1 -> next , l2 ); return l1 ; } }; 22. Generate Parentheses $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > ans ; helper ( \"\" , n , n , ans ); return ans ; } private : void helper ( string str , int l , int r , vector < string >& ans ) { if ( l == 0 && r == 0 ) ans . push_back ( str ); if ( l > 0 ) helper ( str + '(' , l - 1 , r , ans ); if ( l < r ) helper ( str + ')' , l , r - 1 , ans ); } }; 23. Merge k Sorted Lists $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; priority_queue < ListNode * , vector < ListNode *> , compareListNode > pq ; for ( auto list : lists ) if ( list ) pq . push ( list ); while ( ! pq . empty ()) { curr -> next = pq . top (); pq . pop (); curr = curr -> next ; if ( curr -> next ) pq . push ( curr -> next ); } return dummy . next ; } private : struct compareListNode { bool operator ()( const ListNode * l1 , const ListNode * l2 ) { return l1 -> val > l2 -> val ; } }; }; 24. Swap Nodes in Pairs $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; auto prev = & dummy ; auto curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { auto next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; prev = curr ; curr = curr -> next ; } return dummy . next ; } }; 25. Reverse Nodes in k-Group $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; auto prev = & dummy ; auto curr = head ; for ( int i = 0 ; i < length / k ; ++ i ) { for ( int j = 0 ; j < k - 1 ; ++ j ) { auto next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; } prev = curr ; curr = curr -> next ; } return dummy . next ; } }; 26. Remove Duplicates from Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int removeDuplicates ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int j = 0 ; for ( int i = 1 ; i < nums . size (); ++ i ) if ( nums [ i ] != nums [ j ]) nums [ ++ j ] = nums [ i ]; return j + 1 ; } }; 27. Remove Element $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int removeElement ( vector < int >& nums , int val ) { int i = 0 ; for ( int num : nums ) if ( num != val ) nums [ i ++ ] = num ; return i ; } }; 28. Implement strStr() $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int strStr ( string haystack , string needle ) { const int m = haystack . length (); const int n = needle . length (); for ( int i = 0 ; i < m - n + 1 ; i ++ ) if ( haystack . substr ( i , n ) == needle ) return i ; return - 1 ; } }; 29. Divide Two Integers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int divide ( int dividend , int divisor ) { if ( dividend == INT_MIN && divisor == - 1 ) return INT_MAX ; long ans = 0 ; long dvd = labs ( dividend ); long dvs = labs ( divisor ); int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; while ( dvd >= dvs ) { long m = 1 ; long temp = dvs ; while ( temp << 1 <= dvd ) { m <<= 1 ; temp <<= 1 ; } dvd -= temp ; ans += m ; } return sign * ans ; } }; 30. Substring with Concatenation of All Words $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { if ( s . empty () || words . empty ()) return {}; const int m = s . length (); const int n = words [ 0 ]. length (); vector < int > ans ; unordered_map < string , int > map ; for ( string & word : words ) ++ map [ word ]; for ( int i = 0 ; i < n ; ++ i ) { int index = i ; int count = 0 ; unordered_map < string , int > tempMap ; for ( int j = i ; j <= m - n ; j += n ) { string str = s . substr ( j , n ); if ( map . count ( str )) { ++ tempMap [ str ]; ++ count ; while ( tempMap [ str ] > map [ str ]) { -- tempMap [ s . substr ( index , n )]; -- count ; index += n ; } if ( count == words . size ()) { ans . push_back ( index ); -- tempMap [ s . substr ( index , n )]; -- count ; index += n ; } } else { tempMap . clear (); count = 0 ; index = j + n ; } } } return ans ; } };","title":"0021-0030"},{"location":"golang/0001-0100/0021-0030/#21-merge-two-sorted-lists-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( ! l1 || ! l2 ) return l1 ? l1 : l2 ; if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); l1 -> next = mergeTwoLists ( l1 -> next , l2 ); return l1 ; } };","title":"21. Merge Two Sorted Lists $\\star$"},{"location":"golang/0001-0100/0021-0030/#22-generate-parentheses-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > ans ; helper ( \"\" , n , n , ans ); return ans ; } private : void helper ( string str , int l , int r , vector < string >& ans ) { if ( l == 0 && r == 0 ) ans . push_back ( str ); if ( l > 0 ) helper ( str + '(' , l - 1 , r , ans ); if ( l < r ) helper ( str + ')' , l , r - 1 , ans ); } };","title":"22. Generate Parentheses $\\star\\star$"},{"location":"golang/0001-0100/0021-0030/#23-merge-k-sorted-lists-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; priority_queue < ListNode * , vector < ListNode *> , compareListNode > pq ; for ( auto list : lists ) if ( list ) pq . push ( list ); while ( ! pq . empty ()) { curr -> next = pq . top (); pq . pop (); curr = curr -> next ; if ( curr -> next ) pq . push ( curr -> next ); } return dummy . next ; } private : struct compareListNode { bool operator ()( const ListNode * l1 , const ListNode * l2 ) { return l1 -> val > l2 -> val ; } }; };","title":"23. Merge k Sorted Lists $\\star\\star\\star$"},{"location":"golang/0001-0100/0021-0030/#24-swap-nodes-in-pairs-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; auto prev = & dummy ; auto curr = head ; for ( int i = 0 ; i < length / 2 ; ++ i ) { auto next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; prev = curr ; curr = curr -> next ; } return dummy . next ; } };","title":"24. Swap Nodes in Pairs $\\star\\star$"},{"location":"golang/0001-0100/0021-0030/#25-reverse-nodes-in-k-group-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; auto prev = & dummy ; auto curr = head ; for ( int i = 0 ; i < length / k ; ++ i ) { for ( int j = 0 ; j < k - 1 ; ++ j ) { auto next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; } prev = curr ; curr = curr -> next ; } return dummy . next ; } };","title":"25. Reverse Nodes in k-Group $\\star\\star\\star$"},{"location":"golang/0001-0100/0021-0030/#26-remove-duplicates-from-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int removeDuplicates ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int j = 0 ; for ( int i = 1 ; i < nums . size (); ++ i ) if ( nums [ i ] != nums [ j ]) nums [ ++ j ] = nums [ i ]; return j + 1 ; } };","title":"26. Remove Duplicates from Sorted Array $\\star$"},{"location":"golang/0001-0100/0021-0030/#27-remove-element-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int removeElement ( vector < int >& nums , int val ) { int i = 0 ; for ( int num : nums ) if ( num != val ) nums [ i ++ ] = num ; return i ; } };","title":"27. Remove Element $\\star$"},{"location":"golang/0001-0100/0021-0030/#28-implement-strstr-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int strStr ( string haystack , string needle ) { const int m = haystack . length (); const int n = needle . length (); for ( int i = 0 ; i < m - n + 1 ; i ++ ) if ( haystack . substr ( i , n ) == needle ) return i ; return - 1 ; } };","title":"28. Implement strStr() $\\star$"},{"location":"golang/0001-0100/0021-0030/#29-divide-two-integers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int divide ( int dividend , int divisor ) { if ( dividend == INT_MIN && divisor == - 1 ) return INT_MAX ; long ans = 0 ; long dvd = labs ( dividend ); long dvs = labs ( divisor ); int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; while ( dvd >= dvs ) { long m = 1 ; long temp = dvs ; while ( temp << 1 <= dvd ) { m <<= 1 ; temp <<= 1 ; } dvd -= temp ; ans += m ; } return sign * ans ; } };","title":"29. Divide Two Integers $\\star\\star$"},{"location":"golang/0001-0100/0021-0030/#30-substring-with-concatenation-of-all-words-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { if ( s . empty () || words . empty ()) return {}; const int m = s . length (); const int n = words [ 0 ]. length (); vector < int > ans ; unordered_map < string , int > map ; for ( string & word : words ) ++ map [ word ]; for ( int i = 0 ; i < n ; ++ i ) { int index = i ; int count = 0 ; unordered_map < string , int > tempMap ; for ( int j = i ; j <= m - n ; j += n ) { string str = s . substr ( j , n ); if ( map . count ( str )) { ++ tempMap [ str ]; ++ count ; while ( tempMap [ str ] > map [ str ]) { -- tempMap [ s . substr ( index , n )]; -- count ; index += n ; } if ( count == words . size ()) { ans . push_back ( index ); -- tempMap [ s . substr ( index , n )]; -- count ; index += n ; } } else { tempMap . clear (); count = 0 ; index = j + n ; } } } return ans ; } };","title":"30. Substring with Concatenation of All Words $\\star\\star\\star$"},{"location":"golang/0001-0100/0031-0040/","text":"31. Next Permutation $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : void nextPermutation ( vector < int >& nums ) { int i ; for ( i = nums . size () - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = nums . size () - 1 ; j >= 0 ; -- j ) if ( nums [ j ] > nums [ i ]) break ; swap ( nums [ i ], nums [ j ]); } reverse ( nums , i + 1 , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } }; 32. Longest Valid Parentheses $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : int longestValidParentheses ( string s ) { int ans = 0 ; int l = 0 ; int r = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { if ( s [ i ] == '(' ) ++ l ; else ++ r ; if ( l == r ) ans = max ( ans , 2 * r ); else if ( r > l ) { l = 0 ; r = 0 ; } } l = 0 ; r = 0 ; for ( int i = s . length () - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == '(' ) ++ l ; else ++ r ; if ( l == r ) ans = max ( ans , 2 * l ); else if ( l > r ) { l = 0 ; r = 0 ; } } return ans ; } }; 33. Search in Rotated Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } }; 34. Find First and Last Position of Element in Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { int leftIndex = find ( nums , target , true ); if ( leftIndex == nums . size () || nums [ leftIndex ] != target ) return { - 1 , - 1 }; return { leftIndex , find ( nums , target , false ) - 1 }; } private : int find ( vector < int >& nums , int target , bool isLeft ) { int l = 0 ; int r = nums . size (); while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > target || ( isLeft && nums [ m ] == target )) r = m ; else l = m + 1 ; } return l ; } }; 35. Search Insert Position $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size (); while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } }; 36. Valid Sudoku $\\star\\star$ 37. Sudoku Solver $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { dfs ( 0 , board ); } private : bool dfs ( int s , vector < vector < char >>& board ) { if ( s == 81 ) return true ; int i = s / 9 ; int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( s + 1 , board ); for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( i , j , c , board )) { board [ i ][ j ] = c ; if ( dfs ( s + 1 , board )) return true ; board [ i ][ j ] = '.' ; } return false ; } bool isValid ( int row , int col , char c , vector < vector < char >>& board ) { for ( int i = 0 ; i < 9 ; ++ i ) { if ( board [ i ][ col ] != '.' && board [ i ][ col ] == c ) return false ; if ( board [ row ][ i ] != '.' && board [ row ][ i ] == c ) return false ; if ( board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] != '.' && board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; } return true ; } }; 38. Count and Say $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : string countAndSay ( int n ) { unordered_map < int , string > map = { { 1 , \"1\" }, { 2 , \"11\" }, { 3 , \"21\" }, { 4 , \"1211\" }, { 5 , \"111221\" }}; if ( n <= 5 ) return map [ n ]; for ( int i = 6 ; i < n + 1 ; ++ i ) { string s ; int j = 0 ; while ( j <= map [ i - 1 ]. size () - 2 ) { int count = 1 ; while ( j <= map [ i - 1 ]. size () - 2 && map [ i - 1 ][ j ] == map [ i - 1 ][ j + 1 ]) { ++ count ; ++ j ; } s += to_string ( count ) + map [ i - 1 ][ j ]; ++ j ; } if ( j == map [ i - 1 ]. size () - 1 ) s += to_string ( 1 ) + map [ i - 1 ][ j ]; map [ i ] = s ; } return map [ n ]; } }; 39. Combination Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( candidates . begin (), candidates . end ()); dfs ( candidates , target , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& candidates , int target , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { path . push_back ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i , path , ans ); path . pop_back (); } } }; 40. Combination Sum II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( candidates . begin (), candidates . end ()); dfs ( candidates , target , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& candidates , int target , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ]) continue ; path . push_back ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i + 1 , path , ans ); path . pop_back (); } } };","title":"0031-0040"},{"location":"golang/0001-0100/0031-0040/#31-next-permutation-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : void nextPermutation ( vector < int >& nums ) { int i ; for ( i = nums . size () - 2 ; i >= 0 ; -- i ) if ( nums [ i ] < nums [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = nums . size () - 1 ; j >= 0 ; -- j ) if ( nums [ j ] > nums [ i ]) break ; swap ( nums [ i ], nums [ j ]); } reverse ( nums , i + 1 , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } };","title":"31. Next Permutation $\\star\\star$"},{"location":"golang/0001-0100/0031-0040/#32-longest-valid-parentheses-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : int longestValidParentheses ( string s ) { int ans = 0 ; int l = 0 ; int r = 0 ; for ( int i = 0 ; i < s . length (); ++ i ) { if ( s [ i ] == '(' ) ++ l ; else ++ r ; if ( l == r ) ans = max ( ans , 2 * r ); else if ( r > l ) { l = 0 ; r = 0 ; } } l = 0 ; r = 0 ; for ( int i = s . length () - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == '(' ) ++ l ; else ++ r ; if ( l == r ) ans = max ( ans , 2 * l ); else if ( l > r ) { l = 0 ; r = 0 ; } } return ans ; } };","title":"32. Longest Valid Parentheses $\\star\\star\\star$"},{"location":"golang/0001-0100/0031-0040/#33-search-in-rotated-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } };","title":"33. Search in Rotated Sorted Array $\\star\\star$"},{"location":"golang/0001-0100/0031-0040/#34-find-first-and-last-position-of-element-in-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { int leftIndex = find ( nums , target , true ); if ( leftIndex == nums . size () || nums [ leftIndex ] != target ) return { - 1 , - 1 }; return { leftIndex , find ( nums , target , false ) - 1 }; } private : int find ( vector < int >& nums , int target , bool isLeft ) { int l = 0 ; int r = nums . size (); while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > target || ( isLeft && nums [ m ] == target )) r = m ; else l = m + 1 ; } return l ; } };","title":"34. Find First and Last Position of Element in Sorted Array $\\star\\star$"},{"location":"golang/0001-0100/0031-0040/#35-search-insert-position-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size (); while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } };","title":"35. Search Insert Position $\\star$"},{"location":"golang/0001-0100/0031-0040/#36-valid-sudoku-starstar","text":"","title":"36. Valid Sudoku $\\star\\star$"},{"location":"golang/0001-0100/0031-0040/#37-sudoku-solver-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { dfs ( 0 , board ); } private : bool dfs ( int s , vector < vector < char >>& board ) { if ( s == 81 ) return true ; int i = s / 9 ; int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( s + 1 , board ); for ( char c = '1' ; c <= '9' ; ++ c ) if ( isValid ( i , j , c , board )) { board [ i ][ j ] = c ; if ( dfs ( s + 1 , board )) return true ; board [ i ][ j ] = '.' ; } return false ; } bool isValid ( int row , int col , char c , vector < vector < char >>& board ) { for ( int i = 0 ; i < 9 ; ++ i ) { if ( board [ i ][ col ] != '.' && board [ i ][ col ] == c ) return false ; if ( board [ row ][ i ] != '.' && board [ row ][ i ] == c ) return false ; if ( board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] != '.' && board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; } return true ; } };","title":"37. Sudoku Solver $\\star\\star\\star$"},{"location":"golang/0001-0100/0031-0040/#38-count-and-say-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : string countAndSay ( int n ) { unordered_map < int , string > map = { { 1 , \"1\" }, { 2 , \"11\" }, { 3 , \"21\" }, { 4 , \"1211\" }, { 5 , \"111221\" }}; if ( n <= 5 ) return map [ n ]; for ( int i = 6 ; i < n + 1 ; ++ i ) { string s ; int j = 0 ; while ( j <= map [ i - 1 ]. size () - 2 ) { int count = 1 ; while ( j <= map [ i - 1 ]. size () - 2 && map [ i - 1 ][ j ] == map [ i - 1 ][ j + 1 ]) { ++ count ; ++ j ; } s += to_string ( count ) + map [ i - 1 ][ j ]; ++ j ; } if ( j == map [ i - 1 ]. size () - 1 ) s += to_string ( 1 ) + map [ i - 1 ][ j ]; map [ i ] = s ; } return map [ n ]; } };","title":"38. Count and Say $\\star$"},{"location":"golang/0001-0100/0031-0040/#39-combination-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( candidates . begin (), candidates . end ()); dfs ( candidates , target , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& candidates , int target , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { path . push_back ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i , path , ans ); path . pop_back (); } } };","title":"39. Combination Sum $\\star\\star$"},{"location":"golang/0001-0100/0031-0040/#40-combination-sum-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( candidates . begin (), candidates . end ()); dfs ( candidates , target , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& candidates , int target , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); ++ i ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ]) continue ; path . push_back ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i + 1 , path , ans ); path . pop_back (); } } };","title":"40. Combination Sum II $\\star\\star$"},{"location":"golang/0001-0100/0041-0050/","text":"41. First Missing Positive $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int firstMissingPositive ( vector < int >& nums ) { if ( nums . empty ()) return 1 ; const int n = nums . size (); for ( int i = 0 ; i < nums . size (); ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ]) swap ( nums [ i ], nums [ nums [ i ] - 1 ]); for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } }; 42. Trapping Rain Water $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int trap ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; int maxLeft = 0 ; int maxRight = 0 ; while ( l < r ) { if ( height [ l ] < height [ r ]) { maxLeft = max ( maxLeft , height [ l ]); ans += maxLeft - height [ l ]; ++ l ; } else { maxRight = max ( maxRight , height [ r ]); ans += maxRight - height [ r ]; -- r ; } } return ans ; } }; 43. Multiply Strings $\\star\\star$ 44. Wildcard Matching $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool isMatch ( string s , string p ) { const int m = s . length (); const int n = p . length (); vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) { if ( i == 0 && j == 0 ) dp [ i ][ j ] = true ; else if ( i == 0 ) dp [ i ][ j ] = dp [ i ][ j - 1 ] && p [ j - 1 ] == '*' ; else if ( j == 0 ) dp [ i ][ j ] = dp [ i - 1 ][ j ] && s [ i - 1 ] == '*' ; else dp [ i ][ j ] = ( dp [ i - 1 ][ j ] || dp [ i ][ j - 1 ] || dp [ i - 1 ][ j - 1 ]) && ( s [ i - 1 ] == '*' || p [ j - 1 ] == '*' ) || ( dp [ i - 1 ][ j - 1 ]) && ( s [ i - 1 ] == '?' || p [ j - 1 ] == '?' || s [ i - 1 ] == p [ j - 1 ]); } return dp [ m ][ n ]; } }; 45. Jump Game II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int jump ( vector < int >& nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } }; 46. Permutations $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } }; 47. Permutations II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); sort ( nums . begin (), nums . end ()); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ] || i > 0 && used [ i - 1 ] && nums [ i ] == nums [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } }; 48. Rotate Image $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : void rotate ( vector < vector < int >>& matrix ) { for ( int min = 0 ; min < matrix . size () / 2 ; ++ min ) { int max = matrix . size () - min - 1 ; for ( int i = min ; i < max ; ++ i ) { int offset = i - min ; int top = matrix [ min ][ i ]; matrix [ min ][ i ] = matrix [ max - offset ][ min ]; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ]; matrix [ max ][ max - offset ] = matrix [ i ][ max ]; matrix [ i ][ max ] = top ; } } } }; 49. Group Anagrams $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> map ; for ( string & str : strs ) { string s = str ; sort ( s . begin (), s . end ()); map [ s ]. push_back ( str ); } for ( auto & [ key , value ] : map ) { vector < string > s = value ; sort ( s . begin (), s . end ()); ans . push_back ( s ); } return ans ; } }; 50. Pow(x, n) $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution { public : double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n % 2 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } };","title":"0041-0050"},{"location":"golang/0001-0100/0041-0050/#41-first-missing-positive-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int firstMissingPositive ( vector < int >& nums ) { if ( nums . empty ()) return 1 ; const int n = nums . size (); for ( int i = 0 ; i < nums . size (); ++ i ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ]) swap ( nums [ i ], nums [ nums [ i ] - 1 ]); for ( int i = 0 ; i < n ; ++ i ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } };","title":"41. First Missing Positive $\\star\\star\\star$"},{"location":"golang/0001-0100/0041-0050/#42-trapping-rain-water-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int trap ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; int maxLeft = 0 ; int maxRight = 0 ; while ( l < r ) { if ( height [ l ] < height [ r ]) { maxLeft = max ( maxLeft , height [ l ]); ans += maxLeft - height [ l ]; ++ l ; } else { maxRight = max ( maxRight , height [ r ]); ans += maxRight - height [ r ]; -- r ; } } return ans ; } };","title":"42. Trapping Rain Water $\\star\\star\\star$"},{"location":"golang/0001-0100/0041-0050/#43-multiply-strings-starstar","text":"","title":"43. Multiply Strings $\\star\\star$"},{"location":"golang/0001-0100/0041-0050/#44-wildcard-matching-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool isMatch ( string s , string p ) { const int m = s . length (); const int n = p . length (); vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) { if ( i == 0 && j == 0 ) dp [ i ][ j ] = true ; else if ( i == 0 ) dp [ i ][ j ] = dp [ i ][ j - 1 ] && p [ j - 1 ] == '*' ; else if ( j == 0 ) dp [ i ][ j ] = dp [ i - 1 ][ j ] && s [ i - 1 ] == '*' ; else dp [ i ][ j ] = ( dp [ i - 1 ][ j ] || dp [ i ][ j - 1 ] || dp [ i - 1 ][ j - 1 ]) && ( s [ i - 1 ] == '*' || p [ j - 1 ] == '*' ) || ( dp [ i - 1 ][ j - 1 ]) && ( s [ i - 1 ] == '?' || p [ j - 1 ] == '?' || s [ i - 1 ] == p [ j - 1 ]); } return dp [ m ][ n ]; } };","title":"44. Wildcard Matching $\\star\\star\\star$"},{"location":"golang/0001-0100/0041-0050/#45-jump-game-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int jump ( vector < int >& nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ++ ans ; end = farthest ; } } return ans ; } };","title":"45. Jump Game II $\\star\\star\\star$"},{"location":"golang/0001-0100/0041-0050/#46-permutations-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } };","title":"46. Permutations $\\star\\star$"},{"location":"golang/0001-0100/0041-0050/#47-permutations-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); sort ( nums . begin (), nums . end ()); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); ++ i ) { if ( used [ i ] || i > 0 && used [ i - 1 ] && nums [ i ] == nums [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } };","title":"47. Permutations II $\\star\\star$"},{"location":"golang/0001-0100/0041-0050/#48-rotate-image-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : void rotate ( vector < vector < int >>& matrix ) { for ( int min = 0 ; min < matrix . size () / 2 ; ++ min ) { int max = matrix . size () - min - 1 ; for ( int i = min ; i < max ; ++ i ) { int offset = i - min ; int top = matrix [ min ][ i ]; matrix [ min ][ i ] = matrix [ max - offset ][ min ]; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ]; matrix [ max ][ max - offset ] = matrix [ i ][ max ]; matrix [ i ][ max ] = top ; } } } };","title":"48. Rotate Image $\\star\\star$"},{"location":"golang/0001-0100/0041-0050/#49-group-anagrams-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> map ; for ( string & str : strs ) { string s = str ; sort ( s . begin (), s . end ()); map [ s ]. push_back ( str ); } for ( auto & [ key , value ] : map ) { vector < string > s = value ; sort ( s . begin (), s . end ()); ans . push_back ( s ); } return ans ; } };","title":"49. Group Anagrams $\\star\\star$"},{"location":"golang/0001-0100/0041-0050/#50-powx-n-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution { public : double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n % 2 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } };","title":"50. Pow(x, n) $\\star\\star$"},{"location":"golang/0001-0100/0051-0060/","text":"51. N-Queens $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; vector < string > board ( n , string ( n , '.' )); vector < bool > cols ( n , false ); vector < bool > diag1 ( 2 * n - 1 , false ); vector < bool > diag2 ( 2 * n - 1 , false ); dfs ( 0 , cols , diag1 , diag2 , board , ans ); return ans ; } private : void dfs ( int y , vector < bool >& cols , vector < bool >& diag1 , vector < bool >& diag2 , vector < string >& board , vector < vector < string >>& ans ) { if ( y == cols . size ()) { ans . push_back ( board ); return ; } for ( int x = 0 ; x < cols . size (); ++ x ) { if ( ! cols [ x ] && ! diag1 [ x + y ] && ! diag2 [ x - y + cols . size () - 1 ]) { board [ y ][ x ] = 'Q' ; cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = true ; dfs ( y + 1 , cols , diag1 , diag2 , board , ans ); cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = false ; board [ y ][ x ] = '.' ; } } } }; 52. N-Queens II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; vector < bool > cols ( n , false ); vector < bool > diag1 ( 2 * n - 1 , false ); vector < bool > diag2 ( 2 * n - 1 , false ); dfs ( 0 , cols , diag1 , diag2 , ans ); return ans ; } private : void dfs ( int y , vector < bool >& cols , vector < bool >& diag1 , vector < bool >& diag2 , int & ans ) { if ( y == cols . size ()) { ++ ans ; return ; } for ( int x = 0 ; x < cols . size (); ++ x ) { if ( ! cols [ x ] && ! diag1 [ x + y ] && ! diag2 [ x - y + cols . size () - 1 ]) { cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = true ; dfs ( y + 1 , cols , diag1 , diag2 , ans ); cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = false ; } } } }; 53. Maximum Subarray $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxSubArray ( vector < int >& nums ) { int ans = INT_MIN ; int sum = 0 ; for ( int num : nums ) { sum += num ; ans = max ( ans , sum ); sum = max ( sum , 0 ); } return ans ; } }; 54. Spiral Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; vector < int > ans ; int r1 = 0 ; int c1 = 0 ; int r2 = matrix . size () - 1 ; int c2 = matrix [ 0 ]. size () - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; ++ c ) ans . push_back ( matrix [ r1 ][ c ]); for ( int r = r1 + 1 ; r <= r2 ; ++ r ) ans . push_back ( matrix [ r ][ c2 ]); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; -- c ) ans . push_back ( matrix [ r2 ][ c ]); for ( int r = r2 ; r > r1 ; -- r ) ans . push_back ( matrix [ r ][ c1 ]); } ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } }; 55. Jump Game $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool canJump ( vector < int >& nums ) { int goal = nums . size () - 1 ; for ( int i = goal ; i >= 0 ; -- i ) if ( i + nums [ i ] >= goal ) goal = i ; return goal == 0 ; } }; 56. Merge Intervals $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; sort ( intervals . begin (), intervals . end (), compare ); for ( vector < int >& interval : intervals ) { if ( ans . empty () || ans . back ()[ 1 ] < interval [ 0 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); } return ans ; } private : bool static compare ( const vector < int >& a , const vector < int >& b ) { return a [ 0 ] < b [ 0 ]; } }; 57. Insert Interval $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> ans ; auto it = intervals . begin (); for (; it != intervals . end (); ++ it ) if (( * it )[ 0 ] >= newInterval [ 0 ]) break ; intervals . insert ( it , newInterval ); for ( vector < int >& interval : intervals ) { if ( ans . empty () || interval [ 0 ] > ans . back ()[ 1 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); } return ans ; } }; 58. Length of Last Word $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int lengthOfLastWord ( string s ) { int ans = 0 ; int i = s . size () - 1 ; while ( i >= 0 && s [ i ] == ' ' ) -- i ; while ( i >= 0 && s [ i ] != ' ' ) { -- i ; ++ ans ; } return ans ; } }; 59. Spiral Matrix II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n )); int count = 1 ; for ( int min = 0 , max = n - min - 1 ; min < n / 2 ; ++ min , -- max ) { for ( int i = min ; i < max ; ++ i ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ][ min ] = count ++ ; } if ( n & 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } }; 60. Permutation Sequence $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getPermutation ( int n , int k ) { string ans ; vector < int > nums ( n ); vector < int > fact ( n , 1 ); for ( int i = 0 ; i < n ; ++ i ) nums [ i ] = i + 1 ; for ( int i = 1 ; i < n ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; -- k ; for ( int i = n ; i >= 1 ; -- i ) { int j = k / fact [ i - 1 ]; k %= fact [ i - 1 ]; ans . append ( to_string ( nums [ j ])); nums . erase ( nums . begin () + j ); } return ans ; } };","title":"0051-0060"},{"location":"golang/0001-0100/0051-0060/#51-n-queens-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; vector < string > board ( n , string ( n , '.' )); vector < bool > cols ( n , false ); vector < bool > diag1 ( 2 * n - 1 , false ); vector < bool > diag2 ( 2 * n - 1 , false ); dfs ( 0 , cols , diag1 , diag2 , board , ans ); return ans ; } private : void dfs ( int y , vector < bool >& cols , vector < bool >& diag1 , vector < bool >& diag2 , vector < string >& board , vector < vector < string >>& ans ) { if ( y == cols . size ()) { ans . push_back ( board ); return ; } for ( int x = 0 ; x < cols . size (); ++ x ) { if ( ! cols [ x ] && ! diag1 [ x + y ] && ! diag2 [ x - y + cols . size () - 1 ]) { board [ y ][ x ] = 'Q' ; cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = true ; dfs ( y + 1 , cols , diag1 , diag2 , board , ans ); cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = false ; board [ y ][ x ] = '.' ; } } } };","title":"51. N-Queens $\\star\\star\\star$"},{"location":"golang/0001-0100/0051-0060/#52-n-queens-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; vector < bool > cols ( n , false ); vector < bool > diag1 ( 2 * n - 1 , false ); vector < bool > diag2 ( 2 * n - 1 , false ); dfs ( 0 , cols , diag1 , diag2 , ans ); return ans ; } private : void dfs ( int y , vector < bool >& cols , vector < bool >& diag1 , vector < bool >& diag2 , int & ans ) { if ( y == cols . size ()) { ++ ans ; return ; } for ( int x = 0 ; x < cols . size (); ++ x ) { if ( ! cols [ x ] && ! diag1 [ x + y ] && ! diag2 [ x - y + cols . size () - 1 ]) { cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = true ; dfs ( y + 1 , cols , diag1 , diag2 , ans ); cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = false ; } } } };","title":"52. N-Queens II $\\star\\star\\star$"},{"location":"golang/0001-0100/0051-0060/#53-maximum-subarray-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxSubArray ( vector < int >& nums ) { int ans = INT_MIN ; int sum = 0 ; for ( int num : nums ) { sum += num ; ans = max ( ans , sum ); sum = max ( sum , 0 ); } return ans ; } };","title":"53. Maximum Subarray $\\star$"},{"location":"golang/0001-0100/0051-0060/#54-spiral-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; vector < int > ans ; int r1 = 0 ; int c1 = 0 ; int r2 = matrix . size () - 1 ; int c2 = matrix [ 0 ]. size () - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; ++ c ) ans . push_back ( matrix [ r1 ][ c ]); for ( int r = r1 + 1 ; r <= r2 ; ++ r ) ans . push_back ( matrix [ r ][ c2 ]); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; -- c ) ans . push_back ( matrix [ r2 ][ c ]); for ( int r = r2 ; r > r1 ; -- r ) ans . push_back ( matrix [ r ][ c1 ]); } ++ r1 ; ++ c1 ; -- r2 ; -- c2 ; } return ans ; } };","title":"54. Spiral Matrix $\\star\\star$"},{"location":"golang/0001-0100/0051-0060/#55-jump-game-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool canJump ( vector < int >& nums ) { int goal = nums . size () - 1 ; for ( int i = goal ; i >= 0 ; -- i ) if ( i + nums [ i ] >= goal ) goal = i ; return goal == 0 ; } };","title":"55. Jump Game $\\star\\star$"},{"location":"golang/0001-0100/0051-0060/#56-merge-intervals-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; sort ( intervals . begin (), intervals . end (), compare ); for ( vector < int >& interval : intervals ) { if ( ans . empty () || ans . back ()[ 1 ] < interval [ 0 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); } return ans ; } private : bool static compare ( const vector < int >& a , const vector < int >& b ) { return a [ 0 ] < b [ 0 ]; } };","title":"56. Merge Intervals $\\star\\star$"},{"location":"golang/0001-0100/0051-0060/#57-insert-interval-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> ans ; auto it = intervals . begin (); for (; it != intervals . end (); ++ it ) if (( * it )[ 0 ] >= newInterval [ 0 ]) break ; intervals . insert ( it , newInterval ); for ( vector < int >& interval : intervals ) { if ( ans . empty () || interval [ 0 ] > ans . back ()[ 1 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); } return ans ; } };","title":"57. Insert Interval $\\star\\star\\star$"},{"location":"golang/0001-0100/0051-0060/#58-length-of-last-word-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int lengthOfLastWord ( string s ) { int ans = 0 ; int i = s . size () - 1 ; while ( i >= 0 && s [ i ] == ' ' ) -- i ; while ( i >= 0 && s [ i ] != ' ' ) { -- i ; ++ ans ; } return ans ; } };","title":"58. Length of Last Word $\\star$"},{"location":"golang/0001-0100/0051-0060/#59-spiral-matrix-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n )); int count = 1 ; for ( int min = 0 , max = n - min - 1 ; min < n / 2 ; ++ min , -- max ) { for ( int i = min ; i < max ; ++ i ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; ++ i ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; -- i ) ans [ i ][ min ] = count ++ ; } if ( n & 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } };","title":"59. Spiral Matrix II $\\star\\star$"},{"location":"golang/0001-0100/0051-0060/#60-permutation-sequence-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getPermutation ( int n , int k ) { string ans ; vector < int > nums ( n ); vector < int > fact ( n , 1 ); for ( int i = 0 ; i < n ; ++ i ) nums [ i ] = i + 1 ; for ( int i = 1 ; i < n ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; -- k ; for ( int i = n ; i >= 1 ; -- i ) { int j = k / fact [ i - 1 ]; k %= fact [ i - 1 ]; ans . append ( to_string ( nums [ j ])); nums . erase ( nums . begin () + j ); } return ans ; } };","title":"60. Permutation Sequence $\\star\\star$"},{"location":"golang/0001-0100/0061-0070/","text":"61. Rotate List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( ! head || ! head -> next || k == 0 ) return head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; k %= length ; if ( k == 0 ) return head ; auto slow = head ; auto fast = head ; while ( k -- ) fast = fast -> next ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next ; } auto ans = slow -> next ; slow -> next = NULL ; fast -> next = head ; return ans ; } }; 62. Unique Paths $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 func uniquePaths ( m int , n int ) int { // return func1 ( m - 1 , n - 1 , 0 , 0 ); // return func2 ( m , n ); return func4 ( m , n ); } // 1. recursive func func1 ( m int , n int , i int , j int ) int { if i < 0 || m < i || j < 0 || n < j { return 0 ; } if m == i && n == j { return 1 ; } return func1 ( m , n , i + 1 , j ) + func1 ( m , n , i , j + 1 ); } // 2. recursive + memo func func2 ( m int , n int ) int { memo : = make ( [][] int , m ); for i : = 0 ; i < m ; i ++ { memo [ i ] = make ( [] int , n ); for j : = 0 ; j < n ; j ++ { memo [ i ][ j ] = - 1 ; } } return helper2 ( m - 1 , n - 1 , 0 , 0 , memo ); } func helper2 ( m int , n int , i int , j int , memo [][] int ) int { if i < 0 || m < i || j < 0 || n < j { return 0 ; } if m == i && n == j { return 1 ; } if memo [ i ][ j ] != - 1 { return memo [ i ][ j ] ; } memo [ i ][ j ] = helper2 ( m , n , i + 1 , j , memo ) + helper2 ( m , n , i , j + 1 , memo ); return memo [ i ][ j ] ; } // 3. iterative + memo , pass // 4. iterative + 2 N variables func func4 ( m int , n int ) int { memo : = make ( [][] int , 2 ); for i : = 0 ; i < 2 ; i ++ { memo [ i ] = make ( [] int , n ); for j : = 0 ; j < n ; j ++ { memo [ i ][ j ] = 0 ; } } memo [ (m-1)%2 ][ n-1 ] = 1 ; for i : = m - 1 ; i >= 0 ; i -- { for j : = n - 1 ; j >= 0 ; j -- { if i == m - 1 && j == n - 1 { continue ; } memo [ i%2 ][ j ] = 0 ; if j + 1 < n { memo [ i%2 ][ j ] += memo [ i%2 ][ j+1 ] ; } if i + 1 < m { memo [ i%2 ][ j ] += memo [ (i+1)%2 ][ j ] ; } } } // for i : = 0 ; i < 2 ; i ++ { // for j : = 0 ; j < n ; j ++ { // fmt . Println ( i , j , memo [ i ][ j ] ); // } // } return memo [ 0 ][ 0 ] ; } 63. Unique Paths II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func uniquePathsWithObstacles ( obstacleGrid [][] int ) int { m : = len ( obstacleGrid ) n : = len ( obstacleGrid [ 0 ] ) return func4 ( obstacleGrid , m , n ) } // 3. iterative + memo , pass // 4. iterative + 2 N variables func func4 ( obstacleGrid [][] int , m int , n int ) int { memo : = make ( [][] int , 2 ) for i : = 0 ; i < 2 ; i ++ { memo [ i ] = make ( [] int , n ) for j : = 0 ; j < n ; j ++ { memo [ i ][ j ] = 0 } } for i : = m - 1 ; i >= 0 ; i -- { for j : = n - 1 ; j >= 0 ; j -- { if i == m - 1 && j == n - 1 { if obstacleGrid [ m-1 ][ n-1 ] == 1 { memo [ (m-1)%2 ][ n-1 ] = 0 } else { memo [ (m-1)%2 ][ n-1 ] = 1 } continue } memo [ i%2 ][ j ] = 0 if obstacleGrid [ i ][ j ] == 1 { continue } if j + 1 < n { memo [ i%2 ][ j ] += memo [ i%2 ][ j+1 ] } if i + 1 < m { memo [ i%2 ][ j ] += memo [ (i+1)%2 ][ j ] } } } return memo [ 0 ][ 0 ] } 64. Minimum Path Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int minPathSum ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); for ( int i = 1 ; i < m ; ++ i ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ]; for ( int j = 1 ; j < n ; ++ j ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ]; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]); return grid [ m - 1 ][ n - 1 ]; } }; 65. Valid Number $\\star\\star\\star$ 66. Plus One $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > plusOne ( vector < int >& digits ) { const int n = digits . size (); for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( digits [ i ] < 9 ) { ++ digits [ i ]; return digits ; } digits [ i ] = 0 ; } vector < int > ans ( n + 1 ); ans [ 0 ] = 1 ; return ans ; } }; 67. Add Binary $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string addBinary ( string a , string b ) { string ans ; int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( i >= 0 || j >= 0 || carry == 1 ) { if ( i >= 0 ) carry += a [ i -- ] - '0' ; if ( j >= 0 ) carry += b [ j -- ] - '0' ; ans = char ( carry % 2 + '0' ) + ans ; carry >>= 1 ; } return ans ; } }; 68. Text Justification $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < string > fullJustify ( vector < string >& words , int maxWidth ) { vector < string > ans ; vector < string > curr ; int numOfLetters = 0 ; for ( string & word : words ) { if ( numOfLetters + ( int ) curr . size () + ( int ) word . length () > maxWidth ) { for ( int i = 0 ; i < maxWidth - numOfLetters ; ++ i ) { curr . size () - 1 == 0 ? curr [ 0 ]. append ( \" \" ) : curr [ i % ( curr . size () - 1 )]. append ( \" \" ); } ans . push_back ( join ( curr , \"\" )); curr . clear (); numOfLetters = 0 ; } curr . push_back ( word ); numOfLetters += word . length (); } ans . push_back ( ljust ( join ( curr , \" \" ), maxWidth )); return ans ; } private : string join ( vector < string >& v , string c ) { string s ; for ( auto p = v . begin (); p != v . end (); ++ p ) { s += * p ; if ( p != v . end () - 1 ) s += c ; } return s ; } string ljust ( string s , int width ) { for ( int i = 0 ; i < s . length () - width ; ++ i ) s += \" \" ; return s ; } }; 69. Sqrt(x) $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int mySqrt ( int x ) { unsigned l = 1 ; unsigned r = x + 1u ; while ( l < r ) { unsigned m = ( l + r ) >> 1 ; if ( m > x / m ) r = m ; else l = m + 1 ; } return l - 1 ; } }; 70. Climbing Stairs $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int climbStairs ( int n ) { if ( n == 1 ) return 1 ; vector < int > dp ( n + 1 ); dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; ++ i ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]; return dp [ n ]; } };","title":"0061-0070"},{"location":"golang/0001-0100/0061-0070/#61-rotate-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( ! head || ! head -> next || k == 0 ) return head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; k %= length ; if ( k == 0 ) return head ; auto slow = head ; auto fast = head ; while ( k -- ) fast = fast -> next ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next ; } auto ans = slow -> next ; slow -> next = NULL ; fast -> next = head ; return ans ; } };","title":"61. Rotate List $\\star\\star$"},{"location":"golang/0001-0100/0061-0070/#62-unique-paths-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 func uniquePaths ( m int , n int ) int { // return func1 ( m - 1 , n - 1 , 0 , 0 ); // return func2 ( m , n ); return func4 ( m , n ); } // 1. recursive func func1 ( m int , n int , i int , j int ) int { if i < 0 || m < i || j < 0 || n < j { return 0 ; } if m == i && n == j { return 1 ; } return func1 ( m , n , i + 1 , j ) + func1 ( m , n , i , j + 1 ); } // 2. recursive + memo func func2 ( m int , n int ) int { memo : = make ( [][] int , m ); for i : = 0 ; i < m ; i ++ { memo [ i ] = make ( [] int , n ); for j : = 0 ; j < n ; j ++ { memo [ i ][ j ] = - 1 ; } } return helper2 ( m - 1 , n - 1 , 0 , 0 , memo ); } func helper2 ( m int , n int , i int , j int , memo [][] int ) int { if i < 0 || m < i || j < 0 || n < j { return 0 ; } if m == i && n == j { return 1 ; } if memo [ i ][ j ] != - 1 { return memo [ i ][ j ] ; } memo [ i ][ j ] = helper2 ( m , n , i + 1 , j , memo ) + helper2 ( m , n , i , j + 1 , memo ); return memo [ i ][ j ] ; } // 3. iterative + memo , pass // 4. iterative + 2 N variables func func4 ( m int , n int ) int { memo : = make ( [][] int , 2 ); for i : = 0 ; i < 2 ; i ++ { memo [ i ] = make ( [] int , n ); for j : = 0 ; j < n ; j ++ { memo [ i ][ j ] = 0 ; } } memo [ (m-1)%2 ][ n-1 ] = 1 ; for i : = m - 1 ; i >= 0 ; i -- { for j : = n - 1 ; j >= 0 ; j -- { if i == m - 1 && j == n - 1 { continue ; } memo [ i%2 ][ j ] = 0 ; if j + 1 < n { memo [ i%2 ][ j ] += memo [ i%2 ][ j+1 ] ; } if i + 1 < m { memo [ i%2 ][ j ] += memo [ (i+1)%2 ][ j ] ; } } } // for i : = 0 ; i < 2 ; i ++ { // for j : = 0 ; j < n ; j ++ { // fmt . Println ( i , j , memo [ i ][ j ] ); // } // } return memo [ 0 ][ 0 ] ; }","title":"62. Unique Paths $\\star\\star$"},{"location":"golang/0001-0100/0061-0070/#63-unique-paths-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 func uniquePathsWithObstacles ( obstacleGrid [][] int ) int { m : = len ( obstacleGrid ) n : = len ( obstacleGrid [ 0 ] ) return func4 ( obstacleGrid , m , n ) } // 3. iterative + memo , pass // 4. iterative + 2 N variables func func4 ( obstacleGrid [][] int , m int , n int ) int { memo : = make ( [][] int , 2 ) for i : = 0 ; i < 2 ; i ++ { memo [ i ] = make ( [] int , n ) for j : = 0 ; j < n ; j ++ { memo [ i ][ j ] = 0 } } for i : = m - 1 ; i >= 0 ; i -- { for j : = n - 1 ; j >= 0 ; j -- { if i == m - 1 && j == n - 1 { if obstacleGrid [ m-1 ][ n-1 ] == 1 { memo [ (m-1)%2 ][ n-1 ] = 0 } else { memo [ (m-1)%2 ][ n-1 ] = 1 } continue } memo [ i%2 ][ j ] = 0 if obstacleGrid [ i ][ j ] == 1 { continue } if j + 1 < n { memo [ i%2 ][ j ] += memo [ i%2 ][ j+1 ] } if i + 1 < m { memo [ i%2 ][ j ] += memo [ (i+1)%2 ][ j ] } } } return memo [ 0 ][ 0 ] }","title":"63. Unique Paths II $\\star\\star$"},{"location":"golang/0001-0100/0061-0070/#64-minimum-path-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int minPathSum ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); for ( int i = 1 ; i < m ; ++ i ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ]; for ( int j = 1 ; j < n ; ++ j ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ]; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]); return grid [ m - 1 ][ n - 1 ]; } };","title":"64. Minimum Path Sum $\\star\\star$"},{"location":"golang/0001-0100/0061-0070/#65-valid-number-starstarstar","text":"","title":"65. Valid Number $\\star\\star\\star$"},{"location":"golang/0001-0100/0061-0070/#66-plus-one-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > plusOne ( vector < int >& digits ) { const int n = digits . size (); for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( digits [ i ] < 9 ) { ++ digits [ i ]; return digits ; } digits [ i ] = 0 ; } vector < int > ans ( n + 1 ); ans [ 0 ] = 1 ; return ans ; } };","title":"66. Plus One $\\star$"},{"location":"golang/0001-0100/0061-0070/#67-add-binary-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string addBinary ( string a , string b ) { string ans ; int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( i >= 0 || j >= 0 || carry == 1 ) { if ( i >= 0 ) carry += a [ i -- ] - '0' ; if ( j >= 0 ) carry += b [ j -- ] - '0' ; ans = char ( carry % 2 + '0' ) + ans ; carry >>= 1 ; } return ans ; } };","title":"67. Add Binary $\\star$"},{"location":"golang/0001-0100/0061-0070/#68-text-justification-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < string > fullJustify ( vector < string >& words , int maxWidth ) { vector < string > ans ; vector < string > curr ; int numOfLetters = 0 ; for ( string & word : words ) { if ( numOfLetters + ( int ) curr . size () + ( int ) word . length () > maxWidth ) { for ( int i = 0 ; i < maxWidth - numOfLetters ; ++ i ) { curr . size () - 1 == 0 ? curr [ 0 ]. append ( \" \" ) : curr [ i % ( curr . size () - 1 )]. append ( \" \" ); } ans . push_back ( join ( curr , \"\" )); curr . clear (); numOfLetters = 0 ; } curr . push_back ( word ); numOfLetters += word . length (); } ans . push_back ( ljust ( join ( curr , \" \" ), maxWidth )); return ans ; } private : string join ( vector < string >& v , string c ) { string s ; for ( auto p = v . begin (); p != v . end (); ++ p ) { s += * p ; if ( p != v . end () - 1 ) s += c ; } return s ; } string ljust ( string s , int width ) { for ( int i = 0 ; i < s . length () - width ; ++ i ) s += \" \" ; return s ; } };","title":"68. Text Justification $\\star\\star\\star$"},{"location":"golang/0001-0100/0061-0070/#69-sqrtx-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int mySqrt ( int x ) { unsigned l = 1 ; unsigned r = x + 1u ; while ( l < r ) { unsigned m = ( l + r ) >> 1 ; if ( m > x / m ) r = m ; else l = m + 1 ; } return l - 1 ; } };","title":"69. Sqrt(x) $\\star$"},{"location":"golang/0001-0100/0061-0070/#70-climbing-stairs-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int climbStairs ( int n ) { if ( n == 1 ) return 1 ; vector < int > dp ( n + 1 ); dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; ++ i ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]; return dp [ n ]; } };","title":"70. Climbing Stairs $\\star$"},{"location":"golang/0001-0100/0071-0080/","text":"71. Simplify Path $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string simplifyPath ( string path ) { string ans ; string temp ; stringstream ss ( path ); vector < string > stack ; while ( getline ( ss , temp , '/' )) { if ( temp == \"\" || temp == \".\" ) continue ; if ( temp == \"..\" ) { if ( ! stack . empty ()) stack . pop_back (); } else { stack . push_back ( temp ); } } for ( auto str : stack ) ans += \"/\" + str ; return ans . empty () ? \"/\" : ans ; } }; 72. Edit Distance $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int minDistance ( string word1 , string word2 ) { const int m = word1 . length (); const int n = word2 . length (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) { if ( i == 0 ) dp [ i ][ j ] = j ; else if ( j == 0 ) dp [ i ][ j ] = i ; else dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ] + ( word1 [ i - 1 ] == word2 [ j - 1 ] ? 0 : 1 ), min ( dp [ i - 1 ][ j ] + 1 , dp [ i ][ j - 1 ] + 1 )); } return dp [ m ][ n ]; } }; 73. Set Matrix Zeroes $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); bool isFirstRow = false ; bool isFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ][ j ] == 0 ) isFirstRow = true ; for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ][ 0 ] == 0 ) isFirstCol = true ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( isFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ][ j ] = 0 ; if ( isFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ][ 0 ] = 0 ; } }; 74. Search a 2D Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int l = 0 ; int r = m * n ; while ( l < r ) { int mid = l + ( r - l ) / 2 ; int i = mid / n ; int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } }; 75. Sort Colors $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void sortColors ( vector < int >& nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( int num : nums ) { if ( num == 0 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; nums [ ++ zero ] = 0 ; } else if ( num == 1 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; } else { nums [ ++ two ] = 2 ; } } } }; 76. Minimum Window Substring $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : string minWindow ( string s , string t ) { if ( s . empty () || t . empty ()) return \"\" ; unordered_map < char , int > map ; for ( char c : t ) ++ map [ c ]; int l = 0 ; int r = 0 ; int bestLeft = 0 ; int bestRight = 0 ; int required = map . size (); int windowLength = s . length () + 1 ; for ( int r = 0 ; r < s . length (); ++ r ) { if ( map . count ( s [ r ])) if ( -- map [ s [ r ]] == 0 ) -- required ; while ( required == 0 && l <= r ) { if ( r - l + 1 < windowLength ) { windowLength = r - l + 1 ; bestLeft = l ; bestRight = r ; } if ( map . count ( s [ l ])) if ( ++ map [ s [ l ]] > 0 ) ++ required ; ++ l ; } } return windowLength == s . length () + 1 ? \"\" : s . substr ( bestLeft , windowLength ); } }; 77. Combinations $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; vector < int > path ; dfs ( n , k , 1 , path , ans ); return ans ; } private : void dfs ( int n , int k , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( k == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i <= n ; ++ i ) { path . push_back ( i ); dfs ( n , k - 1 , i + 1 , path , ans ); path . pop_back (); } } }; 78. Subsets $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { ans . push_back ( path ); if ( s == nums . size ()) return ; for ( int i = s ; i < nums . size (); ++ i ) { path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } }; 79. Word Search $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { if ( board . empty ()) return false ; for ( int i = 0 ; i < board . size (); ++ i ) for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) if ( dfs ( board , word , i , j , 0 )) return true ; return false ; } private : bool dfs ( vector < vector < char >>& board , string & word , int i , int j , int pos ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] != word [ pos ] || board [ i ][ j ] == '*' ) return false ; if ( pos == word . length () - 1 ) return true ; char c = board [ i ][ j ]; board [ i ][ j ] = '*' ; bool flag = dfs ( board , word , i + 1 , j , pos + 1 ) || dfs ( board , word , i - 1 , j , pos + 1 ) || dfs ( board , word , i , j + 1 , pos + 1 ) || dfs ( board , word , i , j - 1 , pos + 1 ); board [ i ][ j ] = c ; return flag ; } }; 80. Remove Duplicates from Sorted Array II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( int num : nums ) if ( i < 2 || num != nums [ i - 2 ]) nums [ i ++ ] = num ; return i ; } };","title":"0071-0080"},{"location":"golang/0001-0100/0071-0080/#71-simplify-path-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string simplifyPath ( string path ) { string ans ; string temp ; stringstream ss ( path ); vector < string > stack ; while ( getline ( ss , temp , '/' )) { if ( temp == \"\" || temp == \".\" ) continue ; if ( temp == \"..\" ) { if ( ! stack . empty ()) stack . pop_back (); } else { stack . push_back ( temp ); } } for ( auto str : stack ) ans += \"/\" + str ; return ans . empty () ? \"/\" : ans ; } };","title":"71. Simplify Path $\\star\\star$"},{"location":"golang/0001-0100/0071-0080/#72-edit-distance-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int minDistance ( string word1 , string word2 ) { const int m = word1 . length (); const int n = word2 . length (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) { if ( i == 0 ) dp [ i ][ j ] = j ; else if ( j == 0 ) dp [ i ][ j ] = i ; else dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ] + ( word1 [ i - 1 ] == word2 [ j - 1 ] ? 0 : 1 ), min ( dp [ i - 1 ][ j ] + 1 , dp [ i ][ j - 1 ] + 1 )); } return dp [ m ][ n ]; } };","title":"72. Edit Distance $\\star\\star\\star$"},{"location":"golang/0001-0100/0071-0080/#73-set-matrix-zeroes-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); bool isFirstRow = false ; bool isFirstCol = false ; for ( int j = 0 ; j < n ; ++ j ) if ( matrix [ 0 ][ j ] == 0 ) isFirstRow = true ; for ( int i = 0 ; i < m ; ++ i ) if ( matrix [ i ][ 0 ] == 0 ) isFirstCol = true ; for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; ++ i ) for ( int j = 1 ; j < n ; ++ j ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( isFirstRow ) for ( int j = 0 ; j < n ; ++ j ) matrix [ 0 ][ j ] = 0 ; if ( isFirstCol ) for ( int i = 0 ; i < m ; ++ i ) matrix [ i ][ 0 ] = 0 ; } };","title":"73. Set Matrix Zeroes $\\star\\star$"},{"location":"golang/0001-0100/0071-0080/#74-search-a-2d-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int l = 0 ; int r = m * n ; while ( l < r ) { int mid = l + ( r - l ) / 2 ; int i = mid / n ; int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } };","title":"74. Search a 2D Matrix $\\star\\star$"},{"location":"golang/0001-0100/0071-0080/#75-sort-colors-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void sortColors ( vector < int >& nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( int num : nums ) { if ( num == 0 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; nums [ ++ zero ] = 0 ; } else if ( num == 1 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; } else { nums [ ++ two ] = 2 ; } } } };","title":"75. Sort Colors $\\star\\star$"},{"location":"golang/0001-0100/0071-0080/#76-minimum-window-substring-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : string minWindow ( string s , string t ) { if ( s . empty () || t . empty ()) return \"\" ; unordered_map < char , int > map ; for ( char c : t ) ++ map [ c ]; int l = 0 ; int r = 0 ; int bestLeft = 0 ; int bestRight = 0 ; int required = map . size (); int windowLength = s . length () + 1 ; for ( int r = 0 ; r < s . length (); ++ r ) { if ( map . count ( s [ r ])) if ( -- map [ s [ r ]] == 0 ) -- required ; while ( required == 0 && l <= r ) { if ( r - l + 1 < windowLength ) { windowLength = r - l + 1 ; bestLeft = l ; bestRight = r ; } if ( map . count ( s [ l ])) if ( ++ map [ s [ l ]] > 0 ) ++ required ; ++ l ; } } return windowLength == s . length () + 1 ? \"\" : s . substr ( bestLeft , windowLength ); } };","title":"76. Minimum Window Substring $\\star\\star\\star$"},{"location":"golang/0001-0100/0071-0080/#77-combinations-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; vector < int > path ; dfs ( n , k , 1 , path , ans ); return ans ; } private : void dfs ( int n , int k , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( k == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i <= n ; ++ i ) { path . push_back ( i ); dfs ( n , k - 1 , i + 1 , path , ans ); path . pop_back (); } } };","title":"77. Combinations $\\star\\star$"},{"location":"golang/0001-0100/0071-0080/#78-subsets-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { ans . push_back ( path ); if ( s == nums . size ()) return ; for ( int i = s ; i < nums . size (); ++ i ) { path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } };","title":"78. Subsets $\\star\\star$"},{"location":"golang/0001-0100/0071-0080/#79-word-search-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { if ( board . empty ()) return false ; for ( int i = 0 ; i < board . size (); ++ i ) for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) if ( dfs ( board , word , i , j , 0 )) return true ; return false ; } private : bool dfs ( vector < vector < char >>& board , string & word , int i , int j , int pos ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] != word [ pos ] || board [ i ][ j ] == '*' ) return false ; if ( pos == word . length () - 1 ) return true ; char c = board [ i ][ j ]; board [ i ][ j ] = '*' ; bool flag = dfs ( board , word , i + 1 , j , pos + 1 ) || dfs ( board , word , i - 1 , j , pos + 1 ) || dfs ( board , word , i , j + 1 , pos + 1 ) || dfs ( board , word , i , j - 1 , pos + 1 ); board [ i ][ j ] = c ; return flag ; } };","title":"79. Word Search $\\star\\star$"},{"location":"golang/0001-0100/0071-0080/#80-remove-duplicates-from-sorted-array-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( int num : nums ) if ( i < 2 || num != nums [ i - 2 ]) nums [ i ++ ] = num ; return i ; } };","title":"80. Remove Duplicates from Sorted Array II $\\star\\star$"},{"location":"golang/0001-0100/0081-0090/","text":"81. Search in Rotated Sorted Array II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ]) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return false ; } }; 82. Remove Duplicates from Sorted List II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; while ( head ) { while ( head -> next && head -> val == head -> next -> val ) head = head -> next ; if ( prev -> next == head ) prev = prev -> next ; else prev -> next = head -> next ; head = head -> next ; } return dummy . next ; } }; 83. Remove Duplicates from Sorted List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode * curr = head ; while ( curr ) { while ( curr -> next && curr -> val == curr -> next -> val ) curr -> next = curr -> next -> next ; curr = curr -> next ; } return head ; } }; 84. Largest Rectangle in Histogram $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ i ] < heights [ stack . top ()])) { int h = heights [ stack . top ()]; stack . pop (); int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } }; 85. Maximal Rectangle $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; int ans = 0 ; vector < int > temp ( matrix [ 0 ]. size ()); for ( int i = 0 ; i < matrix . size (); ++ i ) { for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) temp [ j ] = matrix [ i ][ j ] == '0' ? 0 : temp [ j ] + 1 ; ans = max ( ans , largestRectangleArea ( temp )); } return ans ; } private : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ i ] < heights [ stack . top ()])) { int h = heights [ stack . top ()]; stack . pop (); int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } }; 86. Partition List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode beforeHead ( 0 ); ListNode afterHead ( 0 ); ListNode * before = & beforeHead ; ListNode * after = & afterHead ; while ( head ) { if ( head -> val < x ) { before -> next = head ; before = before -> next ; } else { after -> next = head ; after = after -> next ; } head = head -> next ; } after -> next = NULL ; before -> next = afterHead . next ; return beforeHead . next ; }; }; 87. Scramble String $\\star\\star\\star$ 88. Merge Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int k = m + n ; while ( n > 0 ) { if ( m > 0 && nums1 [ m - 1 ] > nums2 [ n - 1 ]) nums1 [ -- k ] = nums1 [ -- m ]; else nums1 [ -- k ] = nums2 [ -- n ]; } } }; 89. Gray Code $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > grayCode ( int n ) { vector < int > ans = { 0 }; for ( int i = 0 ; i < n ; ++ i ) for ( int j = ans . size () - 1 ; j >= 0 ; -- j ) ans . push_back ( ans [ j ] | 1 << i ); return ans ; } }; 90. Subsets II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; sort ( nums . begin (), nums . end ()); dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { ans . push_back ( path ); if ( s == nums . size ()) return ; for ( int i = s ; i < nums . size (); ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } };","title":"0081-0090"},{"location":"golang/0001-0100/0081-0090/#81-search-in-rotated-sorted-array-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ]) { ++ l ; -- r ; } else if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return false ; } };","title":"81. Search in Rotated Sorted Array II $\\star\\star$"},{"location":"golang/0001-0100/0081-0090/#82-remove-duplicates-from-sorted-list-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; while ( head ) { while ( head -> next && head -> val == head -> next -> val ) head = head -> next ; if ( prev -> next == head ) prev = prev -> next ; else prev -> next = head -> next ; head = head -> next ; } return dummy . next ; } };","title":"82. Remove Duplicates from Sorted List II $\\star\\star$"},{"location":"golang/0001-0100/0081-0090/#83-remove-duplicates-from-sorted-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode * curr = head ; while ( curr ) { while ( curr -> next && curr -> val == curr -> next -> val ) curr -> next = curr -> next -> next ; curr = curr -> next ; } return head ; } };","title":"83. Remove Duplicates from Sorted List $\\star$"},{"location":"golang/0001-0100/0081-0090/#84-largest-rectangle-in-histogram-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ i ] < heights [ stack . top ()])) { int h = heights [ stack . top ()]; stack . pop (); int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } };","title":"84. Largest Rectangle in Histogram $\\star\\star\\star$"},{"location":"golang/0001-0100/0081-0090/#85-maximal-rectangle-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; int ans = 0 ; vector < int > temp ( matrix [ 0 ]. size ()); for ( int i = 0 ; i < matrix . size (); ++ i ) { for ( int j = 0 ; j < matrix [ 0 ]. size (); ++ j ) temp [ j ] = matrix [ i ][ j ] == '0' ? 0 : temp [ j ] + 1 ; ans = max ( ans , largestRectangleArea ( temp )); } return ans ; } private : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); ++ i ) { while ( ! stack . empty () && ( i == heights . size () || heights [ i ] < heights [ stack . top ()])) { int h = heights [ stack . top ()]; stack . pop (); int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } };","title":"85. Maximal Rectangle $\\star\\star\\star$"},{"location":"golang/0001-0100/0081-0090/#86-partition-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode beforeHead ( 0 ); ListNode afterHead ( 0 ); ListNode * before = & beforeHead ; ListNode * after = & afterHead ; while ( head ) { if ( head -> val < x ) { before -> next = head ; before = before -> next ; } else { after -> next = head ; after = after -> next ; } head = head -> next ; } after -> next = NULL ; before -> next = afterHead . next ; return beforeHead . next ; }; };","title":"86. Partition List $\\star\\star$"},{"location":"golang/0001-0100/0081-0090/#87-scramble-string-starstarstar","text":"","title":"87. Scramble String $\\star\\star\\star$"},{"location":"golang/0001-0100/0081-0090/#88-merge-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int k = m + n ; while ( n > 0 ) { if ( m > 0 && nums1 [ m - 1 ] > nums2 [ n - 1 ]) nums1 [ -- k ] = nums1 [ -- m ]; else nums1 [ -- k ] = nums2 [ -- n ]; } } };","title":"88. Merge Sorted Array $\\star$"},{"location":"golang/0001-0100/0081-0090/#89-gray-code-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > grayCode ( int n ) { vector < int > ans = { 0 }; for ( int i = 0 ; i < n ; ++ i ) for ( int j = ans . size () - 1 ; j >= 0 ; -- j ) ans . push_back ( ans [ j ] | 1 << i ); return ans ; } };","title":"89. Gray Code $\\star\\star$"},{"location":"golang/0001-0100/0081-0090/#90-subsets-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; sort ( nums . begin (), nums . end ()); dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { ans . push_back ( path ); if ( s == nums . size ()) return ; for ( int i = s ; i < nums . size (); ++ i ) { if ( i > s && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } };","title":"90. Subsets II $\\star\\star$"},{"location":"golang/0001-0100/0091-0100/","text":"91. Decode Ways $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int numDecodings ( string s ) { if ( s . empty () || s [ 0 ] == '0' ) return 0 ; if ( s . length () == 1 ) return 1 ; int dp1 = 1 ; int dp2 = 1 ; for ( int i = 1 ; i < s . length (); ++ i ) { int dp = 0 ; if ( ! isValid ( s [ i ]) && ! isValid ( s [ i - 1 ], s [ i ])) return 0 ; if ( isValid ( s [ i ])) dp += dp1 ; if ( isValid ( s [ i - 1 ], s [ i ])) dp += dp2 ; dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : bool isValid ( char c ) { return c != '0' ; } bool isValid ( char c1 , char c2 ) { return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } }; 92. Reverse Linked List II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { if ( ! head ) return NULL ; ListNode * prev = NULL ; ListNode * curr = head ; for ( int i = 0 ; i < m - 1 ; ++ i ) { prev = curr ; curr = curr -> next ; } ListNode * conn = prev ; ListNode * tail = curr ; for ( int i = 0 ; i < n - m + 1 ; ++ i ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } if ( conn ) conn -> next = prev ; else head = prev ; tail -> next = curr ; return head ; } }; 93. Restore IP Addresses $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < string > restoreIpAddresses ( string s ) { vector < string > ans ; vector < string > path ( 4 ); dfs ( s , 0 , 0 , path , ans ); return ans ; } void dfs ( string s , int depth , int index , vector < string >& path , vector < string >& ans ) { if ( depth == 4 && index == s . length ()) { ans . push_back ( path [ 0 ] + \".\" + path [ 1 ] + \".\" + path [ 2 ] + \".\" + path [ 3 ]); return ; } if ( depth == 4 || index == s . length ()) return ; for ( int i = 1 ; i <= 3 ; ++ i ) { if ( index + i > s . length ()) return ; if ( i > 1 && s [ index ] == '0' ) return ; string temp = s . substr ( index , i ); if ( stoi ( temp ) > 255 ) return ; path [ depth ] = temp ; dfs ( s , depth + 1 , index + i , path , ans ); path [ depth ] = \"\" ; } } }; 94. Binary Tree Inorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > ans ; stack < TreeNode *> stack ; TreeNode * curr = root ; while ( curr || ! stack . empty ()) { while ( curr ) { stack . push ( curr ); curr = curr -> left ; } curr = stack . top (); stack . pop (); ans . push_back ( curr -> val ); curr = curr -> right ; } return ans ; } }; 95. Unique Binary Search Trees II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < TreeNode *> generateTrees ( int n ) { if ( n == 0 ) return {}; return helper ( 1 , n ); } private : vector < TreeNode *> helper ( int min , int max ) { vector < TreeNode *> ans ; if ( min > max ) { ans . push_back ( NULL ); return ans ; } for ( int i = min ; i <= max ; ++ i ) { vector < TreeNode *> leftTree = helper ( min , i - 1 ); vector < TreeNode *> rightTree = helper ( i + 1 , max ); for ( TreeNode * left : leftTree ) for ( TreeNode * right : rightTree ) { TreeNode * root = new TreeNode ( i ); root -> left = left ; root -> right = right ; ans . push_back ( root ); } } return ans ; } }; 96. Unique Binary Search Trees $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int numTrees ( int n ) { vector < int > G ( n + 1 ); G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ]; return G [ n ]; } }; 97. Interleaving String $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { if ( s1 . length () + s2 . length () != s3 . length ()) return false ; vector < bool > dp ( s2 . length () + 1 ); for ( int i = 0 ; i <= s1 . length (); ++ i ) for ( int j = 0 ; j <= s2 . length (); ++ j ) { if ( i == 0 && j == 0 ) dp [ j ] = true ; else if ( i == 0 ) dp [ j ] = dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]; else if ( j == 0 ) dp [ j ] = dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]; else dp [ j ] = ( dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]) || ( dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]); } return dp [ s2 . length ()]; } }; 98. Validate Binary Search Tree $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isValidBST ( TreeNode * root ) { return helper ( root , NULL , NULL ); } private : bool helper ( TreeNode * root , TreeNode * minNode , TreeNode * maxNode ) { if ( ! root ) return true ; if ( minNode && root -> val <= minNode -> val || maxNode && root -> val >= maxNode -> val ) return false ; return helper ( root -> left , minNode , root ) && helper ( root -> right , root , maxNode ); } }; 99. Recover Binary Search Tree $\\star\\star\\star$ 100. Same Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } };","title":"0091-0100"},{"location":"golang/0001-0100/0091-0100/#91-decode-ways-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int numDecodings ( string s ) { if ( s . empty () || s [ 0 ] == '0' ) return 0 ; if ( s . length () == 1 ) return 1 ; int dp1 = 1 ; int dp2 = 1 ; for ( int i = 1 ; i < s . length (); ++ i ) { int dp = 0 ; if ( ! isValid ( s [ i ]) && ! isValid ( s [ i - 1 ], s [ i ])) return 0 ; if ( isValid ( s [ i ])) dp += dp1 ; if ( isValid ( s [ i - 1 ], s [ i ])) dp += dp2 ; dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : bool isValid ( char c ) { return c != '0' ; } bool isValid ( char c1 , char c2 ) { return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } };","title":"91. Decode Ways $\\star\\star$"},{"location":"golang/0001-0100/0091-0100/#92-reverse-linked-list-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { if ( ! head ) return NULL ; ListNode * prev = NULL ; ListNode * curr = head ; for ( int i = 0 ; i < m - 1 ; ++ i ) { prev = curr ; curr = curr -> next ; } ListNode * conn = prev ; ListNode * tail = curr ; for ( int i = 0 ; i < n - m + 1 ; ++ i ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } if ( conn ) conn -> next = prev ; else head = prev ; tail -> next = curr ; return head ; } };","title":"92. Reverse Linked List II $\\star\\star$"},{"location":"golang/0001-0100/0091-0100/#93-restore-ip-addresses-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < string > restoreIpAddresses ( string s ) { vector < string > ans ; vector < string > path ( 4 ); dfs ( s , 0 , 0 , path , ans ); return ans ; } void dfs ( string s , int depth , int index , vector < string >& path , vector < string >& ans ) { if ( depth == 4 && index == s . length ()) { ans . push_back ( path [ 0 ] + \".\" + path [ 1 ] + \".\" + path [ 2 ] + \".\" + path [ 3 ]); return ; } if ( depth == 4 || index == s . length ()) return ; for ( int i = 1 ; i <= 3 ; ++ i ) { if ( index + i > s . length ()) return ; if ( i > 1 && s [ index ] == '0' ) return ; string temp = s . substr ( index , i ); if ( stoi ( temp ) > 255 ) return ; path [ depth ] = temp ; dfs ( s , depth + 1 , index + i , path , ans ); path [ depth ] = \"\" ; } } };","title":"93. Restore IP Addresses $\\star\\star$"},{"location":"golang/0001-0100/0091-0100/#94-binary-tree-inorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > ans ; stack < TreeNode *> stack ; TreeNode * curr = root ; while ( curr || ! stack . empty ()) { while ( curr ) { stack . push ( curr ); curr = curr -> left ; } curr = stack . top (); stack . pop (); ans . push_back ( curr -> val ); curr = curr -> right ; } return ans ; } };","title":"94. Binary Tree Inorder Traversal $\\star\\star$"},{"location":"golang/0001-0100/0091-0100/#95-unique-binary-search-trees-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < TreeNode *> generateTrees ( int n ) { if ( n == 0 ) return {}; return helper ( 1 , n ); } private : vector < TreeNode *> helper ( int min , int max ) { vector < TreeNode *> ans ; if ( min > max ) { ans . push_back ( NULL ); return ans ; } for ( int i = min ; i <= max ; ++ i ) { vector < TreeNode *> leftTree = helper ( min , i - 1 ); vector < TreeNode *> rightTree = helper ( i + 1 , max ); for ( TreeNode * left : leftTree ) for ( TreeNode * right : rightTree ) { TreeNode * root = new TreeNode ( i ); root -> left = left ; root -> right = right ; ans . push_back ( root ); } } return ans ; } };","title":"95. Unique Binary Search Trees II $\\star\\star$"},{"location":"golang/0001-0100/0091-0100/#96-unique-binary-search-trees-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int numTrees ( int n ) { vector < int > G ( n + 1 ); G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; ++ i ) for ( int j = 0 ; j < i ; ++ j ) G [ i ] += G [ j ] * G [ i - j - 1 ]; return G [ n ]; } };","title":"96. Unique Binary Search Trees $\\star\\star$"},{"location":"golang/0001-0100/0091-0100/#97-interleaving-string-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { if ( s1 . length () + s2 . length () != s3 . length ()) return false ; vector < bool > dp ( s2 . length () + 1 ); for ( int i = 0 ; i <= s1 . length (); ++ i ) for ( int j = 0 ; j <= s2 . length (); ++ j ) { if ( i == 0 && j == 0 ) dp [ j ] = true ; else if ( i == 0 ) dp [ j ] = dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]; else if ( j == 0 ) dp [ j ] = dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]; else dp [ j ] = ( dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]) || ( dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]); } return dp [ s2 . length ()]; } };","title":"97. Interleaving String $\\star\\star\\star$"},{"location":"golang/0001-0100/0091-0100/#98-validate-binary-search-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isValidBST ( TreeNode * root ) { return helper ( root , NULL , NULL ); } private : bool helper ( TreeNode * root , TreeNode * minNode , TreeNode * maxNode ) { if ( ! root ) return true ; if ( minNode && root -> val <= minNode -> val || maxNode && root -> val >= maxNode -> val ) return false ; return helper ( root -> left , minNode , root ) && helper ( root -> right , root , maxNode ); } };","title":"98. Validate Binary Search Tree $\\star\\star$"},{"location":"golang/0001-0100/0091-0100/#99-recover-binary-search-tree-starstarstar","text":"","title":"99. Recover Binary Search Tree $\\star\\star\\star$"},{"location":"golang/0001-0100/0091-0100/#100-same-tree-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } };","title":"100. Same Tree $\\star$"},{"location":"golang/0101-0200/0101-0110/","text":"101. Symmetric Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isSymmetric ( TreeNode * root ) { return helper ( root , root ); } private : bool helper ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && helper ( p -> left , q -> right ) && helper ( p -> right , q -> left ); } }; 102. Binary Tree Level Order Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode * node = queue . front (); queue . pop (); currLevel . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } ans . push_back ( currLevel ); } return ans ; } }; 103. Binary Tree Zigzag Level Order Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; deque < TreeNode *> deque ; deque . push_back ( root ); bool isLeftToRight = true ; while ( ! deque . empty ()) { vector < int > currLevel ; for ( int i = deque . size (); i > 0 ; -- i ) { if ( isLeftToRight ) { TreeNode * node = deque . front (); deque . pop_front (); currLevel . push_back ( node -> val ); if ( node -> left ) deque . push_back ( node -> left ); if ( node -> right ) deque . push_back ( node -> right ); } else { TreeNode * node = deque . back (); deque . pop_back (); currLevel . push_back ( node -> val ); if ( node -> right ) deque . push_front ( node -> right ); if ( node -> left ) deque . push_front ( node -> left ); } } ans . push_back ( currLevel ); isLeftToRight = ! isLeftToRight ; } return ans ; } }; 104. Maximum Depth of Binary Tree $\\star$ 1 2 3 4 5 6 7 8 class Solution { public : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } }; 105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { unordered_map < int , int > map ; for ( int i = 0 ; i < inorder . size (); ++ i ) map [ inorder [ i ]] = i ; return helper ( preorder , 0 , preorder . size () - 1 , inorder , 0 , inorder . size () - 1 , map ); } TreeNode * helper ( vector < int >& preorder , int pLeft , int pRight , vector < int >& inorder , int iLeft , int iRight , unordered_map < int , int >& map ) { if ( pLeft > pRight || iLeft > iRight ) return nullptr ; int i = map [ preorder [ pLeft ]]; TreeNode * curr = new TreeNode ( preorder [ pLeft ]); curr -> left = helper ( preorder , pLeft + 1 , pLeft + i - iLeft , inorder , iLeft , i - 1 , map ); curr -> right = helper ( preorder , pLeft + i - iLeft + 1 , pRight , inorder , i + 1 , iRight , map ); return curr ; } }; 106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { unordered_map < int , int > map ; for ( int i = 0 ; i < inorder . size (); ++ i ) map [ inorder [ i ]] = i ; return helper ( inorder , 0 , inorder . size () - 1 , postorder , 0 , postorder . size () - 1 , map ); } TreeNode * helper ( vector < int >& inorder , int iLeft , int iRight , vector < int >& postorder , int pLeft , int pRight , unordered_map < int , int >& map ) { if ( iLeft > iRight || pLeft > pRight ) return nullptr ; int i = map [ postorder [ pRight ]]; TreeNode * curr = new TreeNode ( postorder [ pRight ]); curr -> left = helper ( inorder , iLeft , i - 1 , postorder , pLeft , pLeft + i - iLeft - 1 , map ); curr -> right = helper ( inorder , i + 1 , iRight , postorder , pLeft + i - iLeft , pRight - 1 , map ); return curr ; } }; 107. Binary Tree Level Order Traversal II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> levelOrderBottom ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode * node = queue . front (); queue . pop (); currLevel . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } ans . insert ( ans . begin (), currLevel ); } return ans ; } }; 108. Convert Sorted Array to Binary Search Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : TreeNode * sortedArrayToBST ( vector < int >& nums ) { return helper ( nums , 0 , nums . size () - 1 ); } private : TreeNode * helper ( vector < int >& nums , int l , int r ) { if ( l > r ) return NULL ; int mid = ( l + r ) >> 1 ; TreeNode * root = new TreeNode ( nums [ mid ]); root -> left = helper ( nums , l , mid - 1 ); root -> right = helper ( nums , mid + 1 , r ); return root ; } }; 109. Convert Sorted List to Binary Search Tree $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : TreeNode * sortedListToBST ( ListNode * head ) { int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; this -> head = head ; return helper ( 0 , length - 1 ); } private : ListNode * head ; TreeNode * helper ( int l , int r ) { if ( l > r ) return NULL ; int mid = ( l + r ) >> 1 ; TreeNode * left = helper ( l , mid - 1 ); TreeNode * node = new TreeNode ( head -> val ); head = head -> next ; node -> left = left ; node -> right = helper ( mid + 1 , r ); return node ; } }; 110. Balanced Binary Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isBalanced ( TreeNode * root ) { if ( ! root ) return true ; return abs ( maxDepth ( root -> left ) - maxDepth ( root -> right )) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ); } private : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } };","title":"0101-0110"},{"location":"golang/0101-0200/0101-0110/#101-symmetric-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isSymmetric ( TreeNode * root ) { return helper ( root , root ); } private : bool helper ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && helper ( p -> left , q -> right ) && helper ( p -> right , q -> left ); } };","title":"101. Symmetric Tree $\\star$"},{"location":"golang/0101-0200/0101-0110/#102-binary-tree-level-order-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode * node = queue . front (); queue . pop (); currLevel . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } ans . push_back ( currLevel ); } return ans ; } };","title":"102. Binary Tree Level Order Traversal $\\star\\star$"},{"location":"golang/0101-0200/0101-0110/#103-binary-tree-zigzag-level-order-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; deque < TreeNode *> deque ; deque . push_back ( root ); bool isLeftToRight = true ; while ( ! deque . empty ()) { vector < int > currLevel ; for ( int i = deque . size (); i > 0 ; -- i ) { if ( isLeftToRight ) { TreeNode * node = deque . front (); deque . pop_front (); currLevel . push_back ( node -> val ); if ( node -> left ) deque . push_back ( node -> left ); if ( node -> right ) deque . push_back ( node -> right ); } else { TreeNode * node = deque . back (); deque . pop_back (); currLevel . push_back ( node -> val ); if ( node -> right ) deque . push_front ( node -> right ); if ( node -> left ) deque . push_front ( node -> left ); } } ans . push_back ( currLevel ); isLeftToRight = ! isLeftToRight ; } return ans ; } };","title":"103. Binary Tree Zigzag Level Order Traversal $\\star\\star$"},{"location":"golang/0101-0200/0101-0110/#104-maximum-depth-of-binary-tree-star","text":"1 2 3 4 5 6 7 8 class Solution { public : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } };","title":"104. Maximum Depth of Binary Tree $\\star$"},{"location":"golang/0101-0200/0101-0110/#105-construct-binary-tree-from-preorder-and-inorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { unordered_map < int , int > map ; for ( int i = 0 ; i < inorder . size (); ++ i ) map [ inorder [ i ]] = i ; return helper ( preorder , 0 , preorder . size () - 1 , inorder , 0 , inorder . size () - 1 , map ); } TreeNode * helper ( vector < int >& preorder , int pLeft , int pRight , vector < int >& inorder , int iLeft , int iRight , unordered_map < int , int >& map ) { if ( pLeft > pRight || iLeft > iRight ) return nullptr ; int i = map [ preorder [ pLeft ]]; TreeNode * curr = new TreeNode ( preorder [ pLeft ]); curr -> left = helper ( preorder , pLeft + 1 , pLeft + i - iLeft , inorder , iLeft , i - 1 , map ); curr -> right = helper ( preorder , pLeft + i - iLeft + 1 , pRight , inorder , i + 1 , iRight , map ); return curr ; } };","title":"105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$"},{"location":"golang/0101-0200/0101-0110/#106-construct-binary-tree-from-inorder-and-postorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { unordered_map < int , int > map ; for ( int i = 0 ; i < inorder . size (); ++ i ) map [ inorder [ i ]] = i ; return helper ( inorder , 0 , inorder . size () - 1 , postorder , 0 , postorder . size () - 1 , map ); } TreeNode * helper ( vector < int >& inorder , int iLeft , int iRight , vector < int >& postorder , int pLeft , int pRight , unordered_map < int , int >& map ) { if ( iLeft > iRight || pLeft > pRight ) return nullptr ; int i = map [ postorder [ pRight ]]; TreeNode * curr = new TreeNode ( postorder [ pRight ]); curr -> left = helper ( inorder , iLeft , i - 1 , postorder , pLeft , pLeft + i - iLeft - 1 , map ); curr -> right = helper ( inorder , i + 1 , iRight , postorder , pLeft + i - iLeft , pRight - 1 , map ); return curr ; } };","title":"106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$"},{"location":"golang/0101-0200/0101-0110/#107-binary-tree-level-order-traversal-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> levelOrderBottom ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode * node = queue . front (); queue . pop (); currLevel . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } ans . insert ( ans . begin (), currLevel ); } return ans ; } };","title":"107. Binary Tree Level Order Traversal II $\\star$"},{"location":"golang/0101-0200/0101-0110/#108-convert-sorted-array-to-binary-search-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : TreeNode * sortedArrayToBST ( vector < int >& nums ) { return helper ( nums , 0 , nums . size () - 1 ); } private : TreeNode * helper ( vector < int >& nums , int l , int r ) { if ( l > r ) return NULL ; int mid = ( l + r ) >> 1 ; TreeNode * root = new TreeNode ( nums [ mid ]); root -> left = helper ( nums , l , mid - 1 ); root -> right = helper ( nums , mid + 1 , r ); return root ; } };","title":"108. Convert Sorted Array to Binary Search Tree $\\star$"},{"location":"golang/0101-0200/0101-0110/#109-convert-sorted-list-to-binary-search-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : TreeNode * sortedListToBST ( ListNode * head ) { int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; this -> head = head ; return helper ( 0 , length - 1 ); } private : ListNode * head ; TreeNode * helper ( int l , int r ) { if ( l > r ) return NULL ; int mid = ( l + r ) >> 1 ; TreeNode * left = helper ( l , mid - 1 ); TreeNode * node = new TreeNode ( head -> val ); head = head -> next ; node -> left = left ; node -> right = helper ( mid + 1 , r ); return node ; } };","title":"109. Convert Sorted List to Binary Search Tree $\\star\\star$"},{"location":"golang/0101-0200/0101-0110/#110-balanced-binary-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isBalanced ( TreeNode * root ) { if ( ! root ) return true ; return abs ( maxDepth ( root -> left ) - maxDepth ( root -> right )) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ); } private : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } };","title":"110. Balanced Binary Tree $\\star$"},{"location":"golang/0101-0200/0111-0120/","text":"111. Minimum Depth of Binary Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { ++ ans ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode * node = queue . front (); queue . pop (); if ( ! node -> left && ! node -> right ) return ans ; if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } } return - 1 ; } }; 112. Path Sum $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; if ( root -> val == sum && ! root -> left && ! root -> right ) return true ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ); } }; 113. Path Sum II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int sum ) { vector < vector < int >> ans ; vector < int > path ; dfs ( root , sum , path , ans ); return ans ; } private : void dfs ( TreeNode * root , int sum , vector < int >& path , vector < vector < int >>& ans ) { if ( ! root ) return ; if ( sum == root -> val && ! root -> left && ! root -> right ) { path . push_back ( root -> val ); ans . push_back ( path ); path . pop_back (); return ; } path . push_back ( root -> val ); dfs ( root -> left , sum - root -> val , path , ans ); dfs ( root -> right , sum - root -> val , path , ans ); path . pop_back (); } }; 114. Flatten Binary Tree to Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : void flatten ( TreeNode * root ) { if ( ! root ) return ; flatten ( root -> right ); flatten ( root -> left ); root -> right = next ; root -> left = NULL ; next = root ; } private : TreeNode * next = NULL ; }; 115. Distinct Subsequences $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int numDistinct ( string s , string t ) { const int m = s . length (); const int n = t . length (); vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) { if ( j == 0 ) dp [ i ][ j ] = 1 ; else if ( i == 0 ) dp [ i ][ j ] = 0 ; else dp [ i ][ j ] = dp [ i - 1 ][ j ] + ( s [ i - 1 ] == t [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] : 0 ); } return dp [ m ][ n ]; } }; 116. Populating Next Right Pointers in Each Node $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; while ( node && node -> left ) { Node * next = node -> left ; while ( node ) { node -> left -> next = node -> right ; node -> right -> next = node -> next ? node -> next -> left : NULL ; node = node -> next ; } node = next ; } return root ; } }; 117. Populating Next Right Pointers in Each Node II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; Node * curr = new Node ( NULL ); Node * prev = curr ; while ( node ) { while ( node ) { curr -> next = node -> left ; if ( curr -> next ) curr = curr -> next ; curr -> next = node -> right ; if ( curr -> next ) curr = curr -> next ; node = node -> next ; } node = prev -> next ; curr = prev ; } return root ; } }; 118. Pascal's Triangle $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> ans ; for ( int i = 0 ; i < numRows ; ++ i ) ans . push_back ( vector < int > ( i + 1 , 1 )); for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans [ i ]. size () - 1 ; ++ j ) ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ]; return ans ; } }; 119. Pascal's Triangle II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > ans ( rowIndex + 1 , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ]; return ans ; } }; 120. Triangle $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int minimumTotal ( vector < vector < int >>& triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]); return triangle [ 0 ][ 0 ]; } };","title":"0111-0120"},{"location":"golang/0101-0200/0111-0120/#111-minimum-depth-of-binary-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { ++ ans ; for ( int i = queue . size (); i > 0 ; -- i ) { TreeNode * node = queue . front (); queue . pop (); if ( ! node -> left && ! node -> right ) return ans ; if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } } return - 1 ; } };","title":"111. Minimum Depth of Binary Tree $\\star$"},{"location":"golang/0101-0200/0111-0120/#112-path-sum-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; if ( root -> val == sum && ! root -> left && ! root -> right ) return true ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ); } };","title":"112. Path Sum $\\star$"},{"location":"golang/0101-0200/0111-0120/#113-path-sum-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int sum ) { vector < vector < int >> ans ; vector < int > path ; dfs ( root , sum , path , ans ); return ans ; } private : void dfs ( TreeNode * root , int sum , vector < int >& path , vector < vector < int >>& ans ) { if ( ! root ) return ; if ( sum == root -> val && ! root -> left && ! root -> right ) { path . push_back ( root -> val ); ans . push_back ( path ); path . pop_back (); return ; } path . push_back ( root -> val ); dfs ( root -> left , sum - root -> val , path , ans ); dfs ( root -> right , sum - root -> val , path , ans ); path . pop_back (); } };","title":"113. Path Sum II $\\star\\star$"},{"location":"golang/0101-0200/0111-0120/#114-flatten-binary-tree-to-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : void flatten ( TreeNode * root ) { if ( ! root ) return ; flatten ( root -> right ); flatten ( root -> left ); root -> right = next ; root -> left = NULL ; next = root ; } private : TreeNode * next = NULL ; };","title":"114. Flatten Binary Tree to Linked List $\\star\\star$"},{"location":"golang/0101-0200/0111-0120/#115-distinct-subsequences-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int numDistinct ( string s , string t ) { const int m = s . length (); const int n = t . length (); vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 )); for ( int i = 0 ; i <= m ; ++ i ) for ( int j = 0 ; j <= n ; ++ j ) { if ( j == 0 ) dp [ i ][ j ] = 1 ; else if ( i == 0 ) dp [ i ][ j ] = 0 ; else dp [ i ][ j ] = dp [ i - 1 ][ j ] + ( s [ i - 1 ] == t [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] : 0 ); } return dp [ m ][ n ]; } };","title":"115. Distinct Subsequences $\\star\\star\\star$"},{"location":"golang/0101-0200/0111-0120/#116-populating-next-right-pointers-in-each-node-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; while ( node && node -> left ) { Node * next = node -> left ; while ( node ) { node -> left -> next = node -> right ; node -> right -> next = node -> next ? node -> next -> left : NULL ; node = node -> next ; } node = next ; } return root ; } };","title":"116. Populating Next Right Pointers in Each Node $\\star\\star$"},{"location":"golang/0101-0200/0111-0120/#117-populating-next-right-pointers-in-each-node-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; Node * curr = new Node ( NULL ); Node * prev = curr ; while ( node ) { while ( node ) { curr -> next = node -> left ; if ( curr -> next ) curr = curr -> next ; curr -> next = node -> right ; if ( curr -> next ) curr = curr -> next ; node = node -> next ; } node = prev -> next ; curr = prev ; } return root ; } };","title":"117. Populating Next Right Pointers in Each Node II $\\star\\star$"},{"location":"golang/0101-0200/0111-0120/#118-pascals-triangle-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> ans ; for ( int i = 0 ; i < numRows ; ++ i ) ans . push_back ( vector < int > ( i + 1 , 1 )); for ( int i = 2 ; i < numRows ; ++ i ) for ( int j = 1 ; j < ans [ i ]. size () - 1 ; ++ j ) ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ]; return ans ; } };","title":"118. Pascal's Triangle $\\star$"},{"location":"golang/0101-0200/0111-0120/#119-pascals-triangle-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > ans ( rowIndex + 1 , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; ++ i ) for ( int j = 1 ; j < i ; ++ j ) ans [ i - j ] += ans [ i - j - 1 ]; return ans ; } };","title":"119. Pascal's Triangle II $\\star$"},{"location":"golang/0101-0200/0111-0120/#120-triangle-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int minimumTotal ( vector < vector < int >>& triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; -- i ) for ( int j = 0 ; j <= i ; ++ j ) triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]); return triangle [ 0 ][ 0 ]; } };","title":"120. Triangle $\\star\\star$"},{"location":"golang/0101-0200/0121-0130/","text":"121. Best Time to Buy and Sell Stock $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellOne = 0 ; int holdOne = INT_MIN ; for ( int price : prices ) { sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellOne ; } }; 122. Best Time to Buy and Sell Stock II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } }; 123. Best Time to Buy and Sell Stock III $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellTwo = 0 ; int holdTwo = INT_MIN ; int sellOne = 0 ; int holdOne = INT_MIN ; for ( int price : prices ) { sellTwo = max ( sellTwo , holdTwo + price ); holdTwo = max ( holdTwo , sellOne - price ); sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellTwo ; } }; 124. Binary Tree Maximum Path Sum $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int maxPathSum ( TreeNode * root ) { helper ( root ); return ans ; } private : int ans = INT_MIN ; int helper ( TreeNode * root ) { if ( ! root ) return 0 ; int left = max ( helper ( root -> left ), 0 ); int right = max ( helper ( root -> right ), 0 ); ans = max ( ans , root -> val + left + right ); return root -> val + max ( left , right ); } }; 125. Valid Palindrome $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isPalindrome ( string s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! isalnum ( s [ l ])) ++ l ; while ( l < r && ! isalnum ( s [ r ])) -- r ; if ( tolower ( s [ l ]) != tolower ( s [ r ])) return false ; ++ l ; -- r ; } return true ; } }; 126. Word Ladder II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> ans ; unordered_set < string > set ( wordList . begin (), wordList . end ()); if ( ! set . count ( endWord )) return ans ; unordered_set < string > set1 = { beginWord }; unordered_map < string , vector < string >> map ; bool isFound = false ; while ( ! set1 . empty () && ! isFound ) { for ( const string & word : set1 ) set . erase ( word ); unordered_set < string > tempSet ; for ( const string & parent : set1 ) { string word = parent ; for ( int i = 0 ; i < word . length (); ++ i ) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; ++ j ) { word [ i ] = j ; if ( word == endWord ) { map [ parent ]. push_back ( word ); isFound = true ; } else if ( set . count ( word ) && ! isFound ) { tempSet . insert ( word ); map [ parent ]. push_back ( word ); } } word [ i ] = c ; } } swap ( set1 , tempSet ); } if ( isFound ) { vector < string > path = { beginWord }; dfs ( map , beginWord , endWord , path , ans ); } return ans ; } private : void dfs ( const unordered_map < string , vector < string >>& map , const string & word , const string & endWord , vector < string >& path , vector < vector < string >>& ans ) { if ( word == endWord ) { ans . push_back ( path ); return ; } if ( map . find ( word ) == map . cend ()) return ; for ( const string & child : map . at ( word )) { path . push_back ( child ); dfs ( map , child , endWord , path , ans ); path . pop_back (); } } }; 127. Word Ladder $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > set ( wordList . begin (), wordList . end ()); if ( ! set . count ( endWord )) return 0 ; int ans = 0 ; unordered_set < string > set1 = { beginWord }; unordered_set < string > set2 = { endWord }; while ( ! set1 . empty () && ! set2 . empty ()) { ++ ans ; if ( set1 . size () > set2 . size ()) swap ( set1 , set2 ); unordered_set < string > tempSet ; for ( string word : set1 ) for ( int i = 0 ; i < word . length (); ++ i ) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; ++ j ) { word [ i ] = j ; if ( set2 . count ( word )) return ans + 1 ; if ( ! set . count ( word )) continue ; set . erase ( word ); tempSet . insert ( word ); } word [ i ] = c ; } swap ( set1 , tempSet ); } return 0 ; } }; 128. Longest Consecutive Sequence $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int longestConsecutive ( vector < int >& nums ) { int ans = 0 ; unordered_set < int > set ( nums . begin (), nums . end ()); for ( long num : nums ) if ( ! set . count ( num - 1 )) { int length = 0 ; while ( set . count ( num ++ )) ++ length ; ans = max ( ans , length ); } return ans ; } }; 129. Sum Root to Leaf Numbers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int sumNumbers ( TreeNode * root ) { int ans = 0 ; int path = 0 ; dfs ( root , path , ans ); return ans ; } private : void dfs ( TreeNode * root , int & path , int & ans ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { path = path * 10 + root -> val ; ans += path ; path = ( path - root -> val ) / 10 ; return ; } path = path * 10 + root -> val ; dfs ( root -> left , path , ans ); dfs ( root -> right , path , ans ); path = ( path - root -> val ) / 10 ; } }; 130. Surrounded Regions $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : void solve ( vector < vector < char >>& board ) { if ( board . empty ()) return ; const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) { dfs ( board , i , 0 ); dfs ( board , i , n - 1 ); } for ( int j = 1 ; j < n - 1 ; ++ j ) { dfs ( board , 0 , j ); dfs ( board , m - 1 , j ); } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] = board [ i ][ j ] == '.' ? 'O' : 'X' ; } private : void dfs ( vector < vector < char >>& board , int i , int j ) { if ( i < 0 || j < 0 || i >= board . size () || j >= board [ 0 ]. size () || board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '.' ; dfs ( board , i , j + 1 ); dfs ( board , i , j - 1 ); dfs ( board , i + 1 , j ); dfs ( board , i - 1 , j ); } };","title":"0121-0130"},{"location":"golang/0101-0200/0121-0130/#121-best-time-to-buy-and-sell-stock-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellOne = 0 ; int holdOne = INT_MIN ; for ( int price : prices ) { sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellOne ; } };","title":"121. Best Time to Buy and Sell Stock $\\star$"},{"location":"golang/0101-0200/0121-0130/#122-best-time-to-buy-and-sell-stock-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } };","title":"122. Best Time to Buy and Sell Stock II $\\star$"},{"location":"golang/0101-0200/0121-0130/#123-best-time-to-buy-and-sell-stock-iii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellTwo = 0 ; int holdTwo = INT_MIN ; int sellOne = 0 ; int holdOne = INT_MIN ; for ( int price : prices ) { sellTwo = max ( sellTwo , holdTwo + price ); holdTwo = max ( holdTwo , sellOne - price ); sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellTwo ; } };","title":"123. Best Time to Buy and Sell Stock III $\\star\\star\\star$"},{"location":"golang/0101-0200/0121-0130/#124-binary-tree-maximum-path-sum-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int maxPathSum ( TreeNode * root ) { helper ( root ); return ans ; } private : int ans = INT_MIN ; int helper ( TreeNode * root ) { if ( ! root ) return 0 ; int left = max ( helper ( root -> left ), 0 ); int right = max ( helper ( root -> right ), 0 ); ans = max ( ans , root -> val + left + right ); return root -> val + max ( left , right ); } };","title":"124. Binary Tree Maximum Path Sum $\\star\\star\\star$"},{"location":"golang/0101-0200/0121-0130/#125-valid-palindrome-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isPalindrome ( string s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! isalnum ( s [ l ])) ++ l ; while ( l < r && ! isalnum ( s [ r ])) -- r ; if ( tolower ( s [ l ]) != tolower ( s [ r ])) return false ; ++ l ; -- r ; } return true ; } };","title":"125. Valid Palindrome $\\star$"},{"location":"golang/0101-0200/0121-0130/#126-word-ladder-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> ans ; unordered_set < string > set ( wordList . begin (), wordList . end ()); if ( ! set . count ( endWord )) return ans ; unordered_set < string > set1 = { beginWord }; unordered_map < string , vector < string >> map ; bool isFound = false ; while ( ! set1 . empty () && ! isFound ) { for ( const string & word : set1 ) set . erase ( word ); unordered_set < string > tempSet ; for ( const string & parent : set1 ) { string word = parent ; for ( int i = 0 ; i < word . length (); ++ i ) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; ++ j ) { word [ i ] = j ; if ( word == endWord ) { map [ parent ]. push_back ( word ); isFound = true ; } else if ( set . count ( word ) && ! isFound ) { tempSet . insert ( word ); map [ parent ]. push_back ( word ); } } word [ i ] = c ; } } swap ( set1 , tempSet ); } if ( isFound ) { vector < string > path = { beginWord }; dfs ( map , beginWord , endWord , path , ans ); } return ans ; } private : void dfs ( const unordered_map < string , vector < string >>& map , const string & word , const string & endWord , vector < string >& path , vector < vector < string >>& ans ) { if ( word == endWord ) { ans . push_back ( path ); return ; } if ( map . find ( word ) == map . cend ()) return ; for ( const string & child : map . at ( word )) { path . push_back ( child ); dfs ( map , child , endWord , path , ans ); path . pop_back (); } } };","title":"126. Word Ladder II $\\star\\star\\star$"},{"location":"golang/0101-0200/0121-0130/#127-word-ladder-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > set ( wordList . begin (), wordList . end ()); if ( ! set . count ( endWord )) return 0 ; int ans = 0 ; unordered_set < string > set1 = { beginWord }; unordered_set < string > set2 = { endWord }; while ( ! set1 . empty () && ! set2 . empty ()) { ++ ans ; if ( set1 . size () > set2 . size ()) swap ( set1 , set2 ); unordered_set < string > tempSet ; for ( string word : set1 ) for ( int i = 0 ; i < word . length (); ++ i ) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; ++ j ) { word [ i ] = j ; if ( set2 . count ( word )) return ans + 1 ; if ( ! set . count ( word )) continue ; set . erase ( word ); tempSet . insert ( word ); } word [ i ] = c ; } swap ( set1 , tempSet ); } return 0 ; } };","title":"127. Word Ladder $\\star\\star$"},{"location":"golang/0101-0200/0121-0130/#128-longest-consecutive-sequence-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int longestConsecutive ( vector < int >& nums ) { int ans = 0 ; unordered_set < int > set ( nums . begin (), nums . end ()); for ( long num : nums ) if ( ! set . count ( num - 1 )) { int length = 0 ; while ( set . count ( num ++ )) ++ length ; ans = max ( ans , length ); } return ans ; } };","title":"128. Longest Consecutive Sequence $\\star\\star\\star$"},{"location":"golang/0101-0200/0121-0130/#129-sum-root-to-leaf-numbers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int sumNumbers ( TreeNode * root ) { int ans = 0 ; int path = 0 ; dfs ( root , path , ans ); return ans ; } private : void dfs ( TreeNode * root , int & path , int & ans ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { path = path * 10 + root -> val ; ans += path ; path = ( path - root -> val ) / 10 ; return ; } path = path * 10 + root -> val ; dfs ( root -> left , path , ans ); dfs ( root -> right , path , ans ); path = ( path - root -> val ) / 10 ; } };","title":"129. Sum Root to Leaf Numbers $\\star\\star$"},{"location":"golang/0101-0200/0121-0130/#130-surrounded-regions-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : void solve ( vector < vector < char >>& board ) { if ( board . empty ()) return ; const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) { dfs ( board , i , 0 ); dfs ( board , i , n - 1 ); } for ( int j = 1 ; j < n - 1 ; ++ j ) { dfs ( board , 0 , j ); dfs ( board , m - 1 , j ); } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] = board [ i ][ j ] == '.' ? 'O' : 'X' ; } private : void dfs ( vector < vector < char >>& board , int i , int j ) { if ( i < 0 || j < 0 || i >= board . size () || j >= board [ 0 ]. size () || board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '.' ; dfs ( board , i , j + 1 ); dfs ( board , i , j - 1 ); dfs ( board , i + 1 , j ); dfs ( board , i - 1 , j ); } };","title":"130. Surrounded Regions $\\star\\star$"},{"location":"golang/0101-0200/0131-0140/","text":"131. Palindrome Partitioning $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; vector < string > path ; dfs ( s , 0 , path , ans ); return ans ; } private : void dfs ( string & s , int j , vector < string >& path , vector < vector < string >>& ans ) { if ( j == s . length ()) { ans . push_back ( path ); return ; } for ( int i = j ; i < s . length (); ++ i ) if ( isPalindrome ( s , j , i )) { path . push_back ( s . substr ( j , i - j + 1 )); dfs ( s , i + 1 , path , ans ); path . pop_back (); } } bool isPalindrome ( string & s , int l , int r ) { while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } }; 132. Palindrome Partitioning II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int minCut ( string s ) { const int n = s . length (); vector < int > cut ( n ); vector < vector < bool >> dp ( n , vector < bool > ( n )); for ( int i = 0 ; i < n ; ++ i ) { int min = i ; for ( int j = 0 ; j <= i ; ++ j ) if ( s [ j ] == s [ i ] && ( j + 1 > i - 1 || dp [ j + 1 ][ i - 1 ])) { dp [ j ][ i ] = true ; min = j == 0 ? 0 : std :: min ( min , cut [ j - 1 ] + 1 ); } cut [ i ] = min ; } return cut [ n - 1 ]; } }; 133. Clone Graph $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : Node * cloneGraph ( Node * node ) { if ( ! node ) return NULL ; if ( map . count ( node )) return map [ node ]; map [ node ] = new Node ( node -> val , {}); for ( Node * neighbor : node -> neighbors ) map [ node ] -> neighbors . push_back ( cloneGraph ( neighbor )); return map [ node ]; } private : unordered_map < Node * , Node *> map ; }; 134. Gas Station $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int ans = 0 ; int net = 0 ; int sum = 0 ; for ( int i = 0 ; i < gas . size (); ++ i ) { net += gas [ i ] - cost [ i ]; sum += gas [ i ] - cost [ i ]; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; } } return net < 0 ? - 1 : ans ; } }; 135. Candy $\\star\\star\\star$ 136. Single Number $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) ans ^= num ; return ans ; } }; 137. Single Number II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int singleNumber ( vector < int >& nums ) { int ones = 0 ; int twos = 0 ; for ( int num : nums ) { ones ^= ( num & ~ twos ); twos ^= ( num & ~ ones ); } return ones ; } }; 138. Copy List with Random Pointer $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return NULL ; if ( map . count ( head )) return map [ head ]; map [ head ] = new Node ( head -> val , NULL , NULL ); map [ head ] -> next = copyRandomList ( head -> next ); map [ head ] -> random = copyRandomList ( head -> random ); return map [ head ]; } private : unordered_map < Node * , Node *> map ; }; 139. Word Break $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 func wordBreak ( s string , wordDict [] string ) bool { // return func1 ( s , wordDict ); // return func2 ( s , 0 , len ( s ) - 1 , wordDict ); // return func3 ( s , wordDict ); // return func4 ( s , wordDict ); // return func5 ( s , wordDict ); // return func6 ( s , wordDict ); // return func7 ( s , wordDict ); // return func8 ( s , wordDict ); return func9 ( s , wordDict ); } // 1. recursive func func1 ( s string , wordDict [] string ) bool { if len ( s ) == 0 { return true ; } for pos : = 0 ; pos <= len ( s ); pos ++ { for _ , word : = range wordDict { if s [ 0:pos ] == word && func1 ( s [ pos: ] , wordDict ) { return true ; } } } return false ; } // 2. recursive + string - optimize func func2 ( s string , lo int , hi int , wordDict [] string ) bool { if ( lo > hi ) { return true ; } for pos : = lo ; pos <= hi ; pos ++ { for _ , word : = range wordDict { if strCompHelper ( s , lo , pos , word ) && func2 ( s , pos + 1 , hi , wordDict ) { return true ; } } } return false ; } // 3. recursive + string - optimize + memo func func3 ( s string , wordDict [] string ) bool { N : = len ( s ); // 0 = init , 1 = false , 2 = true memo : = make ( [][] int , N ); for i : = 0 ; i < N ; i ++ { memo [ i ] = make ( [] int , N ); } return helper3 ( s , 0 , N - 1 , wordDict , memo ); } func helper3 ( s string , lo int , hi int , wordDict [] string , memo [][] int ) bool { if ( lo > hi ) { return true ; } if memo [ lo ][ hi ] == 1 { return false ; } else if memo [ lo ][ hi ] == 2 { return true ; } for pos : = lo ; pos <= hi ; pos ++ { for _ , word : = range wordDict { if strCompHelper ( s , lo , pos , word ) && helper3 ( s , pos + 1 , hi , wordDict , memo ) { memo [ lo ][ hi ] = 2 ; return true ; } } } memo [ lo ][ hi ] = 1 ; return false ; } // 4. recursive + string - optimize + memo + use - map - instead - of - array func func4 ( s string , wordDict [] string ) bool { N : = len ( s ); // 0 = init , 1 = false , 2 = true memo : = make ( [][] int , N ); for i : = 0 ; i < N ; i ++ { memo [ i ] = make ( [] int , N ); } wordMap : = make ( map [ string ] bool ); for i : = 0 ; i < len ( wordDict ); i ++ { wordMap [ wordDict[i ] ] = true ; } return helper4 ( s , 0 , N - 1 , wordMap , memo ); } func helper4 ( s string , lo int , hi int , wordMap map [ string ] bool , memo [][] int ) bool { if ( lo > hi ) { return true ; } if memo [ lo ][ hi ] == 1 { return false ; } else if memo [ lo ][ hi ] == 2 { return true ; } for pos : = lo ; pos <= hi ; pos ++ { if _ , ok : = wordMap [ s[lo:pos+1 ] ] ; ok { if helper4 ( s , pos + 1 , hi , wordMap , memo ) { memo [ lo ][ hi ] = 2 ; return true ; } } } memo [ lo ][ hi ] = 1 ; return false ; } // 5. iterative 2 D + string - optimize + use - map - instead - of - array // !! ERROR , can ' t guarantee when calculate m [ i ][ j ] already got // m [ i ][ k ] ... m [ k+1 ][ j ] func func5 ( s string , wordDict [] string ) bool { N : = len ( s ); memo : = make ( [][] bool , N ); for i : = 0 ; i < N ; i ++ { memo [ i ] = make ( [] bool , N ); } wordMap : = make ( map [ string ] bool ); for i : = 0 ; i < len ( wordDict ); i ++ { wordMap [ wordDict[i ] ] = true ; } for i : = 0 ; i < N ; i ++ { for j : = i ; j < N ; j ++ { if _ , ok : = wordMap [ s[i:j+1 ] ] ; ok { memo [ i ][ j ] = true ; continue ; } for k : = i ; k < j ; k ++ { if memo [ i ][ k ] && memo [ k+1 ][ j ] { memo [ i ][ j ] = true ; break ; } } } } return memo [ N-1 ][ N-1 ] ; } // 6. iterative 2 D + string - optimize + use - map - instead - of - array // Use substring size iterate 1 , 2 , 3. .., O ( n ^ 3 ) time func func6 ( s string , wordDict [] string ) bool { N : = len ( s ); memo : = make ( [][] bool , N ); for i : = 0 ; i < N ; i ++ { memo [ i ] = make ( [] bool , N ); } wordMap : = make ( map [ string ] bool ); for i : = 0 ; i < len ( wordDict ); i ++ { wordMap [ wordDict[i ] ] = true ; } // size == 1 for i : = 0 ; i < N ; i ++ { if _ , ok : = wordMap [ s[i:i+1 ] ] ; ok { memo [ i ][ i ] = true ; } } // size >= 2 for sz : = 2 ; sz <= N ; sz ++ { for lo , hi : = 0 , sz - 1 ; hi < N ; lo , hi = lo + 1 , hi + 1 { if _ , ok : = wordMap [ s[lo:hi+1 ] ] ; ok { memo [ lo ][ hi ] = true ; continue ; } for mid : = lo ; mid < hi ; mid ++ { if memo [ lo ][ mid ] && memo [ mid+1 ][ hi ] { memo [ lo ][ hi ] = true ; break ; } } } } return memo [ 0 ][ N-1 ] ; } // 7. A different thought , F [ 0...n ] = F [ 0...x ] && isWord ( x + 1. . n ) // recursive solution func func7 ( s string , wordDict [] string ) bool { N : = len ( s ) wordMap : = make ( map [ string ] bool ); for i : = 0 ; i < len ( wordDict ); i ++ { wordMap [ wordDict[i ] ] = true ; } return helper7 ( s , N - 1 , wordMap ); } func helper7 ( s string , end int , wordMap map [ string ] bool ) bool { if end < 0 { return true ; } for i : = end ; i >= 0 ; i -- { if _ , ok : = wordMap [ s[i:end+1 ] ] ; ok { if helper7 ( s , i - 1 , wordMap ) { return true ; } } } return false ; } // 8. same 7 , but with memo func func8 ( s string , wordDict [] string ) bool { N : = len ( s ) // 0 = init , 1 = false , 2 = true memo : = make ( [] int , N ); wordMap : = make ( map [ string ] bool ); for i : = 0 ; i < len ( wordDict ); i ++ { wordMap [ wordDict[i ] ] = true ; } return helper8 ( s , N - 1 , wordMap , memo ); } func helper8 ( s string , end int , wordMap map [ string ] bool , memo [] int ) bool { if end < 0 { return true ; } if memo [ end ] != 0 { return memo [ end ] == 2 ; } for i : = end ; i >= 0 ; i -- { if _ , ok : = wordMap [ s[i:end+1 ] ] ; ok { if helper8 ( s , i - 1 , wordMap , memo ) { memo [ end ] = 2 ; return true ; } } } memo [ end ] = 1 ; return false ; } // 9. same 7 , finially , bottom - up , 1 D , O ( n ^ 2 ) solution func func9 ( s string , wordDict [] string ) bool { N : = len ( s ) memo : = make ( [] bool , N ); wordMap : = make ( map [ string ] bool ); for i : = 0 ; i < len ( wordDict ); i ++ { wordMap [ wordDict[i ] ] = true ; } for i : = 0 ; i < N ; i ++ { if _ , ok : = wordMap [ s[0:i+1 ] ] ; ok { memo [ i ] = true ; continue ; } for j : = i ; j >= 0 ; j -- { if _ , ok : = wordMap [ s[j:i+1 ] ] ; ok && memo [ j-1 ] { memo [ i ] = true ; break ; } } } return memo [ N-1 ] ; } func strCompHelper ( s string , lo int , hi int , word string ) bool { m : = hi - lo + 1 ; n : = len ( word ); if m != n { return false ; } for i : = lo ; i <= hi ; i ++ { if s [ i ] != word [ i-lo ] { return false ; } } return true ; } 140. Word Break II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < string > wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > set ( wordDict . begin (), wordDict . end ()); return wordBreak ( s , set ); } private : unordered_map < string , vector < string >> map ; vector < string >& wordBreak ( string & s , unordered_set < string >& set ) { if ( map . count ( s )) return map [ s ]; vector < string > ans ; if ( set . count ( s )) ans . push_back ( s ); for ( int i = 1 ; i < s . length (); ++ i ) { string right = s . substr ( i ); if ( set . count ( right )) { string left = s . substr ( 0 , i ); vector < string > leftAns = append ( wordBreak ( left , set ), right ); ans . insert ( ans . end (), leftAns . begin (), leftAns . end ()); } } return map [ s ] = ans ; } vector < string > append ( vector < string > prefixes , string & word ) { for ( string & prefix : prefixes ) prefix += \" \" + word ; return prefixes ; } };","title":"0131-0140"},{"location":"golang/0101-0200/0131-0140/#131-palindrome-partitioning-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; vector < string > path ; dfs ( s , 0 , path , ans ); return ans ; } private : void dfs ( string & s , int j , vector < string >& path , vector < vector < string >>& ans ) { if ( j == s . length ()) { ans . push_back ( path ); return ; } for ( int i = j ; i < s . length (); ++ i ) if ( isPalindrome ( s , j , i )) { path . push_back ( s . substr ( j , i - j + 1 )); dfs ( s , i + 1 , path , ans ); path . pop_back (); } } bool isPalindrome ( string & s , int l , int r ) { while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } };","title":"131. Palindrome Partitioning $\\star\\star$"},{"location":"golang/0101-0200/0131-0140/#132-palindrome-partitioning-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int minCut ( string s ) { const int n = s . length (); vector < int > cut ( n ); vector < vector < bool >> dp ( n , vector < bool > ( n )); for ( int i = 0 ; i < n ; ++ i ) { int min = i ; for ( int j = 0 ; j <= i ; ++ j ) if ( s [ j ] == s [ i ] && ( j + 1 > i - 1 || dp [ j + 1 ][ i - 1 ])) { dp [ j ][ i ] = true ; min = j == 0 ? 0 : std :: min ( min , cut [ j - 1 ] + 1 ); } cut [ i ] = min ; } return cut [ n - 1 ]; } };","title":"132. Palindrome Partitioning II $\\star\\star\\star$"},{"location":"golang/0101-0200/0131-0140/#133-clone-graph-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : Node * cloneGraph ( Node * node ) { if ( ! node ) return NULL ; if ( map . count ( node )) return map [ node ]; map [ node ] = new Node ( node -> val , {}); for ( Node * neighbor : node -> neighbors ) map [ node ] -> neighbors . push_back ( cloneGraph ( neighbor )); return map [ node ]; } private : unordered_map < Node * , Node *> map ; };","title":"133. Clone Graph $\\star\\star$"},{"location":"golang/0101-0200/0131-0140/#134-gas-station-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int ans = 0 ; int net = 0 ; int sum = 0 ; for ( int i = 0 ; i < gas . size (); ++ i ) { net += gas [ i ] - cost [ i ]; sum += gas [ i ] - cost [ i ]; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; } } return net < 0 ? - 1 : ans ; } };","title":"134. Gas Station $\\star\\star$"},{"location":"golang/0101-0200/0131-0140/#135-candy-starstarstar","text":"","title":"135. Candy $\\star\\star\\star$"},{"location":"golang/0101-0200/0131-0140/#136-single-number-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) ans ^= num ; return ans ; } };","title":"136. Single Number $\\star$"},{"location":"golang/0101-0200/0131-0140/#137-single-number-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int singleNumber ( vector < int >& nums ) { int ones = 0 ; int twos = 0 ; for ( int num : nums ) { ones ^= ( num & ~ twos ); twos ^= ( num & ~ ones ); } return ones ; } };","title":"137. Single Number II $\\star\\star$"},{"location":"golang/0101-0200/0131-0140/#138-copy-list-with-random-pointer-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return NULL ; if ( map . count ( head )) return map [ head ]; map [ head ] = new Node ( head -> val , NULL , NULL ); map [ head ] -> next = copyRandomList ( head -> next ); map [ head ] -> random = copyRandomList ( head -> random ); return map [ head ]; } private : unordered_map < Node * , Node *> map ; };","title":"138. Copy List with Random Pointer $\\star\\star$"},{"location":"golang/0101-0200/0131-0140/#139-word-break-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 func wordBreak ( s string , wordDict [] string ) bool { // return func1 ( s , wordDict ); // return func2 ( s , 0 , len ( s ) - 1 , wordDict ); // return func3 ( s , wordDict ); // return func4 ( s , wordDict ); // return func5 ( s , wordDict ); // return func6 ( s , wordDict ); // return func7 ( s , wordDict ); // return func8 ( s , wordDict ); return func9 ( s , wordDict ); } // 1. recursive func func1 ( s string , wordDict [] string ) bool { if len ( s ) == 0 { return true ; } for pos : = 0 ; pos <= len ( s ); pos ++ { for _ , word : = range wordDict { if s [ 0:pos ] == word && func1 ( s [ pos: ] , wordDict ) { return true ; } } } return false ; } // 2. recursive + string - optimize func func2 ( s string , lo int , hi int , wordDict [] string ) bool { if ( lo > hi ) { return true ; } for pos : = lo ; pos <= hi ; pos ++ { for _ , word : = range wordDict { if strCompHelper ( s , lo , pos , word ) && func2 ( s , pos + 1 , hi , wordDict ) { return true ; } } } return false ; } // 3. recursive + string - optimize + memo func func3 ( s string , wordDict [] string ) bool { N : = len ( s ); // 0 = init , 1 = false , 2 = true memo : = make ( [][] int , N ); for i : = 0 ; i < N ; i ++ { memo [ i ] = make ( [] int , N ); } return helper3 ( s , 0 , N - 1 , wordDict , memo ); } func helper3 ( s string , lo int , hi int , wordDict [] string , memo [][] int ) bool { if ( lo > hi ) { return true ; } if memo [ lo ][ hi ] == 1 { return false ; } else if memo [ lo ][ hi ] == 2 { return true ; } for pos : = lo ; pos <= hi ; pos ++ { for _ , word : = range wordDict { if strCompHelper ( s , lo , pos , word ) && helper3 ( s , pos + 1 , hi , wordDict , memo ) { memo [ lo ][ hi ] = 2 ; return true ; } } } memo [ lo ][ hi ] = 1 ; return false ; } // 4. recursive + string - optimize + memo + use - map - instead - of - array func func4 ( s string , wordDict [] string ) bool { N : = len ( s ); // 0 = init , 1 = false , 2 = true memo : = make ( [][] int , N ); for i : = 0 ; i < N ; i ++ { memo [ i ] = make ( [] int , N ); } wordMap : = make ( map [ string ] bool ); for i : = 0 ; i < len ( wordDict ); i ++ { wordMap [ wordDict[i ] ] = true ; } return helper4 ( s , 0 , N - 1 , wordMap , memo ); } func helper4 ( s string , lo int , hi int , wordMap map [ string ] bool , memo [][] int ) bool { if ( lo > hi ) { return true ; } if memo [ lo ][ hi ] == 1 { return false ; } else if memo [ lo ][ hi ] == 2 { return true ; } for pos : = lo ; pos <= hi ; pos ++ { if _ , ok : = wordMap [ s[lo:pos+1 ] ] ; ok { if helper4 ( s , pos + 1 , hi , wordMap , memo ) { memo [ lo ][ hi ] = 2 ; return true ; } } } memo [ lo ][ hi ] = 1 ; return false ; } // 5. iterative 2 D + string - optimize + use - map - instead - of - array // !! ERROR , can ' t guarantee when calculate m [ i ][ j ] already got // m [ i ][ k ] ... m [ k+1 ][ j ] func func5 ( s string , wordDict [] string ) bool { N : = len ( s ); memo : = make ( [][] bool , N ); for i : = 0 ; i < N ; i ++ { memo [ i ] = make ( [] bool , N ); } wordMap : = make ( map [ string ] bool ); for i : = 0 ; i < len ( wordDict ); i ++ { wordMap [ wordDict[i ] ] = true ; } for i : = 0 ; i < N ; i ++ { for j : = i ; j < N ; j ++ { if _ , ok : = wordMap [ s[i:j+1 ] ] ; ok { memo [ i ][ j ] = true ; continue ; } for k : = i ; k < j ; k ++ { if memo [ i ][ k ] && memo [ k+1 ][ j ] { memo [ i ][ j ] = true ; break ; } } } } return memo [ N-1 ][ N-1 ] ; } // 6. iterative 2 D + string - optimize + use - map - instead - of - array // Use substring size iterate 1 , 2 , 3. .., O ( n ^ 3 ) time func func6 ( s string , wordDict [] string ) bool { N : = len ( s ); memo : = make ( [][] bool , N ); for i : = 0 ; i < N ; i ++ { memo [ i ] = make ( [] bool , N ); } wordMap : = make ( map [ string ] bool ); for i : = 0 ; i < len ( wordDict ); i ++ { wordMap [ wordDict[i ] ] = true ; } // size == 1 for i : = 0 ; i < N ; i ++ { if _ , ok : = wordMap [ s[i:i+1 ] ] ; ok { memo [ i ][ i ] = true ; } } // size >= 2 for sz : = 2 ; sz <= N ; sz ++ { for lo , hi : = 0 , sz - 1 ; hi < N ; lo , hi = lo + 1 , hi + 1 { if _ , ok : = wordMap [ s[lo:hi+1 ] ] ; ok { memo [ lo ][ hi ] = true ; continue ; } for mid : = lo ; mid < hi ; mid ++ { if memo [ lo ][ mid ] && memo [ mid+1 ][ hi ] { memo [ lo ][ hi ] = true ; break ; } } } } return memo [ 0 ][ N-1 ] ; } // 7. A different thought , F [ 0...n ] = F [ 0...x ] && isWord ( x + 1. . n ) // recursive solution func func7 ( s string , wordDict [] string ) bool { N : = len ( s ) wordMap : = make ( map [ string ] bool ); for i : = 0 ; i < len ( wordDict ); i ++ { wordMap [ wordDict[i ] ] = true ; } return helper7 ( s , N - 1 , wordMap ); } func helper7 ( s string , end int , wordMap map [ string ] bool ) bool { if end < 0 { return true ; } for i : = end ; i >= 0 ; i -- { if _ , ok : = wordMap [ s[i:end+1 ] ] ; ok { if helper7 ( s , i - 1 , wordMap ) { return true ; } } } return false ; } // 8. same 7 , but with memo func func8 ( s string , wordDict [] string ) bool { N : = len ( s ) // 0 = init , 1 = false , 2 = true memo : = make ( [] int , N ); wordMap : = make ( map [ string ] bool ); for i : = 0 ; i < len ( wordDict ); i ++ { wordMap [ wordDict[i ] ] = true ; } return helper8 ( s , N - 1 , wordMap , memo ); } func helper8 ( s string , end int , wordMap map [ string ] bool , memo [] int ) bool { if end < 0 { return true ; } if memo [ end ] != 0 { return memo [ end ] == 2 ; } for i : = end ; i >= 0 ; i -- { if _ , ok : = wordMap [ s[i:end+1 ] ] ; ok { if helper8 ( s , i - 1 , wordMap , memo ) { memo [ end ] = 2 ; return true ; } } } memo [ end ] = 1 ; return false ; } // 9. same 7 , finially , bottom - up , 1 D , O ( n ^ 2 ) solution func func9 ( s string , wordDict [] string ) bool { N : = len ( s ) memo : = make ( [] bool , N ); wordMap : = make ( map [ string ] bool ); for i : = 0 ; i < len ( wordDict ); i ++ { wordMap [ wordDict[i ] ] = true ; } for i : = 0 ; i < N ; i ++ { if _ , ok : = wordMap [ s[0:i+1 ] ] ; ok { memo [ i ] = true ; continue ; } for j : = i ; j >= 0 ; j -- { if _ , ok : = wordMap [ s[j:i+1 ] ] ; ok && memo [ j-1 ] { memo [ i ] = true ; break ; } } } return memo [ N-1 ] ; } func strCompHelper ( s string , lo int , hi int , word string ) bool { m : = hi - lo + 1 ; n : = len ( word ); if m != n { return false ; } for i : = lo ; i <= hi ; i ++ { if s [ i ] != word [ i-lo ] { return false ; } } return true ; }","title":"139. Word Break $\\star\\star$"},{"location":"golang/0101-0200/0131-0140/#140-word-break-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < string > wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > set ( wordDict . begin (), wordDict . end ()); return wordBreak ( s , set ); } private : unordered_map < string , vector < string >> map ; vector < string >& wordBreak ( string & s , unordered_set < string >& set ) { if ( map . count ( s )) return map [ s ]; vector < string > ans ; if ( set . count ( s )) ans . push_back ( s ); for ( int i = 1 ; i < s . length (); ++ i ) { string right = s . substr ( i ); if ( set . count ( right )) { string left = s . substr ( 0 , i ); vector < string > leftAns = append ( wordBreak ( left , set ), right ); ans . insert ( ans . end (), leftAns . begin (), leftAns . end ()); } } return map [ s ] = ans ; } vector < string > append ( vector < string > prefixes , string & word ) { for ( string & prefix : prefixes ) prefix += \" \" + word ; return prefixes ; } };","title":"140. Word Break II $\\star\\star\\star$"},{"location":"golang/0101-0200/0141-0150/","text":"141. Linked List Cycle $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } }; 142. Linked List Cycle II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } }; 143. Reorder List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * prev = NULL ; ListNode * slow = head ; ListNode * fast = head ; ListNode * l1 = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = NULL ; ListNode * l2 = reverse ( slow ); merge ( l1 , l2 ); } private : ListNode * reverse ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { auto next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { auto next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } }; 144. Binary Tree Preorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack ; stack . push ( root ); while ( ! stack . empty ()) { TreeNode * node = stack . top (); ans . push_back ( node -> val ); stack . pop (); if ( node -> right ) stack . push ( node -> right ); if ( node -> left ) stack . push ( node -> left ); } return ans ; } }; 145. Binary Tree Postorder Traversal $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack ; stack . push ( root ); while ( ! stack . empty ()) { TreeNode * node = stack . top (); ans . push_back ( node -> val ); stack . pop (); if ( node -> left ) stack . push ( node -> left ); if ( node -> right ) stack . push ( node -> right ); } reverse ( ans . begin (), ans . end ()); return ans ; } }; 146. LRU Cache $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class LRUCache { public : LRUCache ( int capacity ) : capacity ( capacity ) {} int get ( int key ) { if ( ! map . count ( key )) return - 1 ; cache . splice ( cache . begin (), cache , map [ key ]); return map [ key ] -> second ; } void put ( int key , int value ) { if ( map . count ( key )) { map [ key ] -> second = value ; cache . splice ( cache . begin (), cache , map [ key ]); return ; } if ( cache . size () == capacity ) { pair < int , int >& node = cache . back (); map . erase ( node . first ); cache . pop_back (); } cache . emplace_front ( key , value ); map [ key ] = cache . begin (); } private : int capacity ; list < pair < int , int >> cache ; unordered_map < int , list < pair < int , int >>:: iterator > map ; }; 147. Insertion Sort List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * insertionSortList ( ListNode * head ) { ListNode dummy ( 0 ); ListNode * curr = head ; while ( curr ) { auto prev = & dummy ; while ( prev -> next && prev -> next -> val < curr -> val ) prev = prev -> next ; auto next = curr -> next ; curr -> next = prev -> next ; prev -> next = curr ; curr = next ; } return dummy . next ; } }; 148. Sort List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : ListNode * sortList ( ListNode * head ) { int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; ListNode dummy ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k <<= 1 ) { ListNode * curr = dummy . next ; ListNode * tail = & dummy ; while ( curr ) { ListNode * l = curr ; ListNode * r = split ( l , k ); curr = split ( r , k ); vector < ListNode *> merged = merge ( l , r ); tail -> next = merged [ 0 ]; tail = merged [ 1 ]; } } return dummy . next ; } private : ListNode * split ( ListNode * head , int k ) { while ( -- k && head ) head = head -> next ; ListNode * rest = head ? head -> next : NULL ; if ( head ) head -> next = NULL ; return rest ; } vector < ListNode *> merge ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * tail = & dummy ; while ( l1 && l2 ) { if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); tail -> next = l1 ; l1 = l1 -> next ; tail = tail -> next ; } tail -> next = l1 ? l1 : l2 ; while ( tail -> next ) tail = tail -> next ; return { dummy . next , tail }; } }; 149. Max Points on a Line $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : int maxPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 0 ; i < points . size (); ++ i ) { map < pair < int , int > , int > map ; vector < int > p1 = points [ i ]; int samePoints = 1 ; int maxPoints = 0 ; for ( int j = i + 1 ; j < points . size (); ++ j ) { vector < int > p2 = points [ j ]; if ( p1 [ 0 ] == p2 [ 0 ] && p1 [ 1 ] == p2 [ 1 ]) ++ samePoints ; else maxPoints = max ( maxPoints , ++ map [ getSlope ( p1 , p2 )]); } ans = max ( ans , samePoints + maxPoints ); } return ans ; } private : pair < int , int > getSlope ( vector < int >& p1 , vector < int >& p2 ) { int dx = p2 [ 0 ] - p1 [ 0 ]; int dy = p2 [ 1 ] - p1 [ 1 ]; if ( dy == 0 ) return { p1 [ 1 ], 0 }; if ( dx == 0 ) return { 0 , p1 [ 0 ]}; int d = gcd ( dx , dy ); return { dy / d , dx / d }; } int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } }; 150. Evaluate Reverse Polish Notation $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stack ; int a ; int b ; for ( string & token : tokens ) { if ( token == \"+\" ) { helper ( stack , a , b ); stack . push ( a + b ); } else if ( token == \"-\" ) { helper ( stack , a , b ); stack . push ( a - b ); } else if ( token == \"*\" ) { helper ( stack , a , b ); stack . push ( a * b ); } else if ( token == \"/\" ) { helper ( stack , a , b ); stack . push ( a / b ); } else { stack . push ( stoi ( token )); } } return stack . top (); } private : void helper ( stack < int >& stack , int & a , int & b ) { b = stack . top (); stack . pop (); a = stack . top (); stack . pop (); } };","title":"0141-0150"},{"location":"golang/0101-0200/0141-0150/#141-linked-list-cycle-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } };","title":"141. Linked List Cycle $\\star$"},{"location":"golang/0101-0200/0141-0150/#142-linked-list-cycle-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } };","title":"142. Linked List Cycle II $\\star\\star$"},{"location":"golang/0101-0200/0141-0150/#143-reorder-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * prev = NULL ; ListNode * slow = head ; ListNode * fast = head ; ListNode * l1 = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = NULL ; ListNode * l2 = reverse ( slow ); merge ( l1 , l2 ); } private : ListNode * reverse ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { auto next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { auto next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } };","title":"143. Reorder List $\\star\\star$"},{"location":"golang/0101-0200/0141-0150/#144-binary-tree-preorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack ; stack . push ( root ); while ( ! stack . empty ()) { TreeNode * node = stack . top (); ans . push_back ( node -> val ); stack . pop (); if ( node -> right ) stack . push ( node -> right ); if ( node -> left ) stack . push ( node -> left ); } return ans ; } };","title":"144. Binary Tree Preorder Traversal $\\star\\star$"},{"location":"golang/0101-0200/0141-0150/#145-binary-tree-postorder-traversal-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack ; stack . push ( root ); while ( ! stack . empty ()) { TreeNode * node = stack . top (); ans . push_back ( node -> val ); stack . pop (); if ( node -> left ) stack . push ( node -> left ); if ( node -> right ) stack . push ( node -> right ); } reverse ( ans . begin (), ans . end ()); return ans ; } };","title":"145. Binary Tree Postorder Traversal $\\star\\star\\star$"},{"location":"golang/0101-0200/0141-0150/#146-lru-cache-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class LRUCache { public : LRUCache ( int capacity ) : capacity ( capacity ) {} int get ( int key ) { if ( ! map . count ( key )) return - 1 ; cache . splice ( cache . begin (), cache , map [ key ]); return map [ key ] -> second ; } void put ( int key , int value ) { if ( map . count ( key )) { map [ key ] -> second = value ; cache . splice ( cache . begin (), cache , map [ key ]); return ; } if ( cache . size () == capacity ) { pair < int , int >& node = cache . back (); map . erase ( node . first ); cache . pop_back (); } cache . emplace_front ( key , value ); map [ key ] = cache . begin (); } private : int capacity ; list < pair < int , int >> cache ; unordered_map < int , list < pair < int , int >>:: iterator > map ; };","title":"146. LRU Cache $\\star\\star$"},{"location":"golang/0101-0200/0141-0150/#147-insertion-sort-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * insertionSortList ( ListNode * head ) { ListNode dummy ( 0 ); ListNode * curr = head ; while ( curr ) { auto prev = & dummy ; while ( prev -> next && prev -> next -> val < curr -> val ) prev = prev -> next ; auto next = curr -> next ; curr -> next = prev -> next ; prev -> next = curr ; curr = next ; } return dummy . next ; } };","title":"147. Insertion Sort List $\\star\\star$"},{"location":"golang/0101-0200/0141-0150/#148-sort-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : ListNode * sortList ( ListNode * head ) { int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; ListNode dummy ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k <<= 1 ) { ListNode * curr = dummy . next ; ListNode * tail = & dummy ; while ( curr ) { ListNode * l = curr ; ListNode * r = split ( l , k ); curr = split ( r , k ); vector < ListNode *> merged = merge ( l , r ); tail -> next = merged [ 0 ]; tail = merged [ 1 ]; } } return dummy . next ; } private : ListNode * split ( ListNode * head , int k ) { while ( -- k && head ) head = head -> next ; ListNode * rest = head ? head -> next : NULL ; if ( head ) head -> next = NULL ; return rest ; } vector < ListNode *> merge ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * tail = & dummy ; while ( l1 && l2 ) { if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); tail -> next = l1 ; l1 = l1 -> next ; tail = tail -> next ; } tail -> next = l1 ? l1 : l2 ; while ( tail -> next ) tail = tail -> next ; return { dummy . next , tail }; } };","title":"148. Sort List $\\star\\star$"},{"location":"golang/0101-0200/0141-0150/#149-max-points-on-a-line-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : int maxPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 0 ; i < points . size (); ++ i ) { map < pair < int , int > , int > map ; vector < int > p1 = points [ i ]; int samePoints = 1 ; int maxPoints = 0 ; for ( int j = i + 1 ; j < points . size (); ++ j ) { vector < int > p2 = points [ j ]; if ( p1 [ 0 ] == p2 [ 0 ] && p1 [ 1 ] == p2 [ 1 ]) ++ samePoints ; else maxPoints = max ( maxPoints , ++ map [ getSlope ( p1 , p2 )]); } ans = max ( ans , samePoints + maxPoints ); } return ans ; } private : pair < int , int > getSlope ( vector < int >& p1 , vector < int >& p2 ) { int dx = p2 [ 0 ] - p1 [ 0 ]; int dy = p2 [ 1 ] - p1 [ 1 ]; if ( dy == 0 ) return { p1 [ 1 ], 0 }; if ( dx == 0 ) return { 0 , p1 [ 0 ]}; int d = gcd ( dx , dy ); return { dy / d , dx / d }; } int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } };","title":"149. Max Points on a Line $\\star\\star\\star$"},{"location":"golang/0101-0200/0141-0150/#150-evaluate-reverse-polish-notation-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stack ; int a ; int b ; for ( string & token : tokens ) { if ( token == \"+\" ) { helper ( stack , a , b ); stack . push ( a + b ); } else if ( token == \"-\" ) { helper ( stack , a , b ); stack . push ( a - b ); } else if ( token == \"*\" ) { helper ( stack , a , b ); stack . push ( a * b ); } else if ( token == \"/\" ) { helper ( stack , a , b ); stack . push ( a / b ); } else { stack . push ( stoi ( token )); } } return stack . top (); } private : void helper ( stack < int >& stack , int & a , int & b ) { b = stack . top (); stack . pop (); a = stack . top (); stack . pop (); } };","title":"150. Evaluate Reverse Polish Notation $\\star\\star$"},{"location":"golang/0101-0200/0151-0160/","text":"151. Reverse Words in a String $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : string reverseWords ( string s ) { reverse ( s . begin (), s . end ()); reverseWords ( s , 0 , 0 ); return cleanSpaces ( s , 0 , 0 ); } private : void reverseWords ( string & s , int i , int j ) { while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( s . begin () + i , s . begin () + j ); } } string cleanSpaces ( string & s , int i , int j ) { while ( j < s . length ()) { while ( j < s . length () && s [ j ] == ' ' ) ++ j ; while ( j < s . length () && s [ j ] != ' ' ) s [ i ++ ] = s [ j ++ ]; while ( j < s . length () && s [ j ] == ' ' ) ++ j ; if ( j < s . length ()) s [ i ++ ] = ' ' ; } return s . substr ( 0 , i ); } }; 152. Maximum Product Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProduct ( vector < int >& nums ) { int ans = nums [ 0 ]; int prevMin = nums [ 0 ]; int prevMax = nums [ 0 ]; for ( int i = 1 ; i < nums . size (); ++ i ) { int min = prevMin * nums [ i ]; int max = prevMax * nums [ i ]; prevMin = std :: min ( nums [ i ], std :: min ( min , max )); prevMax = std :: max ( nums [ i ], std :: max ( min , max )); ans = std :: max ( ans , prevMax ); } return ans ; } }; 153. Find Minimum in Rotated Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }; 154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ]) -- r ; else if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }; 155. Min Stack $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MinStack { public : void push ( int x ) { int min = stack . empty () ? x : std :: min ( stack . top (). second , x ); stack . push ({ x , min }); } void pop () { stack . pop (); } int top () { return stack . top (). first ; } int getMin () { return stack . top (). second ; } private : std :: stack < pair < int , int >> stack ; }; 156. Binary Tree Upside Down $\\star\\star$ 157. Read N Characters Given Read4 $\\star$ 158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$ 159. Longest Substring with At Most Two Distinct Characters $\\star\\star$ 160. Intersection of Two Linked Lists $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { if ( ! headA || ! headB ) return NULL ; ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a == NULL ? headB : a -> next ; b = b == NULL ? headA : b -> next ; } return a ; } };","title":"0151-0160"},{"location":"golang/0101-0200/0151-0160/#151-reverse-words-in-a-string-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : string reverseWords ( string s ) { reverse ( s . begin (), s . end ()); reverseWords ( s , 0 , 0 ); return cleanSpaces ( s , 0 , 0 ); } private : void reverseWords ( string & s , int i , int j ) { while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( s . begin () + i , s . begin () + j ); } } string cleanSpaces ( string & s , int i , int j ) { while ( j < s . length ()) { while ( j < s . length () && s [ j ] == ' ' ) ++ j ; while ( j < s . length () && s [ j ] != ' ' ) s [ i ++ ] = s [ j ++ ]; while ( j < s . length () && s [ j ] == ' ' ) ++ j ; if ( j < s . length ()) s [ i ++ ] = ' ' ; } return s . substr ( 0 , i ); } };","title":"151. Reverse Words in a String $\\star\\star$"},{"location":"golang/0101-0200/0151-0160/#152-maximum-product-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProduct ( vector < int >& nums ) { int ans = nums [ 0 ]; int prevMin = nums [ 0 ]; int prevMax = nums [ 0 ]; for ( int i = 1 ; i < nums . size (); ++ i ) { int min = prevMin * nums [ i ]; int max = prevMax * nums [ i ]; prevMin = std :: min ( nums [ i ], std :: min ( min , max )); prevMax = std :: max ( nums [ i ], std :: max ( min , max )); ans = std :: max ( ans , prevMax ); } return ans ; } };","title":"152. Maximum Product Subarray $\\star\\star$"},{"location":"golang/0101-0200/0151-0160/#153-find-minimum-in-rotated-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } };","title":"153. Find Minimum in Rotated Sorted Array $\\star\\star$"},{"location":"golang/0101-0200/0151-0160/#154-find-minimum-in-rotated-sorted-array-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ]) -- r ; else if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } };","title":"154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$"},{"location":"golang/0101-0200/0151-0160/#155-min-stack-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MinStack { public : void push ( int x ) { int min = stack . empty () ? x : std :: min ( stack . top (). second , x ); stack . push ({ x , min }); } void pop () { stack . pop (); } int top () { return stack . top (). first ; } int getMin () { return stack . top (). second ; } private : std :: stack < pair < int , int >> stack ; };","title":"155. Min Stack $\\star$"},{"location":"golang/0101-0200/0151-0160/#156-binary-tree-upside-down-starstar","text":"","title":"156. Binary Tree Upside Down $\\star\\star$"},{"location":"golang/0101-0200/0151-0160/#157-read-n-characters-given-read4-star","text":"","title":"157. Read N Characters Given Read4 $\\star$"},{"location":"golang/0101-0200/0151-0160/#158-read-n-characters-given-read4-ii-call-multiple-times-starstarstar","text":"","title":"158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$"},{"location":"golang/0101-0200/0151-0160/#159-longest-substring-with-at-most-two-distinct-characters-starstar","text":"","title":"159. Longest Substring with At Most Two Distinct Characters $\\star\\star$"},{"location":"golang/0101-0200/0151-0160/#160-intersection-of-two-linked-lists-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { if ( ! headA || ! headB ) return NULL ; ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a == NULL ? headB : a -> next ; b = b == NULL ? headA : b -> next ; } return a ; } };","title":"160. Intersection of Two Linked Lists $\\star$"},{"location":"golang/0101-0200/0161-0170/","text":"161. One Edit Distance $\\star\\star$ 162. Find Peak Element $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findPeakElement ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > nums [ m + 1 ]) r = m ; else l = m + 1 ; } return l ; } }; 163. Missing Ranges $\\star\\star$ 164. Maximum Gap $\\star\\star\\star$ 165. Compare Version Numbers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int compareVersion ( string version1 , string version2 ) { istringstream iss1 ( version1 ); istringstream iss2 ( version2 ); int num1 ; int num2 ; char c ; while ( bool ( iss1 >> num1 ) + bool ( iss2 >> num2 )) { if ( num1 < num2 ) return - 1 ; if ( num1 > num2 ) return 1 ; iss1 >> c ; iss2 >> c ; num1 = 0 ; num2 = 0 ; } if ( num1 == num2 ) return 0 ; return 0 ; }; }; 166. Fraction to Recurring Decimal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; string ans ; if ( numerator < 0 ^ denominator < 0 ) ans += \"-\" ; long n = abs (( long ) numerator ); long d = abs (( long ) denominator ); ans += to_string ( n / d ); if ( n % d == 0 ) return ans ; ans += '.' ; unordered_map < int , int > map ; for ( long r = n % d ; r ; r %= d ) { if ( map . count ( r ) > 0 ) { ans . insert ( map [ r ], 1 , '(' ); ans += ')' ; break ; } map [ r ] = ans . size (); r *= 10 ; ans += to_string ( r / d ); } return ans ; } }; 167. Two Sum II - Input array is sorted $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int l = 0 ; int r = numbers . size () - 1 ; while ( l < r ) { int sum = numbers [ l ] + numbers [ r ]; if ( sum == target ) return { l + 1 , r + 1 }; if ( sum < target ) ++ l ; else -- r ; } throw ; } }; 168. Excel Sheet Column Title $\\star$ 1 2 3 4 5 6 7 class Solution { public : string convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char )( 'A' + (( n - 1 ) % 26 )); } }; 169. Majority Element $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int majorityElement ( vector < int >& nums ) { int ans ; int count = 0 ; for ( int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } }; 170. Two Sum III - Data structure design $\\star$","title":"0161-0170"},{"location":"golang/0101-0200/0161-0170/#161-one-edit-distance-starstar","text":"","title":"161. One Edit Distance $\\star\\star$"},{"location":"golang/0101-0200/0161-0170/#162-find-peak-element-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findPeakElement ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > nums [ m + 1 ]) r = m ; else l = m + 1 ; } return l ; } };","title":"162. Find Peak Element $\\star\\star$"},{"location":"golang/0101-0200/0161-0170/#163-missing-ranges-starstar","text":"","title":"163. Missing Ranges $\\star\\star$"},{"location":"golang/0101-0200/0161-0170/#164-maximum-gap-starstarstar","text":"","title":"164. Maximum Gap $\\star\\star\\star$"},{"location":"golang/0101-0200/0161-0170/#165-compare-version-numbers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int compareVersion ( string version1 , string version2 ) { istringstream iss1 ( version1 ); istringstream iss2 ( version2 ); int num1 ; int num2 ; char c ; while ( bool ( iss1 >> num1 ) + bool ( iss2 >> num2 )) { if ( num1 < num2 ) return - 1 ; if ( num1 > num2 ) return 1 ; iss1 >> c ; iss2 >> c ; num1 = 0 ; num2 = 0 ; } if ( num1 == num2 ) return 0 ; return 0 ; }; };","title":"165. Compare Version Numbers $\\star\\star$"},{"location":"golang/0101-0200/0161-0170/#166-fraction-to-recurring-decimal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; string ans ; if ( numerator < 0 ^ denominator < 0 ) ans += \"-\" ; long n = abs (( long ) numerator ); long d = abs (( long ) denominator ); ans += to_string ( n / d ); if ( n % d == 0 ) return ans ; ans += '.' ; unordered_map < int , int > map ; for ( long r = n % d ; r ; r %= d ) { if ( map . count ( r ) > 0 ) { ans . insert ( map [ r ], 1 , '(' ); ans += ')' ; break ; } map [ r ] = ans . size (); r *= 10 ; ans += to_string ( r / d ); } return ans ; } };","title":"166. Fraction to Recurring Decimal $\\star\\star$"},{"location":"golang/0101-0200/0161-0170/#167-two-sum-ii-input-array-is-sorted-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int l = 0 ; int r = numbers . size () - 1 ; while ( l < r ) { int sum = numbers [ l ] + numbers [ r ]; if ( sum == target ) return { l + 1 , r + 1 }; if ( sum < target ) ++ l ; else -- r ; } throw ; } };","title":"167. Two Sum II - Input array is sorted $\\star$"},{"location":"golang/0101-0200/0161-0170/#168-excel-sheet-column-title-star","text":"1 2 3 4 5 6 7 class Solution { public : string convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char )( 'A' + (( n - 1 ) % 26 )); } };","title":"168. Excel Sheet Column Title $\\star$"},{"location":"golang/0101-0200/0161-0170/#169-majority-element-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int majorityElement ( vector < int >& nums ) { int ans ; int count = 0 ; for ( int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } };","title":"169. Majority Element $\\star$"},{"location":"golang/0101-0200/0161-0170/#170-two-sum-iii-data-structure-design-star","text":"","title":"170. Two Sum III - Data structure design $\\star$"},{"location":"golang/0101-0200/0171-0180/","text":"171. Excel Sheet Column Number $\\star$ 1 2 3 4 5 6 7 class Solution { public : int titleToNumber ( string s ) { return accumulate ( s . begin (), s . end (), 0 , []( int a , int b ) { return a * 26 + ( b - 'A' + 1 ); }); } }; 172. Factorial Trailing Zeroes $\\star$ 1 2 3 4 5 6 class Solution { public : int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } }; 173. Binary Search Tree Iterator $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class BSTIterator { public : BSTIterator ( TreeNode * root ) { helper ( root ); } int next () { TreeNode * node = stack . top (); stack . pop (); if ( node -> right ) helper ( node -> right ); return node -> val ; } bool hasNext () { return ! stack . empty (); } private : std :: stack < TreeNode *> stack ; void helper ( TreeNode * root ) { while ( root ) { stack . push ( root ); root = root -> left ; } } }; 174. Dungeon Game $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { const int m = dungeon . size (); const int n = dungeon [ 0 ]. size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) dp [ i ][ j ] = max ( 1 , min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ]); return dp [ 0 ][ 0 ]; } }; 175. Combine Two Tables $\\star$ 176. Second Highest Salary $\\star$ 177. Nth Highest Salary $\\star\\star$ 178. Rank Scores $\\star\\star$ 179. Largest Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : string largestNumber ( vector < int >& nums ) { string ans ; sort ( nums . begin (), nums . end (), []( int a , int b ) { return to_string ( a ) + to_string ( b ) > to_string ( b ) + to_string ( a ); }); for ( int num : nums ) ans += to_string ( num ); return ans [ 0 ] == '0' ? \"0\" : ans ; } }; 180. Consecutive Numbers $\\star\\star$","title":"0171-0180"},{"location":"golang/0101-0200/0171-0180/#171-excel-sheet-column-number-star","text":"1 2 3 4 5 6 7 class Solution { public : int titleToNumber ( string s ) { return accumulate ( s . begin (), s . end (), 0 , []( int a , int b ) { return a * 26 + ( b - 'A' + 1 ); }); } };","title":"171. Excel Sheet Column Number $\\star$"},{"location":"golang/0101-0200/0171-0180/#172-factorial-trailing-zeroes-star","text":"1 2 3 4 5 6 class Solution { public : int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } };","title":"172. Factorial Trailing Zeroes $\\star$"},{"location":"golang/0101-0200/0171-0180/#173-binary-search-tree-iterator-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class BSTIterator { public : BSTIterator ( TreeNode * root ) { helper ( root ); } int next () { TreeNode * node = stack . top (); stack . pop (); if ( node -> right ) helper ( node -> right ); return node -> val ; } bool hasNext () { return ! stack . empty (); } private : std :: stack < TreeNode *> stack ; void helper ( TreeNode * root ) { while ( root ) { stack . push ( root ); root = root -> left ; } } };","title":"173. Binary Search Tree Iterator $\\star\\star$"},{"location":"golang/0101-0200/0171-0180/#174-dungeon-game-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { const int m = dungeon . size (); const int n = dungeon [ 0 ]. size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) dp [ i ][ j ] = max ( 1 , min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ]); return dp [ 0 ][ 0 ]; } };","title":"174. Dungeon Game $\\star\\star\\star$"},{"location":"golang/0101-0200/0171-0180/#175-combine-two-tables-star","text":"","title":"175. Combine Two Tables $\\star$"},{"location":"golang/0101-0200/0171-0180/#176-second-highest-salary-star","text":"","title":"176. Second Highest Salary $\\star$"},{"location":"golang/0101-0200/0171-0180/#177-nth-highest-salary-starstar","text":"","title":"177. Nth Highest Salary $\\star\\star$"},{"location":"golang/0101-0200/0171-0180/#178-rank-scores-starstar","text":"","title":"178. Rank Scores $\\star\\star$"},{"location":"golang/0101-0200/0171-0180/#179-largest-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : string largestNumber ( vector < int >& nums ) { string ans ; sort ( nums . begin (), nums . end (), []( int a , int b ) { return to_string ( a ) + to_string ( b ) > to_string ( b ) + to_string ( a ); }); for ( int num : nums ) ans += to_string ( num ); return ans [ 0 ] == '0' ? \"0\" : ans ; } };","title":"179. Largest Number $\\star\\star$"},{"location":"golang/0101-0200/0171-0180/#180-consecutive-numbers-starstar","text":"","title":"180. Consecutive Numbers $\\star\\star$"},{"location":"golang/0101-0200/0181-0190/","text":"181. Employees Earning More Than Their Managers $\\star$ 182. Duplicate Emails $\\star$ 183. Customers Who Never Order $\\star$ 184. Department Highest Salary $\\star\\star$ 185. Department Top Three Salaries $\\star\\star\\star$ 186. Reverse Words in a String II $\\star\\star$ 187. Repeated DNA Sequences $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < string > findRepeatedDnaSequences ( string s ) { const int n = s . length (); unordered_set < string > ans ; unordered_set < string > set ; for ( int i = 0 ; i <= n - 10 ; ++ i ) { string seq = s . substr ( i , 10 ); if ( set . count ( seq )) ans . insert ( seq ); set . insert ( seq ); } return vector < string > ( ans . begin (), ans . end ()); } }; 188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int maxProfit ( int k , vector < int >& prices ) { if ( k >= prices . size () / 2 ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } vector < int > sell ( k + 1 ); vector < int > hold ( k + 1 , INT_MIN ); for ( int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = max ( sell [ i ], hold [ i ] + price ); hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ); } return sell [ k ]; } }; 189. Rotate Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : void rotate ( vector < int >& nums , int k ) { k %= nums . size (); reverse ( nums , 0 , nums . size () - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } }; 190. Reverse Bits $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : uint32_t reverseBits ( uint32_t num ) { unsigned int NO_OF_BITS = sizeof ( num ) * 8 ; unsigned int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; ++ i ) { temp = ( num & ( 1 << i )); if ( temp ) reverse_num |= ( 1 << (( NO_OF_BITS - 1 ) - i )); } return reverse_num ; } };","title":"0181-0190"},{"location":"golang/0101-0200/0181-0190/#181-employees-earning-more-than-their-managers-star","text":"","title":"181. Employees Earning More Than Their Managers $\\star$"},{"location":"golang/0101-0200/0181-0190/#182-duplicate-emails-star","text":"","title":"182. Duplicate Emails $\\star$"},{"location":"golang/0101-0200/0181-0190/#183-customers-who-never-order-star","text":"","title":"183. Customers Who Never Order $\\star$"},{"location":"golang/0101-0200/0181-0190/#184-department-highest-salary-starstar","text":"","title":"184. Department Highest Salary $\\star\\star$"},{"location":"golang/0101-0200/0181-0190/#185-department-top-three-salaries-starstarstar","text":"","title":"185. Department Top Three Salaries $\\star\\star\\star$"},{"location":"golang/0101-0200/0181-0190/#186-reverse-words-in-a-string-ii-starstar","text":"","title":"186. Reverse Words in a String II $\\star\\star$"},{"location":"golang/0101-0200/0181-0190/#187-repeated-dna-sequences-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < string > findRepeatedDnaSequences ( string s ) { const int n = s . length (); unordered_set < string > ans ; unordered_set < string > set ; for ( int i = 0 ; i <= n - 10 ; ++ i ) { string seq = s . substr ( i , 10 ); if ( set . count ( seq )) ans . insert ( seq ); set . insert ( seq ); } return vector < string > ( ans . begin (), ans . end ()); } };","title":"187. Repeated DNA Sequences $\\star\\star$"},{"location":"golang/0101-0200/0181-0190/#188-best-time-to-buy-and-sell-stock-iv-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int maxProfit ( int k , vector < int >& prices ) { if ( k >= prices . size () / 2 ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } vector < int > sell ( k + 1 ); vector < int > hold ( k + 1 , INT_MIN ); for ( int price : prices ) for ( int i = k ; i > 0 ; -- i ) { sell [ i ] = max ( sell [ i ], hold [ i ] + price ); hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ); } return sell [ k ]; } };","title":"188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$"},{"location":"golang/0101-0200/0181-0190/#189-rotate-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : void rotate ( vector < int >& nums , int k ) { k %= nums . size (); reverse ( nums , 0 , nums . size () - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) swap ( nums [ l ++ ], nums [ r -- ]); } };","title":"189. Rotate Array $\\star$"},{"location":"golang/0101-0200/0181-0190/#190-reverse-bits-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : uint32_t reverseBits ( uint32_t num ) { unsigned int NO_OF_BITS = sizeof ( num ) * 8 ; unsigned int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; ++ i ) { temp = ( num & ( 1 << i )); if ( temp ) reverse_num |= ( 1 << (( NO_OF_BITS - 1 ) - i )); } return reverse_num ; } };","title":"190. Reverse Bits $\\star$"},{"location":"golang/0101-0200/0191-0200/","text":"191. Number of 1 Bits $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int hammingWeight ( uint32_t n ) { int ans ; for ( ans = 0 ; n != 0 ; ++ ans ) n &= n - 1 ; return ans ; } }; 192. Word Frequency $\\star\\star$ 193. Valid Phone Numbers $\\star$ 194. Transpose File $\\star\\star$ 195. Tenth Line $\\star$ 196. Delete Duplicate Emails $\\star$ 197. Rising Temperature $\\star$ 198. House Robber $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int rob ( vector < int >& nums ) { int dp1 = 0 ; int dp2 = 0 ; for ( int num : nums ) { int temp = dp1 ; dp1 = max ( dp1 , dp2 + num ); dp2 = temp ; } return dp1 ; } }; 199. Binary Tree Right Side View $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; dfs ( root , 1 , ans ); return ans ; } private : void dfs ( TreeNode * root , int level , vector < int >& ans ) { if ( ! root ) return ; if ( level > ans . size ()) ans . push_back ( root -> val ); dfs ( root -> right , level + 1 , ans ); dfs ( root -> left , level + 1 , ans ); } }; 200. Number of Islands $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int numIslands ( vector < vector < char >>& grid ) { if ( grid . empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> visited ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( ! visited [ i ][ j ] && grid [ i ][ j ] == '1' ) { ++ ans ; dfs ( grid , i , j , visited ); } return ans ; } private : void dfs ( vector < vector < char >>& grid , int i , int j , vector < vector < bool >>& visited ) { if ( i < 0 || j < 0 || i >= grid . size () || j >= grid [ 0 ]. size () || visited [ i ][ j ] || grid [ i ][ j ] == '0' ) return ; visited [ i ][ j ] = true ; dfs ( grid , i + 1 , j , visited ); dfs ( grid , i - 1 , j , visited ); dfs ( grid , i , j + 1 , visited ); dfs ( grid , i , j - 1 , visited ); } };","title":"0191-0200"},{"location":"golang/0101-0200/0191-0200/#191-number-of-1-bits-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int hammingWeight ( uint32_t n ) { int ans ; for ( ans = 0 ; n != 0 ; ++ ans ) n &= n - 1 ; return ans ; } };","title":"191. Number of 1 Bits $\\star$"},{"location":"golang/0101-0200/0191-0200/#192-word-frequency-starstar","text":"","title":"192. Word Frequency $\\star\\star$"},{"location":"golang/0101-0200/0191-0200/#193-valid-phone-numbers-star","text":"","title":"193. Valid Phone Numbers $\\star$"},{"location":"golang/0101-0200/0191-0200/#194-transpose-file-starstar","text":"","title":"194. Transpose File $\\star\\star$"},{"location":"golang/0101-0200/0191-0200/#195-tenth-line-star","text":"","title":"195. Tenth Line $\\star$"},{"location":"golang/0101-0200/0191-0200/#196-delete-duplicate-emails-star","text":"","title":"196. Delete Duplicate Emails $\\star$"},{"location":"golang/0101-0200/0191-0200/#197-rising-temperature-star","text":"","title":"197. Rising Temperature $\\star$"},{"location":"golang/0101-0200/0191-0200/#198-house-robber-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int rob ( vector < int >& nums ) { int dp1 = 0 ; int dp2 = 0 ; for ( int num : nums ) { int temp = dp1 ; dp1 = max ( dp1 , dp2 + num ); dp2 = temp ; } return dp1 ; } };","title":"198. House Robber $\\star$"},{"location":"golang/0101-0200/0191-0200/#199-binary-tree-right-side-view-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; dfs ( root , 1 , ans ); return ans ; } private : void dfs ( TreeNode * root , int level , vector < int >& ans ) { if ( ! root ) return ; if ( level > ans . size ()) ans . push_back ( root -> val ); dfs ( root -> right , level + 1 , ans ); dfs ( root -> left , level + 1 , ans ); } };","title":"199. Binary Tree Right Side View $\\star\\star$"},{"location":"golang/0101-0200/0191-0200/#200-number-of-islands-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int numIslands ( vector < vector < char >>& grid ) { if ( grid . empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> visited ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( ! visited [ i ][ j ] && grid [ i ][ j ] == '1' ) { ++ ans ; dfs ( grid , i , j , visited ); } return ans ; } private : void dfs ( vector < vector < char >>& grid , int i , int j , vector < vector < bool >>& visited ) { if ( i < 0 || j < 0 || i >= grid . size () || j >= grid [ 0 ]. size () || visited [ i ][ j ] || grid [ i ][ j ] == '0' ) return ; visited [ i ][ j ] = true ; dfs ( grid , i + 1 , j , visited ); dfs ( grid , i - 1 , j , visited ); dfs ( grid , i , j + 1 , visited ); dfs ( grid , i , j - 1 , visited ); } };","title":"200. Number of Islands $\\star\\star$"},{"location":"golang/0201-0300/0201-0210/","text":"201. Bitwise AND of Numbers Range $\\star\\star$ 1 2 3 4 5 6 class Solution { public : int rangeBitwiseAnd ( int m , int n ) { return m < n ? rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 : m ; } }; 202. Happy Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool isHappy ( int n ) { int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } if ( slow == 1 ) return true ; return false ; } private : int helper ( int n ) { int sum = 0 ; while ( n ) { sum += pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } }; 203. Remove Linked List Elements $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : ListNode * removeElements ( ListNode * head , int val ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * curr = & dummy ; while ( curr ) { ListNode * next = curr -> next ; while ( next && next -> val == val ) next = next -> next ; curr -> next = next ; curr = next ; } return dummy . next ; } }; 204. Count Primes $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int countPrimes ( int n ) { if ( n <= 2 ) return 0 ; vector < bool > prime ( n , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i < sqrt ( n ); ++ i ) if ( prime [ i ]) for ( int j = i * 2 ; j < n ; j += i ) prime [ j ] = false ; return count ( prime . begin (), prime . end (), true ); } }; 205. Isomorphic Strings $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isIsomorphic ( string s , string t ) { unordered_map < char , int > map_s ; unordered_map < char , int > map_t ; for ( int i = 0 ; i < s . length (); ++ i ) { if ( map_s [ s [ i ]] != map_t [ t [ i ]]) return false ; map_s [ s [ i ]] = i + 1 ; map_t [ t [ i ]] = i + 1 ; } return true ; } }; 206. Reverse Linked List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { auto next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } }; 207. Course Schedule $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool canFinish ( int numCourses , vector < vector < int >>& prerequisites ) { vector < vector < int >> graph ( numCourses ); vector < int > visited ( numCourses , 0 ); for ( vector < int >& prerequisite : prerequisites ) graph [ prerequisite [ 1 ]]. push_back ( prerequisite [ 0 ]); for ( int i = 0 ; i < numCourses ; ++ i ) if ( dfs ( graph , visited , i )) return false ; return true ; } private : bool dfs ( vector < vector < int >>& graph , vector < int >& visited , int curr ) { if ( visited [ curr ] == 1 ) return true ; if ( visited [ curr ] == 2 ) return false ; visited [ curr ] = 1 ; for ( int neighbor : graph [ curr ]) if ( dfs ( graph , visited , neighbor )) return true ; visited [ curr ] = 2 ; return false ; } }; 208. Implement Trie (Prefix Tree) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Trie { public : void insert ( string word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> isWord = true ; } bool search ( string word ) { TrieNode * node = find ( word ); return node && node -> isWord ; } bool startsWith ( string prefix ) { return find ( prefix ); } private : struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; TrieNode root ; TrieNode * find ( string & prefix ) { TrieNode * node = & root ; for ( char c : prefix ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) return nullptr ; node = next ; } return node ; } }; 209. Minimum Size Subarray Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int minSubArrayLen ( int s , vector < int >& nums ) { int ans = INT_MAX ; int sum = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; while ( sum >= s ) { ans = min ( ans , i - j + 1 ); sum -= nums [ j ++ ]; } } return ans != INT_MAX ? ans : 0 ; } }; 210. Course Schedule II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < int > findOrder ( int numCourses , vector < vector < int >>& prerequisites ) { vector < int > ans ; vector < vector < int >> graph ( numCourses ); vector < int > visited ( numCourses , 0 ); for ( vector < int >& prerequisite : prerequisites ) graph [ prerequisite [ 0 ]]. push_back ( prerequisite [ 1 ]); for ( int i = 0 ; i < numCourses ; ++ i ) if ( dfs ( graph , visited , i , ans )) return {}; return ans ; } private : bool dfs ( vector < vector < int >>& graph , vector < int >& visited , int curr , vector < int >& ans ) { if ( visited [ curr ] == 1 ) return true ; if ( visited [ curr ] == 2 ) return false ; visited [ curr ] = 1 ; for ( int neighbor : graph [ curr ]) if ( dfs ( graph , visited , neighbor , ans )) return true ; visited [ curr ] = 2 ; ans . push_back ( curr ); return false ; } };","title":"0201-0210"},{"location":"golang/0201-0300/0201-0210/#201-bitwise-and-of-numbers-range-starstar","text":"1 2 3 4 5 6 class Solution { public : int rangeBitwiseAnd ( int m , int n ) { return m < n ? rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 : m ; } };","title":"201. Bitwise AND of Numbers Range $\\star\\star$"},{"location":"golang/0201-0300/0201-0210/#202-happy-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool isHappy ( int n ) { int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } if ( slow == 1 ) return true ; return false ; } private : int helper ( int n ) { int sum = 0 ; while ( n ) { sum += pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } };","title":"202. Happy Number $\\star$"},{"location":"golang/0201-0300/0201-0210/#203-remove-linked-list-elements-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : ListNode * removeElements ( ListNode * head , int val ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * curr = & dummy ; while ( curr ) { ListNode * next = curr -> next ; while ( next && next -> val == val ) next = next -> next ; curr -> next = next ; curr = next ; } return dummy . next ; } };","title":"203. Remove Linked List Elements $\\star$"},{"location":"golang/0201-0300/0201-0210/#204-count-primes-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int countPrimes ( int n ) { if ( n <= 2 ) return 0 ; vector < bool > prime ( n , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i < sqrt ( n ); ++ i ) if ( prime [ i ]) for ( int j = i * 2 ; j < n ; j += i ) prime [ j ] = false ; return count ( prime . begin (), prime . end (), true ); } };","title":"204. Count Primes $\\star$"},{"location":"golang/0201-0300/0201-0210/#205-isomorphic-strings-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isIsomorphic ( string s , string t ) { unordered_map < char , int > map_s ; unordered_map < char , int > map_t ; for ( int i = 0 ; i < s . length (); ++ i ) { if ( map_s [ s [ i ]] != map_t [ t [ i ]]) return false ; map_s [ s [ i ]] = i + 1 ; map_t [ t [ i ]] = i + 1 ; } return true ; } };","title":"205. Isomorphic Strings $\\star$"},{"location":"golang/0201-0300/0201-0210/#206-reverse-linked-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { auto next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } };","title":"206. Reverse Linked List $\\star$"},{"location":"golang/0201-0300/0201-0210/#207-course-schedule-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool canFinish ( int numCourses , vector < vector < int >>& prerequisites ) { vector < vector < int >> graph ( numCourses ); vector < int > visited ( numCourses , 0 ); for ( vector < int >& prerequisite : prerequisites ) graph [ prerequisite [ 1 ]]. push_back ( prerequisite [ 0 ]); for ( int i = 0 ; i < numCourses ; ++ i ) if ( dfs ( graph , visited , i )) return false ; return true ; } private : bool dfs ( vector < vector < int >>& graph , vector < int >& visited , int curr ) { if ( visited [ curr ] == 1 ) return true ; if ( visited [ curr ] == 2 ) return false ; visited [ curr ] = 1 ; for ( int neighbor : graph [ curr ]) if ( dfs ( graph , visited , neighbor )) return true ; visited [ curr ] = 2 ; return false ; } };","title":"207. Course Schedule $\\star\\star$"},{"location":"golang/0201-0300/0201-0210/#208-implement-trie-prefix-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Trie { public : void insert ( string word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> isWord = true ; } bool search ( string word ) { TrieNode * node = find ( word ); return node && node -> isWord ; } bool startsWith ( string prefix ) { return find ( prefix ); } private : struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; TrieNode root ; TrieNode * find ( string & prefix ) { TrieNode * node = & root ; for ( char c : prefix ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) return nullptr ; node = next ; } return node ; } };","title":"208. Implement Trie (Prefix Tree) $\\star\\star$"},{"location":"golang/0201-0300/0201-0210/#209-minimum-size-subarray-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int minSubArrayLen ( int s , vector < int >& nums ) { int ans = INT_MAX ; int sum = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; while ( sum >= s ) { ans = min ( ans , i - j + 1 ); sum -= nums [ j ++ ]; } } return ans != INT_MAX ? ans : 0 ; } };","title":"209. Minimum Size Subarray Sum $\\star\\star$"},{"location":"golang/0201-0300/0201-0210/#210-course-schedule-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < int > findOrder ( int numCourses , vector < vector < int >>& prerequisites ) { vector < int > ans ; vector < vector < int >> graph ( numCourses ); vector < int > visited ( numCourses , 0 ); for ( vector < int >& prerequisite : prerequisites ) graph [ prerequisite [ 0 ]]. push_back ( prerequisite [ 1 ]); for ( int i = 0 ; i < numCourses ; ++ i ) if ( dfs ( graph , visited , i , ans )) return {}; return ans ; } private : bool dfs ( vector < vector < int >>& graph , vector < int >& visited , int curr , vector < int >& ans ) { if ( visited [ curr ] == 1 ) return true ; if ( visited [ curr ] == 2 ) return false ; visited [ curr ] = 1 ; for ( int neighbor : graph [ curr ]) if ( dfs ( graph , visited , neighbor , ans )) return true ; visited [ curr ] = 2 ; ans . push_back ( curr ); return false ; } };","title":"210. Course Schedule II $\\star\\star$"},{"location":"golang/0201-0300/0211-0220/","text":"211. Add and Search Word - Data structure design $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class WordDictionary { public : void addWord ( string word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> isWord = true ; } bool search ( string word ) { return dfs ( word , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; TrieNode root ; bool dfs ( const string & word , int depth , TrieNode * node ) { if ( depth == word . length ()) return node -> isWord ; if ( word [ depth ] != '.' ) { TrieNode * next = node -> children [ word [ depth ] - 'a' ]; return next ? dfs ( word , depth + 1 , next ) : false ; } for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ] && dfs ( word , depth + 1 , node -> children [ i ])) return true ; return false ; } }; 212. Word Search II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { for ( const string & word : words ) insert ( word ); vector < string > ans ; for ( int i = 0 ; i < board . size (); ++ i ) for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) dfs ( board , i , j , & root , ans ); return ans ; } private : struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete ( child ); } vector < TrieNode *> children ; const string * word ; }; TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> word = & word ; } void dfs ( vector < vector < char >>& board , int i , int j , TrieNode * node , vector < string >& ans ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] == '*' ) return ; char c = board [ i ][ j ]; TrieNode * next = node -> children [ c - 'a' ]; if ( ! next ) return ; if ( next -> word ) { ans . push_back ( * next -> word ); next -> word = nullptr ; } board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j , next , ans ); dfs ( board , i - 1 , j , next , ans ); dfs ( board , i , j + 1 , next , ans ); dfs ( board , i , j - 1 , next , ans ); board [ i ][ j ] = c ; } }; 213. House Robber II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int rob ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; if ( nums . size () < 2 ) return nums [ 0 ]; const int n = nums . size (); return max ( rob ( nums , 0 , n - 2 ), rob ( nums , 1 , n - 1 )); } private : int rob ( vector < int >& nums , int l , int r ) { int dp1 = 0 ; int dp2 = 0 ; for ( int i = l ; i <= r ; ++ i ) { int temp = dp1 ; dp1 = max ( dp1 , dp2 + nums [ i ]); dp2 = temp ; } return dp1 ; } }; 214. Shortest Palindrome $\\star\\star\\star$ 215. Kth Largest Element in an Array $\\star\\star$ 1 2 3 4 5 6 7 8 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { nth_element ( nums . begin (), nums . begin () + k - 1 , nums . end (), greater < int > ()); return nums [ k - 1 ]; } }; 216. Combination Sum III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; vector < int > path ; dfs ( k , n , 1 , path , ans ); return ans ; } private : void dfs ( int k , int n , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( k == 0 && n == 0 ) { ans . push_back ( path ); return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . push_back ( i ); dfs ( k - 1 , n - i , i + 1 , path , ans ); path . pop_back (); } } }; 217. Contains Duplicate $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > set ; for ( int num : nums ) { if ( set . count ( num )) return true ; set . insert ( num ); } return false ; } }; 218. The Skyline Problem $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : vector < vector < int >> getSkyline ( vector < vector < int >>& buildings ) { vector < vector < int >> ans ; vector < vector < int >> events ; for ( vector < int >& building : buildings ) { events . push_back ({ building [ 0 ], building [ 2 ]}); events . push_back ({ building [ 1 ], - building [ 2 ]}); } sort ( events . begin (), events . end (), []( const vector < int >& e1 , const vector < int >& e2 ) { return e1 [ 0 ] == e2 [ 0 ] ? e1 [ 1 ] > e2 [ 1 ] : e1 [ 0 ] < e2 [ 0 ]; }); for ( vector < int >& event : events ) { int x = event [ 0 ]; int h = abs ( event [ 1 ]); if ( event [ 1 ] > 0 ) { if ( h > maxHeight ()) ans . push_back ({ x , h }); set . insert ( h ); } else { set . erase ( set . equal_range ( h ). first ); if ( h > maxHeight ()) ans . push_back ({ x , maxHeight ()}); } } return ans ; } private : multiset < int > set ; int maxHeight () const { return set . empty () ? 0 : * set . rbegin (); } }; 219. Contains Duplicate II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { unordered_set < int > set ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( i > k ) set . erase ( nums [ i - k - 1 ]); if ( set . count ( nums [ i ])) return true ; set . insert ( nums [ i ]); } return false ; } }; 220. Contains Duplicate III $\\star\\star$","title":"0211-0220"},{"location":"golang/0201-0300/0211-0220/#211-add-and-search-word-data-structure-design-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class WordDictionary { public : void addWord ( string word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> isWord = true ; } bool search ( string word ) { return dfs ( word , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; TrieNode root ; bool dfs ( const string & word , int depth , TrieNode * node ) { if ( depth == word . length ()) return node -> isWord ; if ( word [ depth ] != '.' ) { TrieNode * next = node -> children [ word [ depth ] - 'a' ]; return next ? dfs ( word , depth + 1 , next ) : false ; } for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ] && dfs ( word , depth + 1 , node -> children [ i ])) return true ; return false ; } };","title":"211. Add and Search Word - Data structure design $\\star\\star$"},{"location":"golang/0201-0300/0211-0220/#212-word-search-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { for ( const string & word : words ) insert ( word ); vector < string > ans ; for ( int i = 0 ; i < board . size (); ++ i ) for ( int j = 0 ; j < board [ 0 ]. size (); ++ j ) dfs ( board , i , j , & root , ans ); return ans ; } private : struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete ( child ); } vector < TrieNode *> children ; const string * word ; }; TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> word = & word ; } void dfs ( vector < vector < char >>& board , int i , int j , TrieNode * node , vector < string >& ans ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] == '*' ) return ; char c = board [ i ][ j ]; TrieNode * next = node -> children [ c - 'a' ]; if ( ! next ) return ; if ( next -> word ) { ans . push_back ( * next -> word ); next -> word = nullptr ; } board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j , next , ans ); dfs ( board , i - 1 , j , next , ans ); dfs ( board , i , j + 1 , next , ans ); dfs ( board , i , j - 1 , next , ans ); board [ i ][ j ] = c ; } };","title":"212. Word Search II $\\star\\star\\star$"},{"location":"golang/0201-0300/0211-0220/#213-house-robber-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int rob ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; if ( nums . size () < 2 ) return nums [ 0 ]; const int n = nums . size (); return max ( rob ( nums , 0 , n - 2 ), rob ( nums , 1 , n - 1 )); } private : int rob ( vector < int >& nums , int l , int r ) { int dp1 = 0 ; int dp2 = 0 ; for ( int i = l ; i <= r ; ++ i ) { int temp = dp1 ; dp1 = max ( dp1 , dp2 + nums [ i ]); dp2 = temp ; } return dp1 ; } };","title":"213. House Robber II $\\star\\star$"},{"location":"golang/0201-0300/0211-0220/#214-shortest-palindrome-starstarstar","text":"","title":"214. Shortest Palindrome $\\star\\star\\star$"},{"location":"golang/0201-0300/0211-0220/#215-kth-largest-element-in-an-array-starstar","text":"1 2 3 4 5 6 7 8 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { nth_element ( nums . begin (), nums . begin () + k - 1 , nums . end (), greater < int > ()); return nums [ k - 1 ]; } };","title":"215. Kth Largest Element in an Array $\\star\\star$"},{"location":"golang/0201-0300/0211-0220/#216-combination-sum-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; vector < int > path ; dfs ( k , n , 1 , path , ans ); return ans ; } private : void dfs ( int k , int n , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( k == 0 && n == 0 ) { ans . push_back ( path ); return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; ++ i ) { path . push_back ( i ); dfs ( k - 1 , n - i , i + 1 , path , ans ); path . pop_back (); } } };","title":"216. Combination Sum III $\\star\\star$"},{"location":"golang/0201-0300/0211-0220/#217-contains-duplicate-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > set ; for ( int num : nums ) { if ( set . count ( num )) return true ; set . insert ( num ); } return false ; } };","title":"217. Contains Duplicate $\\star$"},{"location":"golang/0201-0300/0211-0220/#218-the-skyline-problem-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : vector < vector < int >> getSkyline ( vector < vector < int >>& buildings ) { vector < vector < int >> ans ; vector < vector < int >> events ; for ( vector < int >& building : buildings ) { events . push_back ({ building [ 0 ], building [ 2 ]}); events . push_back ({ building [ 1 ], - building [ 2 ]}); } sort ( events . begin (), events . end (), []( const vector < int >& e1 , const vector < int >& e2 ) { return e1 [ 0 ] == e2 [ 0 ] ? e1 [ 1 ] > e2 [ 1 ] : e1 [ 0 ] < e2 [ 0 ]; }); for ( vector < int >& event : events ) { int x = event [ 0 ]; int h = abs ( event [ 1 ]); if ( event [ 1 ] > 0 ) { if ( h > maxHeight ()) ans . push_back ({ x , h }); set . insert ( h ); } else { set . erase ( set . equal_range ( h ). first ); if ( h > maxHeight ()) ans . push_back ({ x , maxHeight ()}); } } return ans ; } private : multiset < int > set ; int maxHeight () const { return set . empty () ? 0 : * set . rbegin (); } };","title":"218. The Skyline Problem $\\star\\star\\star$"},{"location":"golang/0201-0300/0211-0220/#219-contains-duplicate-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { unordered_set < int > set ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( i > k ) set . erase ( nums [ i - k - 1 ]); if ( set . count ( nums [ i ])) return true ; set . insert ( nums [ i ]); } return false ; } };","title":"219. Contains Duplicate II $\\star$"},{"location":"golang/0201-0300/0211-0220/#220-contains-duplicate-iii-starstar","text":"","title":"220. Contains Duplicate III $\\star\\star$"},{"location":"golang/0201-0300/0221-0230/","text":"221. Maximal Square $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maximalSquare ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < int > dp ( n ); int max = 0 ; int prev = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int temp = dp [ j ]; dp [ j ] = ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) ? matrix [ i ][ j ] - '0' : min ( dp [ j ], min ( dp [ j - 1 ], prev )) + 1 ; max = std :: max ( max , dp [ j ]); prev = temp ; } return max * max ; } }; 222. Count Complete Tree Nodes $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int countNodes ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { ++ ans ; TreeNode * node = queue . front (); queue . pop (); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } return ans ; } }; 223. Rectangle Area $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int computeArea ( int A , int B , int C , int D , int E , int F , int G , int H ) { long x = max ( A , E ) < min ( C , G ) ? ( min ( C , G ) - max ( A , E )) : 0 ; long y = max ( B , F ) < min ( D , H ) ? ( min ( D , H ) - max ( B , F )) : 0 ; return ( long )( C - A ) * ( long )( D - B ) + ( long )( G - E ) * ( long )( H - F ) - x * y ; } }; 224. Basic Calculator $\\star\\star\\star$ 225. Implement Stack using Queues $\\star$ 226. Invert Binary Tree $\\star$ 227. Basic Calculator II $\\star\\star$ 228. Summary Ranges $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < string > summaryRanges ( vector < int >& nums ) { vector < string > ans ; for ( int i = 0 ; i < nums . size (); ++ i ) { int begin = nums [ i ]; while ( i < nums . size () - 1 && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; int end = nums [ i ]; if ( begin == end ) ans . push_back ( to_string ( begin )); else ans . push_back ( to_string ( begin ) + \"->\" + to_string ( end )); } return ans ; } }; 229. Majority Element II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : vector < int > majorityElement ( vector < int >& nums ) { vector < int > ans ; int ans1 = 0 ; int ans2 = 1 ; int count1 = 0 ; int count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; else if ( count1 == 0 ) { ans1 = num ; ++ count1 ; } else if ( count2 == 0 ) { ans2 = num ; ++ count2 ; } else { -- count1 ; -- count2 ; } } count1 = 0 ; count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; } if ( count1 > nums . size () / 3 ) ans . push_back ( ans1 ); if ( count2 > nums . size () / 3 ) ans . push_back ( ans2 ); return ans ; } }; 230. Kth Smallest Element in a BST $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int kthSmallest ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); return nums [ k - 1 ]; } private : void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } };","title":"0221-0230"},{"location":"golang/0201-0300/0221-0230/#221-maximal-square-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maximalSquare ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < int > dp ( n ); int max = 0 ; int prev = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int temp = dp [ j ]; dp [ j ] = ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) ? matrix [ i ][ j ] - '0' : min ( dp [ j ], min ( dp [ j - 1 ], prev )) + 1 ; max = std :: max ( max , dp [ j ]); prev = temp ; } return max * max ; } };","title":"221. Maximal Square $\\star\\star$"},{"location":"golang/0201-0300/0221-0230/#222-count-complete-tree-nodes-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int countNodes ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { ++ ans ; TreeNode * node = queue . front (); queue . pop (); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } return ans ; } };","title":"222. Count Complete Tree Nodes $\\star\\star$"},{"location":"golang/0201-0300/0221-0230/#223-rectangle-area-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int computeArea ( int A , int B , int C , int D , int E , int F , int G , int H ) { long x = max ( A , E ) < min ( C , G ) ? ( min ( C , G ) - max ( A , E )) : 0 ; long y = max ( B , F ) < min ( D , H ) ? ( min ( D , H ) - max ( B , F )) : 0 ; return ( long )( C - A ) * ( long )( D - B ) + ( long )( G - E ) * ( long )( H - F ) - x * y ; } };","title":"223. Rectangle Area $\\star\\star$"},{"location":"golang/0201-0300/0221-0230/#224-basic-calculator-starstarstar","text":"","title":"224. Basic Calculator $\\star\\star\\star$"},{"location":"golang/0201-0300/0221-0230/#225-implement-stack-using-queues-star","text":"","title":"225. Implement Stack using Queues $\\star$"},{"location":"golang/0201-0300/0221-0230/#226-invert-binary-tree-star","text":"","title":"226. Invert Binary Tree $\\star$"},{"location":"golang/0201-0300/0221-0230/#227-basic-calculator-ii-starstar","text":"","title":"227. Basic Calculator II $\\star\\star$"},{"location":"golang/0201-0300/0221-0230/#228-summary-ranges-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < string > summaryRanges ( vector < int >& nums ) { vector < string > ans ; for ( int i = 0 ; i < nums . size (); ++ i ) { int begin = nums [ i ]; while ( i < nums . size () - 1 && nums [ i ] == nums [ i + 1 ] - 1 ) ++ i ; int end = nums [ i ]; if ( begin == end ) ans . push_back ( to_string ( begin )); else ans . push_back ( to_string ( begin ) + \"->\" + to_string ( end )); } return ans ; } };","title":"228. Summary Ranges $\\star\\star$"},{"location":"golang/0201-0300/0221-0230/#229-majority-element-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : vector < int > majorityElement ( vector < int >& nums ) { vector < int > ans ; int ans1 = 0 ; int ans2 = 1 ; int count1 = 0 ; int count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; else if ( count1 == 0 ) { ans1 = num ; ++ count1 ; } else if ( count2 == 0 ) { ans2 = num ; ++ count2 ; } else { -- count1 ; -- count2 ; } } count1 = 0 ; count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) ++ count1 ; else if ( num == ans2 ) ++ count2 ; } if ( count1 > nums . size () / 3 ) ans . push_back ( ans1 ); if ( count2 > nums . size () / 3 ) ans . push_back ( ans2 ); return ans ; } };","title":"229. Majority Element II $\\star\\star$"},{"location":"golang/0201-0300/0221-0230/#230-kth-smallest-element-in-a-bst-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int kthSmallest ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); return nums [ k - 1 ]; } private : void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } };","title":"230. Kth Smallest Element in a BST $\\star\\star$"},{"location":"golang/0201-0300/0231-0240/","text":"231. Power of Two $\\star$ 232. Implement Queue using Stacks $\\star$ 233. Number of Digit One $\\star\\star\\star$ 234. Palindrome Linked List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : bool isPalindrome ( ListNode * head ) { if ( ! head || ! head -> next ) return true ; auto slow = head ; auto fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) slow = slow -> next ; slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) return false ; slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } }; 235. Lowest Common Ancestor of a Binary Search Tree $\\star$ 236. Lowest Common Ancestor of a Binary Tree $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root || root == p || root == q ) return root ; TreeNode * left = lowestCommonAncestor ( root -> left , p , q ); TreeNode * right = lowestCommonAncestor ( root -> right , p , q ); if ( ! left ) return right ; if ( ! right ) return left ; return root ; } }; 237. Delete Node in a Linked List $\\star$ 1 2 3 4 5 6 7 class Solution { public : void deleteNode ( ListNode * node ) { node -> val = node -> next -> val ; node -> next = node -> next -> next ; } }; 238. Product of Array Except Self $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > ans ( nums . size (), 0 ); ans [ 0 ] = 1 ; int r = 1 ; for ( int i = 1 ; i < nums . size (); ++ i ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]; for ( int i = nums . size () - 1 ; i >= 0 ; -- i ) { ans [ i ] *= r ; r *= nums [ i ]; } return ans ; } }; 239. Sliding Window Maximum $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; deque < int > deque ; for ( int i = 0 ; i < nums . size (); ++ i ) { while ( ! deque . empty () && nums [ i ] > deque . back ()) deque . pop_back (); deque . push_back ( nums [ i ]); if ( i - k + 1 >= 0 ) { ans . push_back ( deque . front ()); if ( nums [ i - k + 1 ] == deque . front ()) deque . pop_front (); } } return ans ; } }; 240. Search a 2D Matrix II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; int r = 0 ; int c = matrix [ 0 ]. size () - 1 ; while ( r < matrix . size () && c >= 0 ) { if ( matrix [ r ][ c ] == target ) return true ; target < matrix [ r ][ c ] ? -- c : ++ r ; } return false ; } };","title":"0231-0240"},{"location":"golang/0201-0300/0231-0240/#231-power-of-two-star","text":"","title":"231. Power of Two $\\star$"},{"location":"golang/0201-0300/0231-0240/#232-implement-queue-using-stacks-star","text":"","title":"232. Implement Queue using Stacks $\\star$"},{"location":"golang/0201-0300/0231-0240/#233-number-of-digit-one-starstarstar","text":"","title":"233. Number of Digit One $\\star\\star\\star$"},{"location":"golang/0201-0300/0231-0240/#234-palindrome-linked-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : bool isPalindrome ( ListNode * head ) { if ( ! head || ! head -> next ) return true ; auto slow = head ; auto fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) slow = slow -> next ; slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) return false ; slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } };","title":"234. Palindrome Linked List $\\star$"},{"location":"golang/0201-0300/0231-0240/#235-lowest-common-ancestor-of-a-binary-search-tree-star","text":"","title":"235. Lowest Common Ancestor of a Binary Search Tree $\\star$"},{"location":"golang/0201-0300/0231-0240/#236-lowest-common-ancestor-of-a-binary-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root || root == p || root == q ) return root ; TreeNode * left = lowestCommonAncestor ( root -> left , p , q ); TreeNode * right = lowestCommonAncestor ( root -> right , p , q ); if ( ! left ) return right ; if ( ! right ) return left ; return root ; } };","title":"236. Lowest Common Ancestor of a Binary Tree $\\star\\star$"},{"location":"golang/0201-0300/0231-0240/#237-delete-node-in-a-linked-list-star","text":"1 2 3 4 5 6 7 class Solution { public : void deleteNode ( ListNode * node ) { node -> val = node -> next -> val ; node -> next = node -> next -> next ; } };","title":"237. Delete Node in a Linked List $\\star$"},{"location":"golang/0201-0300/0231-0240/#238-product-of-array-except-self-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > ans ( nums . size (), 0 ); ans [ 0 ] = 1 ; int r = 1 ; for ( int i = 1 ; i < nums . size (); ++ i ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]; for ( int i = nums . size () - 1 ; i >= 0 ; -- i ) { ans [ i ] *= r ; r *= nums [ i ]; } return ans ; } };","title":"238. Product of Array Except Self $\\star\\star$"},{"location":"golang/0201-0300/0231-0240/#239-sliding-window-maximum-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; deque < int > deque ; for ( int i = 0 ; i < nums . size (); ++ i ) { while ( ! deque . empty () && nums [ i ] > deque . back ()) deque . pop_back (); deque . push_back ( nums [ i ]); if ( i - k + 1 >= 0 ) { ans . push_back ( deque . front ()); if ( nums [ i - k + 1 ] == deque . front ()) deque . pop_front (); } } return ans ; } };","title":"239. Sliding Window Maximum $\\star\\star\\star$"},{"location":"golang/0201-0300/0231-0240/#240-search-a-2d-matrix-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; int r = 0 ; int c = matrix [ 0 ]. size () - 1 ; while ( r < matrix . size () && c >= 0 ) { if ( matrix [ r ][ c ] == target ) return true ; target < matrix [ r ][ c ] ? -- c : ++ r ; } return false ; } };","title":"240. Search a 2D Matrix II $\\star\\star$"},{"location":"golang/0201-0300/0241-0250/","text":"241. Different Ways to Add Parentheses $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > diffWaysToCompute ( string input ) { vector < int > ans ; for ( int i = 0 ; i < input . size (); ++ i ) if ( ispunct ( input [ i ])) { vector < int > left = diffWaysToCompute ( input . substr ( 0 , i )); vector < int > right = diffWaysToCompute ( input . substr ( i + 1 )); for ( int a : left ) for ( int b : right ) ans . push_back ( input [ i ] == '+' ? a + b : input [ i ] == '-' ? a - b : a * b ); } return ans . empty () ? vector < int > { stoi ( input )} : ans ; } }; 242. Valid Anagram $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isAnagram ( string s , string t ) { if ( s . length () != t . length ()) return false ; unordered_map < char , int > map ; for ( char c : s ) ++ map [ c ]; for ( char c : t ) if ( -- map [ c ] < 0 ) return false ; return true ; } }; 243. Shortest Word Distance $\\star$ 244. Shortest Word Distance II $\\star\\star$ 245. Shortest Word Distance III $\\star\\star$ 246. Strobogrammatic Number $\\star$ 247. Strobogrammatic Number II $\\star\\star$ 248. Strobogrammatic Number III $\\star\\star\\star$ 249. Group Shifted Strings $\\star\\star$ 250. Count Univalue Subtrees $\\star\\star$","title":"0241-0250"},{"location":"golang/0201-0300/0241-0250/#241-different-ways-to-add-parentheses-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > diffWaysToCompute ( string input ) { vector < int > ans ; for ( int i = 0 ; i < input . size (); ++ i ) if ( ispunct ( input [ i ])) { vector < int > left = diffWaysToCompute ( input . substr ( 0 , i )); vector < int > right = diffWaysToCompute ( input . substr ( i + 1 )); for ( int a : left ) for ( int b : right ) ans . push_back ( input [ i ] == '+' ? a + b : input [ i ] == '-' ? a - b : a * b ); } return ans . empty () ? vector < int > { stoi ( input )} : ans ; } };","title":"241. Different Ways to Add Parentheses $\\star\\star$"},{"location":"golang/0201-0300/0241-0250/#242-valid-anagram-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isAnagram ( string s , string t ) { if ( s . length () != t . length ()) return false ; unordered_map < char , int > map ; for ( char c : s ) ++ map [ c ]; for ( char c : t ) if ( -- map [ c ] < 0 ) return false ; return true ; } };","title":"242. Valid Anagram $\\star$"},{"location":"golang/0201-0300/0241-0250/#243-shortest-word-distance-star","text":"","title":"243. Shortest Word Distance $\\star$"},{"location":"golang/0201-0300/0241-0250/#244-shortest-word-distance-ii-starstar","text":"","title":"244. Shortest Word Distance II $\\star\\star$"},{"location":"golang/0201-0300/0241-0250/#245-shortest-word-distance-iii-starstar","text":"","title":"245. Shortest Word Distance III $\\star\\star$"},{"location":"golang/0201-0300/0241-0250/#246-strobogrammatic-number-star","text":"","title":"246. Strobogrammatic Number $\\star$"},{"location":"golang/0201-0300/0241-0250/#247-strobogrammatic-number-ii-starstar","text":"","title":"247. Strobogrammatic Number II $\\star\\star$"},{"location":"golang/0201-0300/0241-0250/#248-strobogrammatic-number-iii-starstarstar","text":"","title":"248. Strobogrammatic Number III $\\star\\star\\star$"},{"location":"golang/0201-0300/0241-0250/#249-group-shifted-strings-starstar","text":"","title":"249. Group Shifted Strings $\\star\\star$"},{"location":"golang/0201-0300/0241-0250/#250-count-univalue-subtrees-starstar","text":"","title":"250. Count Univalue Subtrees $\\star\\star$"},{"location":"golang/0201-0300/0251-0260/","text":"251. Flatten 2D Vector $\\star\\star$ 252. Meeting Rooms $\\star$ 253. Meeting Rooms II $\\star\\star$ 254. Factor Combinations $\\star\\star$ 255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$ 256. Paint House $\\star$ 257. Binary Tree Paths $\\star$ 258. Add Digits $\\star$ 259. 3Sum Smaller $\\star\\star$ 260. Single Number III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { vector < int > ans ( 2 ); int xor_ = accumulate ( nums . begin (), nums . end (), 0 , bit_xor < int > ()); xor_ &= - xor_ ; for ( int num : nums ) { if ( num & xor_ ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; } return ans ; } };","title":"0251-0260"},{"location":"golang/0201-0300/0251-0260/#251-flatten-2d-vector-starstar","text":"","title":"251. Flatten 2D Vector $\\star\\star$"},{"location":"golang/0201-0300/0251-0260/#252-meeting-rooms-star","text":"","title":"252. Meeting Rooms $\\star$"},{"location":"golang/0201-0300/0251-0260/#253-meeting-rooms-ii-starstar","text":"","title":"253. Meeting Rooms II $\\star\\star$"},{"location":"golang/0201-0300/0251-0260/#254-factor-combinations-starstar","text":"","title":"254. Factor Combinations $\\star\\star$"},{"location":"golang/0201-0300/0251-0260/#255-verify-preorder-sequence-in-binary-search-tree-starstar","text":"","title":"255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$"},{"location":"golang/0201-0300/0251-0260/#256-paint-house-star","text":"","title":"256. Paint House $\\star$"},{"location":"golang/0201-0300/0251-0260/#257-binary-tree-paths-star","text":"","title":"257. Binary Tree Paths $\\star$"},{"location":"golang/0201-0300/0251-0260/#258-add-digits-star","text":"","title":"258. Add Digits $\\star$"},{"location":"golang/0201-0300/0251-0260/#259-3sum-smaller-starstar","text":"","title":"259. 3Sum Smaller $\\star\\star$"},{"location":"golang/0201-0300/0251-0260/#260-single-number-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { vector < int > ans ( 2 ); int xor_ = accumulate ( nums . begin (), nums . end (), 0 , bit_xor < int > ()); xor_ &= - xor_ ; for ( int num : nums ) { if ( num & xor_ ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; } return ans ; } };","title":"260. Single Number III $\\star\\star$"},{"location":"golang/0201-0300/0261-0270/","text":"261. Graph Valid Tree $\\star\\star$ 262. Trips and Users $\\star\\star\\star$ 263. Ugly Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isUgly ( int num ) { if ( num == 0 ) return false ; vector < int > factors { 2 , 3 , 5 }; for ( int factor : factors ) while ( num % factor == 0 ) num /= factor ; return num == 1 ; } }; 264. Ugly Number II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int nthUglyNumber ( int n ) { vector < int > nums { 1 }; int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( nums . size () < n ) { int next2 = nums [ i2 ] * 2 ; int next3 = nums [ i3 ] * 3 ; int next5 = nums [ i5 ] * 5 ; int next = min ( next2 , min ( next3 , next5 )); if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; nums . push_back ( next ); } return nums . back (); } }; 265. Paint House II $\\star\\star\\star$ 266. Palindrome Permutation $\\star$ 267. Palindrome Permutation II $\\star\\star$ 268. Missing Number $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int missingNumber ( vector < int >& nums ) { int ans = nums . size (); for ( int i = 0 ; i < nums . size (); ++ i ) ans ^= i ^ nums [ i ]; return ans ; } }; 269. Alien Dictionary $\\star\\star\\star$ 270. Closest Binary Search Tree Value $\\star$","title":"0261-0270"},{"location":"golang/0201-0300/0261-0270/#261-graph-valid-tree-starstar","text":"","title":"261. Graph Valid Tree $\\star\\star$"},{"location":"golang/0201-0300/0261-0270/#262-trips-and-users-starstarstar","text":"","title":"262. Trips and Users $\\star\\star\\star$"},{"location":"golang/0201-0300/0261-0270/#263-ugly-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isUgly ( int num ) { if ( num == 0 ) return false ; vector < int > factors { 2 , 3 , 5 }; for ( int factor : factors ) while ( num % factor == 0 ) num /= factor ; return num == 1 ; } };","title":"263. Ugly Number $\\star$"},{"location":"golang/0201-0300/0261-0270/#264-ugly-number-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int nthUglyNumber ( int n ) { vector < int > nums { 1 }; int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( nums . size () < n ) { int next2 = nums [ i2 ] * 2 ; int next3 = nums [ i3 ] * 3 ; int next5 = nums [ i5 ] * 5 ; int next = min ( next2 , min ( next3 , next5 )); if ( next == next2 ) ++ i2 ; if ( next == next3 ) ++ i3 ; if ( next == next5 ) ++ i5 ; nums . push_back ( next ); } return nums . back (); } };","title":"264. Ugly Number II $\\star\\star$"},{"location":"golang/0201-0300/0261-0270/#265-paint-house-ii-starstarstar","text":"","title":"265. Paint House II $\\star\\star\\star$"},{"location":"golang/0201-0300/0261-0270/#266-palindrome-permutation-star","text":"","title":"266. Palindrome Permutation $\\star$"},{"location":"golang/0201-0300/0261-0270/#267-palindrome-permutation-ii-starstar","text":"","title":"267. Palindrome Permutation II $\\star\\star$"},{"location":"golang/0201-0300/0261-0270/#268-missing-number-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int missingNumber ( vector < int >& nums ) { int ans = nums . size (); for ( int i = 0 ; i < nums . size (); ++ i ) ans ^= i ^ nums [ i ]; return ans ; } };","title":"268. Missing Number $\\star$"},{"location":"golang/0201-0300/0261-0270/#269-alien-dictionary-starstarstar","text":"","title":"269. Alien Dictionary $\\star\\star\\star$"},{"location":"golang/0201-0300/0261-0270/#270-closest-binary-search-tree-value-star","text":"","title":"270. Closest Binary Search Tree Value $\\star$"},{"location":"golang/0201-0300/0271-0280/","text":"271. Encode and Decode Strings $\\star\\star$ 272. Closest Binary Search Tree Value II $\\star\\star\\star$ 273. Integer to English Words $\\star\\star\\star$ 274. H-Index $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int hIndex ( vector < int >& citations ) { sort ( citations . begin (), citations . end ()); for ( int i = 0 ; i < citations . size (); ++ i ) if ( citations [ i ] >= citations . size () - i ) return citations . size () - i ; return 0 ; } }; 275. H-Index II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int hIndex ( vector < int >& citations ) { int l = 0 ; int r = citations . size () - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( citations [ m ] == citations . size () - m ) return citations [ m ]; else if ( citations [ m ] > citations . size () - m ) r = m - 1 ; else l = m + 1 ; } return citations . size () - ( r + 1 ); } }; 276. Paint Fence $\\star$ 277. Find the Celebrity $\\star\\star$ 278. First Bad Version $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool isBadVersion ( int version ); class Solution { public : int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } }; 279. Perfect Squares $\\star\\star$ 280. Wiggle Sort $\\star\\star$","title":"0271-0280"},{"location":"golang/0201-0300/0271-0280/#271-encode-and-decode-strings-starstar","text":"","title":"271. Encode and Decode Strings $\\star\\star$"},{"location":"golang/0201-0300/0271-0280/#272-closest-binary-search-tree-value-ii-starstarstar","text":"","title":"272. Closest Binary Search Tree Value II $\\star\\star\\star$"},{"location":"golang/0201-0300/0271-0280/#273-integer-to-english-words-starstarstar","text":"","title":"273. Integer to English Words $\\star\\star\\star$"},{"location":"golang/0201-0300/0271-0280/#274-h-index-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int hIndex ( vector < int >& citations ) { sort ( citations . begin (), citations . end ()); for ( int i = 0 ; i < citations . size (); ++ i ) if ( citations [ i ] >= citations . size () - i ) return citations . size () - i ; return 0 ; } };","title":"274. H-Index $\\star\\star$"},{"location":"golang/0201-0300/0271-0280/#275-h-index-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int hIndex ( vector < int >& citations ) { int l = 0 ; int r = citations . size () - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( citations [ m ] == citations . size () - m ) return citations [ m ]; else if ( citations [ m ] > citations . size () - m ) r = m - 1 ; else l = m + 1 ; } return citations . size () - ( r + 1 ); } };","title":"275. H-Index II $\\star\\star$"},{"location":"golang/0201-0300/0271-0280/#276-paint-fence-star","text":"","title":"276. Paint Fence $\\star$"},{"location":"golang/0201-0300/0271-0280/#277-find-the-celebrity-starstar","text":"","title":"277. Find the Celebrity $\\star\\star$"},{"location":"golang/0201-0300/0271-0280/#278-first-bad-version-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool isBadVersion ( int version ); class Solution { public : int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } };","title":"278. First Bad Version $\\star$"},{"location":"golang/0201-0300/0271-0280/#279-perfect-squares-starstar","text":"","title":"279. Perfect Squares $\\star\\star$"},{"location":"golang/0201-0300/0271-0280/#280-wiggle-sort-starstar","text":"","title":"280. Wiggle Sort $\\star\\star$"},{"location":"golang/0201-0300/0281-0290/","text":"281. Zigzag Iterator $\\star\\star$ 282. Expression Add Operators $\\star\\star\\star$ 283. Move Zeroes $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : void moveZeroes ( vector < int >& nums ) { int j = 0 ; for ( int num : nums ) if ( num != 0 ) nums [ j ++ ] = num ; for ( int i = j ; i < nums . size (); ++ i ) nums [ i ] = 0 ; } }; 284. Peeking Iterator $\\star\\star$ 285. Inorder Successor in BST $\\star\\star$ 286. Walls and Gates $\\star\\star$ 287. Find the Duplicate Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findDuplicate ( vector < int >& nums ) { int slow = nums [ nums [ 0 ]]; int fast = nums [ nums [ nums [ 0 ]]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } slow = nums [ 0 ]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } }; 288. Unique Word Abbreviation $\\star\\star$ 289. Game of Life $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) ones += board [ y ][ x ] & 1 ; if (( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) || ( board [ i ][ j ] == 0 && ones == 3 )) board [ i ][ j ] |= 0 b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] >>= 1 ; } }; 290. Word Pattern $\\star$","title":"0281-0290"},{"location":"golang/0201-0300/0281-0290/#281-zigzag-iterator-starstar","text":"","title":"281. Zigzag Iterator $\\star\\star$"},{"location":"golang/0201-0300/0281-0290/#282-expression-add-operators-starstarstar","text":"","title":"282. Expression Add Operators $\\star\\star\\star$"},{"location":"golang/0201-0300/0281-0290/#283-move-zeroes-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : void moveZeroes ( vector < int >& nums ) { int j = 0 ; for ( int num : nums ) if ( num != 0 ) nums [ j ++ ] = num ; for ( int i = j ; i < nums . size (); ++ i ) nums [ i ] = 0 ; } };","title":"283. Move Zeroes $\\star$"},{"location":"golang/0201-0300/0281-0290/#284-peeking-iterator-starstar","text":"","title":"284. Peeking Iterator $\\star\\star$"},{"location":"golang/0201-0300/0281-0290/#285-inorder-successor-in-bst-starstar","text":"","title":"285. Inorder Successor in BST $\\star\\star$"},{"location":"golang/0201-0300/0281-0290/#286-walls-and-gates-starstar","text":"","title":"286. Walls and Gates $\\star\\star$"},{"location":"golang/0201-0300/0281-0290/#287-find-the-duplicate-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findDuplicate ( vector < int >& nums ) { int slow = nums [ nums [ 0 ]]; int fast = nums [ nums [ nums [ 0 ]]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } slow = nums [ 0 ]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } };","title":"287. Find the Duplicate Number $\\star\\star$"},{"location":"golang/0201-0300/0281-0290/#288-unique-word-abbreviation-starstar","text":"","title":"288. Unique Word Abbreviation $\\star\\star$"},{"location":"golang/0201-0300/0281-0290/#289-game-of-life-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) ones += board [ y ][ x ] & 1 ; if (( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) || ( board [ i ][ j ] == 0 && ones == 3 )) board [ i ][ j ] |= 0 b10 ; } for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) board [ i ][ j ] >>= 1 ; } };","title":"289. Game of Life $\\star\\star$"},{"location":"golang/0201-0300/0281-0290/#290-word-pattern-star","text":"","title":"290. Word Pattern $\\star$"},{"location":"golang/0201-0300/0291-0300/","text":"291. Word Pattern II $\\star\\star\\star$ 292. Nim Game $\\star$ 293. Flip Game $\\star$ 294. Flip Game II $\\star\\star$ 295. Find Median from Data Stream $\\star\\star\\star$ 296. Best Meeting Point $\\star\\star\\star$ 297. Serialize and Deserialize Binary Tree $\\star\\star\\star$ 298. Binary Tree Longest Consecutive Sequence $\\star\\star$ 299. Bulls and Cows $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getHint ( string secans , string guess ) { int A = 0 ; int B = 0 ; map < char , int > map1 ; map < char , int > map2 ; for ( int i = 0 ; i < secans . length (); ++ i ) { if ( secans [ i ] == guess [ i ]) ++ A ; else { ++ map1 [ secans [ i ]]; ++ map2 [ guess [ i ]]; } } for ( int i = 0 ; i <= 9 ; ++ i ) B += min ( map1 [ '0' + i ], map2 [ '0' + i ]); return to_string ( A ) + \"A\" + to_string ( B ) + \"B\" ; } }; 300. Longest Increasing Subsequence $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 func lengthOfLIS ( nums [] int ) int { // return func1 ( nums ); // return func2 ( nums ); return func3 ( nums ); } // ** sort + LCS func func1 ( nums [] int ) int { if len ( nums ) <= 0 { return 0 ; } sorted : = make ( [] int , len ( nums )); for i : = 0 ; i < len ( nums ); i ++ { sorted [ i ] = nums [ i ] ; } sort . Ints ( sorted ); unique : = make ( [] int , 1 , len ( nums )); unique [ 0 ] = sorted [ 0 ] ; for i : = 1 ; i < len ( sorted ); i ++ { if sorted [ i ] != unique [ len(unique)-1 ] { unique = append ( unique , sorted [ i ] ); } } return lengthOfLCS ( unique , nums ); } func lengthOfLCS ( nums1 [] int , nums2 [] int ) int { m : = len ( nums1 ); n : = len ( nums2 ); ret : = 0 ; memo : = make ( [][] int , m + 1 ); for i : = 0 ; i < m + 1 ; i ++ { memo [ i ] = make ( [] int , n + 1 ); } for i : = 0 ; i < m ; i ++ { for j : = 0 ; j < n ; j ++ { if nums1 [ i ] == nums2 [ j ] { memo [ i+1 ][ j+1 ] = memo [ i ][ j ] + 1 ; } else { memo [ i+1 ][ j+1 ] = max ( memo [ i ][ j+1 ] , memo [ i+1 ][ j ] ); } ret = max ( ret , memo [ i+1 ][ j+1 ] ) } } return ret ; } func max ( a int , b int ) int { if a > b { return a ; } else { return b ; } } // ** standard dp func func2 ( nums [] int ) int { n : = len ( nums ); memo : = make ( [] int , n ); for i : = 0 ; i < n ; i ++ { memo [ i ] = 1 ; } ret : = 0 ; for i : = n - 1 ; i >= 0 ; i -- { for j : = i + 1 ; j < n ; j ++ { if nums [ i ] < nums [ j ] { memo [ i ] = max ( memo [ i ] , memo [ j ] + 1 ); } } ret = max ( ret , memo [ i ] ); } return ret ; } // ** O ( nlogn ) binary - search solution , interesting func func3 ( nums [] int ) int { n : = len ( nums ); arr : = make ( [] int , 0 ); for i : = n - 1 ; i >= 0 ; i -- { idx : = findLargestLessOrEqualThanTarget ( arr , nums [ i ] ); if idx >= len ( arr ) { arr = append ( arr , nums [ i ] ) } else { arr [ idx ] = nums [ i ] ; } } return len ( arr ); } /* * nums is inverted order and return the index that nums[index] is the * largest element <= target * eg: [19,18,17,16,10], find target | nums[lo] | nums[hi] | ret: * 20 | nums[0]=19 | nums[-1]= | 0 * 19 | nums[0]=19 | nums[0]=19 | 0 * 12 | nums[4]=10 | nums[3]=16 | 4 * 09 | nums[5]= | nums[4]=10 | 5 */ func findLargestLessOrEqualThanTarget ( nums [] int , target int ) int { lo : = 0 ; hi : = len ( nums ) - 1 ; for ( lo <= hi ) { mid : = ( lo + hi ) / 2 ; if nums [ mid ] == target { return mid ; } else if nums [ mid ] > target { lo = mid + 1 ; } else { hi = mid - 1 ; } } return lo ; }","title":"0291-0300"},{"location":"golang/0201-0300/0291-0300/#291-word-pattern-ii-starstarstar","text":"","title":"291. Word Pattern II $\\star\\star\\star$"},{"location":"golang/0201-0300/0291-0300/#292-nim-game-star","text":"","title":"292. Nim Game $\\star$"},{"location":"golang/0201-0300/0291-0300/#293-flip-game-star","text":"","title":"293. Flip Game $\\star$"},{"location":"golang/0201-0300/0291-0300/#294-flip-game-ii-starstar","text":"","title":"294. Flip Game II $\\star\\star$"},{"location":"golang/0201-0300/0291-0300/#295-find-median-from-data-stream-starstarstar","text":"","title":"295. Find Median from Data Stream $\\star\\star\\star$"},{"location":"golang/0201-0300/0291-0300/#296-best-meeting-point-starstarstar","text":"","title":"296. Best Meeting Point $\\star\\star\\star$"},{"location":"golang/0201-0300/0291-0300/#297-serialize-and-deserialize-binary-tree-starstarstar","text":"","title":"297. Serialize and Deserialize Binary Tree $\\star\\star\\star$"},{"location":"golang/0201-0300/0291-0300/#298-binary-tree-longest-consecutive-sequence-starstar","text":"","title":"298. Binary Tree Longest Consecutive Sequence $\\star\\star$"},{"location":"golang/0201-0300/0291-0300/#299-bulls-and-cows-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getHint ( string secans , string guess ) { int A = 0 ; int B = 0 ; map < char , int > map1 ; map < char , int > map2 ; for ( int i = 0 ; i < secans . length (); ++ i ) { if ( secans [ i ] == guess [ i ]) ++ A ; else { ++ map1 [ secans [ i ]]; ++ map2 [ guess [ i ]]; } } for ( int i = 0 ; i <= 9 ; ++ i ) B += min ( map1 [ '0' + i ], map2 [ '0' + i ]); return to_string ( A ) + \"A\" + to_string ( B ) + \"B\" ; } };","title":"299. Bulls and Cows $\\star$"},{"location":"golang/0201-0300/0291-0300/#300-longest-increasing-subsequence-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 func lengthOfLIS ( nums [] int ) int { // return func1 ( nums ); // return func2 ( nums ); return func3 ( nums ); } // ** sort + LCS func func1 ( nums [] int ) int { if len ( nums ) <= 0 { return 0 ; } sorted : = make ( [] int , len ( nums )); for i : = 0 ; i < len ( nums ); i ++ { sorted [ i ] = nums [ i ] ; } sort . Ints ( sorted ); unique : = make ( [] int , 1 , len ( nums )); unique [ 0 ] = sorted [ 0 ] ; for i : = 1 ; i < len ( sorted ); i ++ { if sorted [ i ] != unique [ len(unique)-1 ] { unique = append ( unique , sorted [ i ] ); } } return lengthOfLCS ( unique , nums ); } func lengthOfLCS ( nums1 [] int , nums2 [] int ) int { m : = len ( nums1 ); n : = len ( nums2 ); ret : = 0 ; memo : = make ( [][] int , m + 1 ); for i : = 0 ; i < m + 1 ; i ++ { memo [ i ] = make ( [] int , n + 1 ); } for i : = 0 ; i < m ; i ++ { for j : = 0 ; j < n ; j ++ { if nums1 [ i ] == nums2 [ j ] { memo [ i+1 ][ j+1 ] = memo [ i ][ j ] + 1 ; } else { memo [ i+1 ][ j+1 ] = max ( memo [ i ][ j+1 ] , memo [ i+1 ][ j ] ); } ret = max ( ret , memo [ i+1 ][ j+1 ] ) } } return ret ; } func max ( a int , b int ) int { if a > b { return a ; } else { return b ; } } // ** standard dp func func2 ( nums [] int ) int { n : = len ( nums ); memo : = make ( [] int , n ); for i : = 0 ; i < n ; i ++ { memo [ i ] = 1 ; } ret : = 0 ; for i : = n - 1 ; i >= 0 ; i -- { for j : = i + 1 ; j < n ; j ++ { if nums [ i ] < nums [ j ] { memo [ i ] = max ( memo [ i ] , memo [ j ] + 1 ); } } ret = max ( ret , memo [ i ] ); } return ret ; } // ** O ( nlogn ) binary - search solution , interesting func func3 ( nums [] int ) int { n : = len ( nums ); arr : = make ( [] int , 0 ); for i : = n - 1 ; i >= 0 ; i -- { idx : = findLargestLessOrEqualThanTarget ( arr , nums [ i ] ); if idx >= len ( arr ) { arr = append ( arr , nums [ i ] ) } else { arr [ idx ] = nums [ i ] ; } } return len ( arr ); } /* * nums is inverted order and return the index that nums[index] is the * largest element <= target * eg: [19,18,17,16,10], find target | nums[lo] | nums[hi] | ret: * 20 | nums[0]=19 | nums[-1]= | 0 * 19 | nums[0]=19 | nums[0]=19 | 0 * 12 | nums[4]=10 | nums[3]=16 | 4 * 09 | nums[5]= | nums[4]=10 | 5 */ func findLargestLessOrEqualThanTarget ( nums [] int , target int ) int { lo : = 0 ; hi : = len ( nums ) - 1 ; for ( lo <= hi ) { mid : = ( lo + hi ) / 2 ; if nums [ mid ] == target { return mid ; } else if nums [ mid ] > target { lo = mid + 1 ; } else { hi = mid - 1 ; } } return lo ; }","title":"300. Longest Increasing Subsequence $\\star\\star$"},{"location":"golang/0301-0400/0301-0310/","text":"301. Remove Invalid Parentheses $\\star\\star\\star$ 302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$ 303. Range Sum Query - Immutable $\\star$ 304. Range Sum Query 2D - Immutable $\\star\\star$ 305. Number of Islands II $\\star\\star\\star$ 306. Additive Number $\\star\\star$ 307. Range Sum Query - Mutable $\\star\\star$ 308. Range Sum Query 2D - Mutable $\\star\\star\\star$ 309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; int prev = 0 ; for ( int price : prices ) { int cache = sell ; sell = max ( sell , hold + price ); hold = max ( hold , prev - price ); prev = cache ; } return sell ; } }; 310. Minimum Height Trees $\\star\\star$","title":"0301-0310"},{"location":"golang/0301-0400/0301-0310/#301-remove-invalid-parentheses-starstarstar","text":"","title":"301. Remove Invalid Parentheses $\\star\\star\\star$"},{"location":"golang/0301-0400/0301-0310/#302-smallest-rectangle-enclosing-black-pixels-starstarstar","text":"","title":"302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$"},{"location":"golang/0301-0400/0301-0310/#303-range-sum-query-immutable-star","text":"","title":"303. Range Sum Query - Immutable $\\star$"},{"location":"golang/0301-0400/0301-0310/#304-range-sum-query-2d-immutable-starstar","text":"","title":"304. Range Sum Query 2D - Immutable $\\star\\star$"},{"location":"golang/0301-0400/0301-0310/#305-number-of-islands-ii-starstarstar","text":"","title":"305. Number of Islands II $\\star\\star\\star$"},{"location":"golang/0301-0400/0301-0310/#306-additive-number-starstar","text":"","title":"306. Additive Number $\\star\\star$"},{"location":"golang/0301-0400/0301-0310/#307-range-sum-query-mutable-starstar","text":"","title":"307. Range Sum Query - Mutable $\\star\\star$"},{"location":"golang/0301-0400/0301-0310/#308-range-sum-query-2d-mutable-starstarstar","text":"","title":"308. Range Sum Query 2D - Mutable $\\star\\star\\star$"},{"location":"golang/0301-0400/0301-0310/#309-best-time-to-buy-and-sell-stock-with-cooldown-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; int prev = 0 ; for ( int price : prices ) { int cache = sell ; sell = max ( sell , hold + price ); hold = max ( hold , prev - price ); prev = cache ; } return sell ; } };","title":"309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$"},{"location":"golang/0301-0400/0301-0310/#310-minimum-height-trees-starstar","text":"","title":"310. Minimum Height Trees $\\star\\star$"},{"location":"golang/0301-0400/0311-0320/","text":"311. Sparse Matrix Multiplication $\\star\\star$ 312. Burst Balloons $\\star\\star\\star$ 313. Super Ugly Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { const int k = primes . size (); vector < int > nums { 1 }; vector < int > indices ( k ); while ( nums . size () < n ) { vector < int > nexts ( k ); for ( int i = 0 ; i < k ; ++ i ) nexts [ i ] = nums [ indices [ i ]] * primes [ i ]; int next = accumulate ( nexts . begin (), nexts . end (), INT_MAX , []( int a , int b ) { return min ( a , b ); }); for ( int i = 0 ; i < k ; ++ i ) if ( next == nexts [ i ]) ++ indices [ i ]; nums . push_back ( next ); } return nums . back (); } }; 314. Binary Tree Vertical Order Traversal $\\star\\star$ 315. Count of Smaller Numbers After Self $\\star\\star\\star$ 316. Remove Duplicate Letters $\\star\\star\\star$ 317. Shortest Distance from All Buildings $\\star\\star\\star$ 318. Maximum Product of Word Lengths $\\star\\star$ 319. Bulb Switcher $\\star\\star$ 1 2 3 4 class Solution { public : int bulbSwitch ( int n ) { return sqrt ( n ); } }; 320. Generalized Abbreviation $\\star\\star$","title":"0311-0320"},{"location":"golang/0301-0400/0311-0320/#311-sparse-matrix-multiplication-starstar","text":"","title":"311. Sparse Matrix Multiplication $\\star\\star$"},{"location":"golang/0301-0400/0311-0320/#312-burst-balloons-starstarstar","text":"","title":"312. Burst Balloons $\\star\\star\\star$"},{"location":"golang/0301-0400/0311-0320/#313-super-ugly-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { const int k = primes . size (); vector < int > nums { 1 }; vector < int > indices ( k ); while ( nums . size () < n ) { vector < int > nexts ( k ); for ( int i = 0 ; i < k ; ++ i ) nexts [ i ] = nums [ indices [ i ]] * primes [ i ]; int next = accumulate ( nexts . begin (), nexts . end (), INT_MAX , []( int a , int b ) { return min ( a , b ); }); for ( int i = 0 ; i < k ; ++ i ) if ( next == nexts [ i ]) ++ indices [ i ]; nums . push_back ( next ); } return nums . back (); } };","title":"313. Super Ugly Number $\\star\\star$"},{"location":"golang/0301-0400/0311-0320/#314-binary-tree-vertical-order-traversal-starstar","text":"","title":"314. Binary Tree Vertical Order Traversal $\\star\\star$"},{"location":"golang/0301-0400/0311-0320/#315-count-of-smaller-numbers-after-self-starstarstar","text":"","title":"315. Count of Smaller Numbers After Self $\\star\\star\\star$"},{"location":"golang/0301-0400/0311-0320/#316-remove-duplicate-letters-starstarstar","text":"","title":"316. Remove Duplicate Letters $\\star\\star\\star$"},{"location":"golang/0301-0400/0311-0320/#317-shortest-distance-from-all-buildings-starstarstar","text":"","title":"317. Shortest Distance from All Buildings $\\star\\star\\star$"},{"location":"golang/0301-0400/0311-0320/#318-maximum-product-of-word-lengths-starstar","text":"","title":"318. Maximum Product of Word Lengths $\\star\\star$"},{"location":"golang/0301-0400/0311-0320/#319-bulb-switcher-starstar","text":"1 2 3 4 class Solution { public : int bulbSwitch ( int n ) { return sqrt ( n ); } };","title":"319. Bulb Switcher $\\star\\star$"},{"location":"golang/0301-0400/0311-0320/#320-generalized-abbreviation-starstar","text":"","title":"320. Generalized Abbreviation $\\star\\star$"},{"location":"golang/0301-0400/0321-0330/","text":"321. Create Maximum Number $\\star\\star\\star$ 322. Coin Change $\\star\\star$ \u6807\u51c6DP\u7684\u65b9\u6cd5\uff0c\u65e0\u6cd5bottom-top\u8fed\u4ee3 \u5b8c\u5168\u80cc\u5305\u95ee\u9898\uff0ctrick\u7684\u70b9\u5728\u4e8e \u4ece 0...V \u8fed\u4ee3\u800c\u4e0d\u662f coins[i-1]...V \uff0c\u56e0\u4e3a\u5728\u9762\u5bf9\u7269\u54c1 coins[i-1] \u65f6\uff0c\u5373\u4f7f\u80cc\u5305\u5927\u5c0f\u653e\u4e0d\u4e0b\u5b83\uff0c\u4e5f\u8981\u540c\u6b65\u66f4\u65b0 0...coins[i-1]-1 \u7684\u72b6\u6001\uff0c\u4e0d\u5e94\u8be5\u8fd8\u662f\u521d\u59cb\u503c\u4e86(-1or\u4e4b\u540e\u7684amount+1) \u521d\u59cb\u503c\u4e0d\u8981\u7528-1\uff0c\u4f1a\u5bfc\u81f4\u4ee3\u7801\u5f88\u5570\u55e6\uff0c\u4f7f\u7528 amount+1 \u5373\uff0c\u6700\u7cdf\u7cd5\u7684\u60c5\u51b5\u4e0b\uff0c\u5047\u8bbe\u67091\u5927\u5c0f\u7684\u7269\u54c1\uff0c\u6700\u591a\u4e5f\u5c31\u653eamount\u6b21\uff0camount+1\u4e00\u5b9a\u65f6\u6700\u5927\u7684\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 func coinChange ( coins [] int , amount int ) int { // return func1 ( coins , amount ); // return func2 ( coins , amount ); // return completeKnapsack4 ( coins , amount ); // return completeKnapsack5 ( coins , amount ); return completeKnapsack6 ( coins , amount ); } // 1. Basic , Time Limit Exceeded func func1 ( coins [] int , amount int ) int { if amount == 0 { return 0 ; } ret : = - 1 ; for _ , coin : = range coins { if coin == amount { return 1 ; } if coin < amount { tmp : = func1 ( coins , amount - coin ); if tmp != - 1 { if ret == - 1 { ret = 1 + tmp ; } else if ret > tmp + 1 { ret = tmp + 1 ; } } } } return ret ; } // 2. Top - down memo , Time Limit Exceeded func func2 ( coins [] int , amount int ) int { memo : = make ( map [ int ] int ); return helper2 ( coins , amount , memo ); } func helper2 ( coins [] int , amount int , memo map [ int ] int ) int { if amount == 0 { return 0 ; } if val , ok : = memo [ amount ] ; ok { return val ; } ret : = - 1 ; for _ , coin : = range coins { if coin == amount { ret = 1 ; break ; } if coin < amount { tmp : = helper2 ( coins , amount - coin , memo ); if tmp != - 1 { if ret == - 1 { ret = 1 + tmp ; } else if ret > tmp + 1 { ret = tmp + 1 ; } } } } memo [ amount ] = ret ; return memo [ amount ] ; } // 3. Bottom - up ?? // 4. Complete knapsack , 2 D array , - 1 as failed condition => complex checking func completeKnapsack4 ( coins [] int , amount int ) int { if amount == 0 { return 0 ; } N : = len ( coins ); V : = amount ; pack : = make ( [][] int , N + 1 ); for i : = 0 ; i < N + 1 ; i ++ { pack [ i ] = make ( [] int , V + 1 ); for j : = 0 ; j < V + 1 ; j ++ { pack [ i ][ j ] = - 1 ; } } for i : = 0 ; i < N + 1 ; i ++ { pack [ i ][ 0 ] = 0 ; } for i : = 1 ; i <= N ; i ++ { for v : = 0 ; v <= V ; v ++ { if pack [ i-1 ][ v ] != - 1 { pack [ i ][ v ] = pack [ i-1 ][ v ] ; } if v >= coins [ i-1 ] && pack [ i ][ v-coins[i-1 ] ] != - 1 { if pack [ i ][ v ] == - 1 { pack [ i ][ v ] = pack [ i ][ v-coins[i-1 ] ] + 1 ; } else { pack [ i ][ v ] = min ( pack [ i ][ v ] , pack [ i ][ v-coins[i-1 ] ] + 1 ); } } } } ret : = - 1 ; for i : = 1 ; i <= N ; i ++ { if pack [ i ][ V ] != - 1 { if ret == - 1 { ret = pack [ i ][ V ] ; } else { ret = min ( ret , pack [ i ][ V ] ); } } } return ret ; } // 5. Complete knapsack , 2 D array , amount + 1 as failed condition => simple checking // !!! Key Point , set ret = amount + 1 , // because max number of operations is put 1 into package with amount time func completeKnapsack5 ( coins [] int , amount int ) int { if amount == 0 { return 0 ; } N : = len ( coins ); V : = amount ; pack : = make ( [][] int , N + 1 ); for i : = 0 ; i < N + 1 ; i ++ { pack [ i ] = make ( [] int , V + 1 ); for j : = 0 ; j < V + 1 ; j ++ { pack [ i ][ j ] = amount + 1 ; } } for i : = 0 ; i < N + 1 ; i ++ { pack [ i ][ 0 ] = 0 ; } for i : = 1 ; i <= N ; i ++ { for v : = 0 ; v <= V ; v ++ { pack [ i ][ v ] = pack [ i-1 ][ v ] ; if v >= coins [ i-1 ] { pack [ i ][ v ] = min ( pack [ i ][ v ] , pack [ i ][ v-coins[i-1 ] ] + 1 ); } } } ret : = amount + 1 ; for i : = 1 ; i <= N ; i ++ { ret = min ( ret , pack [ i ][ V ] ); } if ret == amount + 1 { return - 1 ; } return ret ; } // 6. Complete knapsack , 1 D array func completeKnapsack6 ( coins [] int , amount int ) int { if amount == 0 { return 0 ; } N : = len ( coins ); V : = amount ; pack : = make ( [] int , V + 1 ); for i : = 1 ; i < V + 1 ; i ++ { pack [ i ] = amount + 1 ; } for i : = 1 ; i <= N ; i ++ { for v : = 0 ; v <= V ; v ++ { if v >= coins [ i-1 ] { pack [ v ] = min ( pack [ v ] , pack [ v-coins[i-1 ] ] + 1 ); } } } if pack [ V ] == amount + 1 { return - 1 ; } return pack [ V ] ; } func min ( a int , b int ) int { if a < b { return a ; } return b ; } 323. Number of Connected Components in an Undirected Graph $\\star\\star$ 324. Wiggle Sort II $\\star\\star$ 325. Maximum Size Subarray Sum Equals k $\\star\\star$ 326. Power of Three $\\star$ 327. Count of Range Sum $\\star\\star\\star$ 328. Odd Even Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : ListNode * oddEvenList ( ListNode * head ) { if ( ! head ) return NULL ; ListNode dummyOdd ( 0 ); ListNode dummyEven ( 0 ); ListNode * prevOdd = & dummyOdd ; ListNode * prevEven = & dummyEven ; int index = 0 ; while ( head ) { auto next = head -> next ; head -> next = NULL ; if ( index ++ & 1 ) { prevEven -> next = head ; prevEven = head ; } else { prevOdd -> next = head ; prevOdd = head ; } head = next ; } prevOdd -> next = dummyEven . next ; return dummyOdd . next ; } }; 329. Longest Increasing Path in a Matrix $\\star\\star\\star$ 330. Patching Array $\\star\\star\\star$","title":"0321-0330"},{"location":"golang/0301-0400/0321-0330/#321-create-maximum-number-starstarstar","text":"","title":"321. Create Maximum Number $\\star\\star\\star$"},{"location":"golang/0301-0400/0321-0330/#322-coin-change-starstar","text":"\u6807\u51c6DP\u7684\u65b9\u6cd5\uff0c\u65e0\u6cd5bottom-top\u8fed\u4ee3 \u5b8c\u5168\u80cc\u5305\u95ee\u9898\uff0ctrick\u7684\u70b9\u5728\u4e8e \u4ece 0...V \u8fed\u4ee3\u800c\u4e0d\u662f coins[i-1]...V \uff0c\u56e0\u4e3a\u5728\u9762\u5bf9\u7269\u54c1 coins[i-1] \u65f6\uff0c\u5373\u4f7f\u80cc\u5305\u5927\u5c0f\u653e\u4e0d\u4e0b\u5b83\uff0c\u4e5f\u8981\u540c\u6b65\u66f4\u65b0 0...coins[i-1]-1 \u7684\u72b6\u6001\uff0c\u4e0d\u5e94\u8be5\u8fd8\u662f\u521d\u59cb\u503c\u4e86(-1or\u4e4b\u540e\u7684amount+1) \u521d\u59cb\u503c\u4e0d\u8981\u7528-1\uff0c\u4f1a\u5bfc\u81f4\u4ee3\u7801\u5f88\u5570\u55e6\uff0c\u4f7f\u7528 amount+1 \u5373\uff0c\u6700\u7cdf\u7cd5\u7684\u60c5\u51b5\u4e0b\uff0c\u5047\u8bbe\u67091\u5927\u5c0f\u7684\u7269\u54c1\uff0c\u6700\u591a\u4e5f\u5c31\u653eamount\u6b21\uff0camount+1\u4e00\u5b9a\u65f6\u6700\u5927\u7684\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 func coinChange ( coins [] int , amount int ) int { // return func1 ( coins , amount ); // return func2 ( coins , amount ); // return completeKnapsack4 ( coins , amount ); // return completeKnapsack5 ( coins , amount ); return completeKnapsack6 ( coins , amount ); } // 1. Basic , Time Limit Exceeded func func1 ( coins [] int , amount int ) int { if amount == 0 { return 0 ; } ret : = - 1 ; for _ , coin : = range coins { if coin == amount { return 1 ; } if coin < amount { tmp : = func1 ( coins , amount - coin ); if tmp != - 1 { if ret == - 1 { ret = 1 + tmp ; } else if ret > tmp + 1 { ret = tmp + 1 ; } } } } return ret ; } // 2. Top - down memo , Time Limit Exceeded func func2 ( coins [] int , amount int ) int { memo : = make ( map [ int ] int ); return helper2 ( coins , amount , memo ); } func helper2 ( coins [] int , amount int , memo map [ int ] int ) int { if amount == 0 { return 0 ; } if val , ok : = memo [ amount ] ; ok { return val ; } ret : = - 1 ; for _ , coin : = range coins { if coin == amount { ret = 1 ; break ; } if coin < amount { tmp : = helper2 ( coins , amount - coin , memo ); if tmp != - 1 { if ret == - 1 { ret = 1 + tmp ; } else if ret > tmp + 1 { ret = tmp + 1 ; } } } } memo [ amount ] = ret ; return memo [ amount ] ; } // 3. Bottom - up ?? // 4. Complete knapsack , 2 D array , - 1 as failed condition => complex checking func completeKnapsack4 ( coins [] int , amount int ) int { if amount == 0 { return 0 ; } N : = len ( coins ); V : = amount ; pack : = make ( [][] int , N + 1 ); for i : = 0 ; i < N + 1 ; i ++ { pack [ i ] = make ( [] int , V + 1 ); for j : = 0 ; j < V + 1 ; j ++ { pack [ i ][ j ] = - 1 ; } } for i : = 0 ; i < N + 1 ; i ++ { pack [ i ][ 0 ] = 0 ; } for i : = 1 ; i <= N ; i ++ { for v : = 0 ; v <= V ; v ++ { if pack [ i-1 ][ v ] != - 1 { pack [ i ][ v ] = pack [ i-1 ][ v ] ; } if v >= coins [ i-1 ] && pack [ i ][ v-coins[i-1 ] ] != - 1 { if pack [ i ][ v ] == - 1 { pack [ i ][ v ] = pack [ i ][ v-coins[i-1 ] ] + 1 ; } else { pack [ i ][ v ] = min ( pack [ i ][ v ] , pack [ i ][ v-coins[i-1 ] ] + 1 ); } } } } ret : = - 1 ; for i : = 1 ; i <= N ; i ++ { if pack [ i ][ V ] != - 1 { if ret == - 1 { ret = pack [ i ][ V ] ; } else { ret = min ( ret , pack [ i ][ V ] ); } } } return ret ; } // 5. Complete knapsack , 2 D array , amount + 1 as failed condition => simple checking // !!! Key Point , set ret = amount + 1 , // because max number of operations is put 1 into package with amount time func completeKnapsack5 ( coins [] int , amount int ) int { if amount == 0 { return 0 ; } N : = len ( coins ); V : = amount ; pack : = make ( [][] int , N + 1 ); for i : = 0 ; i < N + 1 ; i ++ { pack [ i ] = make ( [] int , V + 1 ); for j : = 0 ; j < V + 1 ; j ++ { pack [ i ][ j ] = amount + 1 ; } } for i : = 0 ; i < N + 1 ; i ++ { pack [ i ][ 0 ] = 0 ; } for i : = 1 ; i <= N ; i ++ { for v : = 0 ; v <= V ; v ++ { pack [ i ][ v ] = pack [ i-1 ][ v ] ; if v >= coins [ i-1 ] { pack [ i ][ v ] = min ( pack [ i ][ v ] , pack [ i ][ v-coins[i-1 ] ] + 1 ); } } } ret : = amount + 1 ; for i : = 1 ; i <= N ; i ++ { ret = min ( ret , pack [ i ][ V ] ); } if ret == amount + 1 { return - 1 ; } return ret ; } // 6. Complete knapsack , 1 D array func completeKnapsack6 ( coins [] int , amount int ) int { if amount == 0 { return 0 ; } N : = len ( coins ); V : = amount ; pack : = make ( [] int , V + 1 ); for i : = 1 ; i < V + 1 ; i ++ { pack [ i ] = amount + 1 ; } for i : = 1 ; i <= N ; i ++ { for v : = 0 ; v <= V ; v ++ { if v >= coins [ i-1 ] { pack [ v ] = min ( pack [ v ] , pack [ v-coins[i-1 ] ] + 1 ); } } } if pack [ V ] == amount + 1 { return - 1 ; } return pack [ V ] ; } func min ( a int , b int ) int { if a < b { return a ; } return b ; }","title":"322. Coin Change $\\star\\star$"},{"location":"golang/0301-0400/0321-0330/#323-number-of-connected-components-in-an-undirected-graph-starstar","text":"","title":"323. Number of Connected Components in an Undirected Graph $\\star\\star$"},{"location":"golang/0301-0400/0321-0330/#324-wiggle-sort-ii-starstar","text":"","title":"324. Wiggle Sort II $\\star\\star$"},{"location":"golang/0301-0400/0321-0330/#325-maximum-size-subarray-sum-equals-k-starstar","text":"","title":"325. Maximum Size Subarray Sum Equals k $\\star\\star$"},{"location":"golang/0301-0400/0321-0330/#326-power-of-three-star","text":"","title":"326. Power of Three $\\star$"},{"location":"golang/0301-0400/0321-0330/#327-count-of-range-sum-starstarstar","text":"","title":"327. Count of Range Sum $\\star\\star\\star$"},{"location":"golang/0301-0400/0321-0330/#328-odd-even-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : ListNode * oddEvenList ( ListNode * head ) { if ( ! head ) return NULL ; ListNode dummyOdd ( 0 ); ListNode dummyEven ( 0 ); ListNode * prevOdd = & dummyOdd ; ListNode * prevEven = & dummyEven ; int index = 0 ; while ( head ) { auto next = head -> next ; head -> next = NULL ; if ( index ++ & 1 ) { prevEven -> next = head ; prevEven = head ; } else { prevOdd -> next = head ; prevOdd = head ; } head = next ; } prevOdd -> next = dummyEven . next ; return dummyOdd . next ; } };","title":"328. Odd Even Linked List $\\star\\star$"},{"location":"golang/0301-0400/0321-0330/#329-longest-increasing-path-in-a-matrix-starstarstar","text":"","title":"329. Longest Increasing Path in a Matrix $\\star\\star\\star$"},{"location":"golang/0301-0400/0321-0330/#330-patching-array-starstarstar","text":"","title":"330. Patching Array $\\star\\star\\star$"},{"location":"golang/0301-0400/0331-0340/","text":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$ 332. Reconstruct Itinerary $\\star\\star$ 333. Largest BST Subtree $\\star\\star$ 334. Increasing Triplet Subsequence $\\star\\star$ 335. Self Crossing $\\star\\star\\star$ 336. Palindrome Pairs $\\star\\star\\star$ 337. House Robber III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int rob ( TreeNode * root ) { vector < int > ans = helper ( root ); return max ( ans [ 0 ], ans [ 1 ]); } vector < int > helper ( TreeNode * root ) { if ( ! root ) return { 0 , 0 }; vector < int > left = helper ( root -> left ); vector < int > right = helper ( root -> right ); return { max ( left [ 0 ], left [ 1 ]) + max ( right [ 0 ], right [ 1 ]), root -> val + left [ 0 ] + right [ 0 ]}; } }; 338. Counting Bits $\\star\\star$ 339. Nested List Weight Sum $\\star$ 340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$","title":"0331-0340"},{"location":"golang/0301-0400/0331-0340/#331-verify-preorder-serialization-of-a-binary-tree-starstar","text":"","title":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$"},{"location":"golang/0301-0400/0331-0340/#332-reconstruct-itinerary-starstar","text":"","title":"332. Reconstruct Itinerary $\\star\\star$"},{"location":"golang/0301-0400/0331-0340/#333-largest-bst-subtree-starstar","text":"","title":"333. Largest BST Subtree $\\star\\star$"},{"location":"golang/0301-0400/0331-0340/#334-increasing-triplet-subsequence-starstar","text":"","title":"334. Increasing Triplet Subsequence $\\star\\star$"},{"location":"golang/0301-0400/0331-0340/#335-self-crossing-starstarstar","text":"","title":"335. Self Crossing $\\star\\star\\star$"},{"location":"golang/0301-0400/0331-0340/#336-palindrome-pairs-starstarstar","text":"","title":"336. Palindrome Pairs $\\star\\star\\star$"},{"location":"golang/0301-0400/0331-0340/#337-house-robber-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int rob ( TreeNode * root ) { vector < int > ans = helper ( root ); return max ( ans [ 0 ], ans [ 1 ]); } vector < int > helper ( TreeNode * root ) { if ( ! root ) return { 0 , 0 }; vector < int > left = helper ( root -> left ); vector < int > right = helper ( root -> right ); return { max ( left [ 0 ], left [ 1 ]) + max ( right [ 0 ], right [ 1 ]), root -> val + left [ 0 ] + right [ 0 ]}; } };","title":"337. House Robber III $\\star\\star$"},{"location":"golang/0301-0400/0331-0340/#338-counting-bits-starstar","text":"","title":"338. Counting Bits $\\star\\star$"},{"location":"golang/0301-0400/0331-0340/#339-nested-list-weight-sum-star","text":"","title":"339. Nested List Weight Sum $\\star$"},{"location":"golang/0301-0400/0331-0340/#340-longest-substring-with-at-most-k-distinct-characters-starstarstar","text":"","title":"340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$"},{"location":"golang/0301-0400/0341-0350/","text":"341. Flatten Nested List Iterator $\\star\\star$ 342. Power of Four $\\star$ 343. Integer Break $\\star\\star$ 344. Reverse String $\\star$ 345. Reverse Vowels of a String $\\star$ 346. Moving Average from Data Stream $\\star$ 347. Top K Frequent Elements $\\star\\star$ 348. Design Tic-Tac-Toe $\\star\\star$ 349. Intersection of Two Arrays $\\star$ 350. Intersection of Two Arrays II $\\star$","title":"0341-0350"},{"location":"golang/0301-0400/0341-0350/#341-flatten-nested-list-iterator-starstar","text":"","title":"341. Flatten Nested List Iterator $\\star\\star$"},{"location":"golang/0301-0400/0341-0350/#342-power-of-four-star","text":"","title":"342. Power of Four $\\star$"},{"location":"golang/0301-0400/0341-0350/#343-integer-break-starstar","text":"","title":"343. Integer Break $\\star\\star$"},{"location":"golang/0301-0400/0341-0350/#344-reverse-string-star","text":"","title":"344. Reverse String $\\star$"},{"location":"golang/0301-0400/0341-0350/#345-reverse-vowels-of-a-string-star","text":"","title":"345. Reverse Vowels of a String $\\star$"},{"location":"golang/0301-0400/0341-0350/#346-moving-average-from-data-stream-star","text":"","title":"346. Moving Average from Data Stream $\\star$"},{"location":"golang/0301-0400/0341-0350/#347-top-k-frequent-elements-starstar","text":"","title":"347. Top K Frequent Elements $\\star\\star$"},{"location":"golang/0301-0400/0341-0350/#348-design-tic-tac-toe-starstar","text":"","title":"348. Design Tic-Tac-Toe $\\star\\star$"},{"location":"golang/0301-0400/0341-0350/#349-intersection-of-two-arrays-star","text":"","title":"349. Intersection of Two Arrays $\\star$"},{"location":"golang/0301-0400/0341-0350/#350-intersection-of-two-arrays-ii-star","text":"","title":"350. Intersection of Two Arrays II $\\star$"},{"location":"golang/0301-0400/0351-0360/","text":"351. Android Unlock Patterns $\\star\\star$ 352. Data Stream as Disjoint Intervals $\\star\\star\\star$ 353. Design Snake Game $\\star\\star$ 354. Russian Doll Envelopes $\\star\\star\\star$ 355. Design Twitter $\\star\\star$ 356. Line Reflection $\\star\\star$ 357. Count Numbers with Unique Digits $\\star\\star$ 358. Rearrange String k Distance Apart $\\star\\star\\star$ 359. Logger Rate Limiter $\\star$ 360. Sort Transformed Array $\\star\\star$","title":"0351-0360"},{"location":"golang/0301-0400/0351-0360/#351-android-unlock-patterns-starstar","text":"","title":"351. Android Unlock Patterns $\\star\\star$"},{"location":"golang/0301-0400/0351-0360/#352-data-stream-as-disjoint-intervals-starstarstar","text":"","title":"352. Data Stream as Disjoint Intervals $\\star\\star\\star$"},{"location":"golang/0301-0400/0351-0360/#353-design-snake-game-starstar","text":"","title":"353. Design Snake Game $\\star\\star$"},{"location":"golang/0301-0400/0351-0360/#354-russian-doll-envelopes-starstarstar","text":"","title":"354. Russian Doll Envelopes $\\star\\star\\star$"},{"location":"golang/0301-0400/0351-0360/#355-design-twitter-starstar","text":"","title":"355. Design Twitter $\\star\\star$"},{"location":"golang/0301-0400/0351-0360/#356-line-reflection-starstar","text":"","title":"356. Line Reflection $\\star\\star$"},{"location":"golang/0301-0400/0351-0360/#357-count-numbers-with-unique-digits-starstar","text":"","title":"357. Count Numbers with Unique Digits $\\star\\star$"},{"location":"golang/0301-0400/0351-0360/#358-rearrange-string-k-distance-apart-starstarstar","text":"","title":"358. Rearrange String k Distance Apart $\\star\\star\\star$"},{"location":"golang/0301-0400/0351-0360/#359-logger-rate-limiter-star","text":"","title":"359. Logger Rate Limiter $\\star$"},{"location":"golang/0301-0400/0351-0360/#360-sort-transformed-array-starstar","text":"","title":"360. Sort Transformed Array $\\star\\star$"},{"location":"golang/0301-0400/0361-0370/","text":"361. Bomb Enemy $\\star\\star$ 362. Design Hit Counter $\\star\\star$ 363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$ 364. Nested List Weight Sum II $\\star\\star$ 365. Water and Jug Problem $\\star\\star$ 366. Find Leaves of Binary Tree $\\star\\star$ 367. Valid Perfect Square $\\star$ 368. Largest Divisible Subset $\\star\\star$ 369. Plus One Linked List $\\star\\star$ 370. Range Addition $\\star\\star$","title":"0361-0370"},{"location":"golang/0301-0400/0361-0370/#361-bomb-enemy-starstar","text":"","title":"361. Bomb Enemy $\\star\\star$"},{"location":"golang/0301-0400/0361-0370/#362-design-hit-counter-starstar","text":"","title":"362. Design Hit Counter $\\star\\star$"},{"location":"golang/0301-0400/0361-0370/#363-max-sum-of-rectangle-no-larger-than-k-starstarstar","text":"","title":"363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$"},{"location":"golang/0301-0400/0361-0370/#364-nested-list-weight-sum-ii-starstar","text":"","title":"364. Nested List Weight Sum II $\\star\\star$"},{"location":"golang/0301-0400/0361-0370/#365-water-and-jug-problem-starstar","text":"","title":"365. Water and Jug Problem $\\star\\star$"},{"location":"golang/0301-0400/0361-0370/#366-find-leaves-of-binary-tree-starstar","text":"","title":"366. Find Leaves of Binary Tree $\\star\\star$"},{"location":"golang/0301-0400/0361-0370/#367-valid-perfect-square-star","text":"","title":"367. Valid Perfect Square $\\star$"},{"location":"golang/0301-0400/0361-0370/#368-largest-divisible-subset-starstar","text":"","title":"368. Largest Divisible Subset $\\star\\star$"},{"location":"golang/0301-0400/0361-0370/#369-plus-one-linked-list-starstar","text":"","title":"369. Plus One Linked List $\\star\\star$"},{"location":"golang/0301-0400/0361-0370/#370-range-addition-starstar","text":"","title":"370. Range Addition $\\star\\star$"},{"location":"golang/0301-0400/0371-0380/","text":"371. Sum of Two Integers $\\star$ 372. Super Pow $\\star\\star$ 373. Find K Pairs with Smallest Sums $\\star\\star$ 374. Guess Number Higher or Lower $\\star$ 375. Guess Number Higher or Lower II $\\star\\star$ 376. Wiggle Subsequence $\\star\\star$ 377. Combination Sum IV $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 func combinationSum4 ( nums [] int , target int ) int { // return func1 ( nums , target ); return func2 ( nums , target ); } // 1. complete - knapsack - problm // !! ERROR , Can ' t use CKP func func1 ( nums [] int , target int ) int { N : = len ( nums ); if N <= 0 || target < 0 { return 0 ; } pack : = make ( [] int , target + 1 ); pack [ 0 ] = 1 ; for i : = 0 ; i < N ; i ++ { for v : = 0 ; v <= target ; v ++ { if v >= nums [ i ] { pack [ v ] = max ( pack [ v ] , 1 + pack [ v-nums[i ] ] ); } } } return pack [ target ] ; } // 2. standard DP , dp [ n ] means combinations to n // O ( n ^ 2 ) time func func2 ( nums [] int , target int ) int { dp : = make ( [] int , target + 1 ); dp [ 0 ] = 1 ; for i : = 1 ; i <= target ; i ++ { for _ , n : = range nums { if i >= n { dp [ i ] += dp [ i-n ] ; } } } return dp [ target ] ; } func max ( a int , b int ) int { if a > b { return a ; } return b ; } 378. Kth Smallest Element in a Sorted Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { int l = matrix [ 0 ][ 0 ]; int r = matrix . back (). back (); while ( l < r ) { int m = ( l + r ) >> 1 ; int count = 0 ; for ( auto & row : matrix ) count += upper_bound ( row . begin (), row . end (), m ) - row . begin (); if ( count >= k ) r = m ; else l = m + 1 ; } return l ; } }; 379. Design Phone Directory $\\star\\star$ 380. Insert Delete GetRandom O(1) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class RandomizedSet { public : bool insert ( int val ) { if ( map . count ( val )) return false ; map [ val ] = vals . size (); vals . push_back ( val ); return true ; } bool remove ( int val ) { if ( ! map . count ( val )) return false ; int index = map [ val ]; map [ vals . back ()] = index ; map . erase ( val ); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]; } private : vector < int > vals ; unordered_map < int , int > map ; };","title":"0371-0380"},{"location":"golang/0301-0400/0371-0380/#371-sum-of-two-integers-star","text":"","title":"371. Sum of Two Integers $\\star$"},{"location":"golang/0301-0400/0371-0380/#372-super-pow-starstar","text":"","title":"372. Super Pow $\\star\\star$"},{"location":"golang/0301-0400/0371-0380/#373-find-k-pairs-with-smallest-sums-starstar","text":"","title":"373. Find K Pairs with Smallest Sums $\\star\\star$"},{"location":"golang/0301-0400/0371-0380/#374-guess-number-higher-or-lower-star","text":"","title":"374. Guess Number Higher or Lower $\\star$"},{"location":"golang/0301-0400/0371-0380/#375-guess-number-higher-or-lower-ii-starstar","text":"","title":"375. Guess Number Higher or Lower II $\\star\\star$"},{"location":"golang/0301-0400/0371-0380/#376-wiggle-subsequence-starstar","text":"","title":"376. Wiggle Subsequence $\\star\\star$"},{"location":"golang/0301-0400/0371-0380/#377-combination-sum-iv-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 func combinationSum4 ( nums [] int , target int ) int { // return func1 ( nums , target ); return func2 ( nums , target ); } // 1. complete - knapsack - problm // !! ERROR , Can ' t use CKP func func1 ( nums [] int , target int ) int { N : = len ( nums ); if N <= 0 || target < 0 { return 0 ; } pack : = make ( [] int , target + 1 ); pack [ 0 ] = 1 ; for i : = 0 ; i < N ; i ++ { for v : = 0 ; v <= target ; v ++ { if v >= nums [ i ] { pack [ v ] = max ( pack [ v ] , 1 + pack [ v-nums[i ] ] ); } } } return pack [ target ] ; } // 2. standard DP , dp [ n ] means combinations to n // O ( n ^ 2 ) time func func2 ( nums [] int , target int ) int { dp : = make ( [] int , target + 1 ); dp [ 0 ] = 1 ; for i : = 1 ; i <= target ; i ++ { for _ , n : = range nums { if i >= n { dp [ i ] += dp [ i-n ] ; } } } return dp [ target ] ; } func max ( a int , b int ) int { if a > b { return a ; } return b ; }","title":"377. Combination Sum IV $\\star\\star$"},{"location":"golang/0301-0400/0371-0380/#378-kth-smallest-element-in-a-sorted-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { int l = matrix [ 0 ][ 0 ]; int r = matrix . back (). back (); while ( l < r ) { int m = ( l + r ) >> 1 ; int count = 0 ; for ( auto & row : matrix ) count += upper_bound ( row . begin (), row . end (), m ) - row . begin (); if ( count >= k ) r = m ; else l = m + 1 ; } return l ; } };","title":"378. Kth Smallest Element in a Sorted Matrix $\\star\\star$"},{"location":"golang/0301-0400/0371-0380/#379-design-phone-directory-starstar","text":"","title":"379. Design Phone Directory $\\star\\star$"},{"location":"golang/0301-0400/0371-0380/#380-insert-delete-getrandom-o1-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class RandomizedSet { public : bool insert ( int val ) { if ( map . count ( val )) return false ; map [ val ] = vals . size (); vals . push_back ( val ); return true ; } bool remove ( int val ) { if ( ! map . count ( val )) return false ; int index = map [ val ]; map [ vals . back ()] = index ; map . erase ( val ); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]; } private : vector < int > vals ; unordered_map < int , int > map ; };","title":"380. Insert Delete GetRandom O(1) $\\star\\star$"},{"location":"golang/0301-0400/0381-0390/","text":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class RandomizedCollection { public : bool insert ( int val ) { map [ val ]. push_back ( vals . size ()); vals . emplace_back ( val , map [ val ]. size () - 1 ); return map [ val ]. size () == 1 ; } bool remove ( int val ) { if ( ! map . count ( val ) || map [ val ]. empty ()) return false ; int index = map [ val ]. back (); map [ vals . back (). first ][ vals . back (). second ] = index ; map [ val ]. pop_back (); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]. first ; } private : vector < pair < int , int >> vals ; unordered_map < int , vector < int >> map ; }; 382. Linked List Random Node $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Solution ( ListNode * head ) { privateHead = head ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; } int getRandom () { int n = rand () % length ; ListNode * curr = privateHead ; while ( n -- > 0 ) curr = curr -> next ; return curr -> val ; } private : ListNode * privateHead ; int length = 0 ; }; 383. Ransom Note $\\star$ 384. Shuffle an Array $\\star\\star$ 385. Mini Parser $\\star\\star$ 386. Lexicographical Numbers $\\star\\star$ 387. First Unique Character in a String $\\star$ 388. Longest Absolute File Path $\\star\\star$ 389. Find the Difference $\\star$ 390. Elimination Game $\\star\\star$","title":"0381-0390"},{"location":"golang/0301-0400/0381-0390/#381-insert-delete-getrandom-o1-duplicates-allowed-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class RandomizedCollection { public : bool insert ( int val ) { map [ val ]. push_back ( vals . size ()); vals . emplace_back ( val , map [ val ]. size () - 1 ); return map [ val ]. size () == 1 ; } bool remove ( int val ) { if ( ! map . count ( val ) || map [ val ]. empty ()) return false ; int index = map [ val ]. back (); map [ vals . back (). first ][ vals . back (). second ] = index ; map [ val ]. pop_back (); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]. first ; } private : vector < pair < int , int >> vals ; unordered_map < int , vector < int >> map ; };","title":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$"},{"location":"golang/0301-0400/0381-0390/#382-linked-list-random-node-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Solution ( ListNode * head ) { privateHead = head ; for ( auto curr = head ; curr ; curr = curr -> next ) ++ length ; } int getRandom () { int n = rand () % length ; ListNode * curr = privateHead ; while ( n -- > 0 ) curr = curr -> next ; return curr -> val ; } private : ListNode * privateHead ; int length = 0 ; };","title":"382. Linked List Random Node $\\star\\star$"},{"location":"golang/0301-0400/0381-0390/#383-ransom-note-star","text":"","title":"383. Ransom Note $\\star$"},{"location":"golang/0301-0400/0381-0390/#384-shuffle-an-array-starstar","text":"","title":"384. Shuffle an Array $\\star\\star$"},{"location":"golang/0301-0400/0381-0390/#385-mini-parser-starstar","text":"","title":"385. Mini Parser $\\star\\star$"},{"location":"golang/0301-0400/0381-0390/#386-lexicographical-numbers-starstar","text":"","title":"386. Lexicographical Numbers $\\star\\star$"},{"location":"golang/0301-0400/0381-0390/#387-first-unique-character-in-a-string-star","text":"","title":"387. First Unique Character in a String $\\star$"},{"location":"golang/0301-0400/0381-0390/#388-longest-absolute-file-path-starstar","text":"","title":"388. Longest Absolute File Path $\\star\\star$"},{"location":"golang/0301-0400/0381-0390/#389-find-the-difference-star","text":"","title":"389. Find the Difference $\\star$"},{"location":"golang/0301-0400/0381-0390/#390-elimination-game-starstar","text":"","title":"390. Elimination Game $\\star\\star$"},{"location":"golang/0301-0400/0391-0400/","text":"391. Perfect Rectangle $\\star\\star\\star$ 392. Is Subsequence $\\star$ 393. UTF-8 Validation $\\star\\star$ 394. Decode String $\\star\\star$ 395. Longest Substring with At Least K Repeating Characters $\\star\\star$ 396. Rotate Function $\\star\\star$ 397. Integer Replacement $\\star\\star$ 398. Random Pick Index $\\star\\star$ 399. Evaluate Division $\\star\\star$ 400. Nth Digit $\\star\\star$","title":"0391-0300"},{"location":"golang/0301-0400/0391-0400/#391-perfect-rectangle-starstarstar","text":"","title":"391. Perfect Rectangle $\\star\\star\\star$"},{"location":"golang/0301-0400/0391-0400/#392-is-subsequence-star","text":"","title":"392. Is Subsequence $\\star$"},{"location":"golang/0301-0400/0391-0400/#393-utf-8-validation-starstar","text":"","title":"393. UTF-8 Validation $\\star\\star$"},{"location":"golang/0301-0400/0391-0400/#394-decode-string-starstar","text":"","title":"394. Decode String $\\star\\star$"},{"location":"golang/0301-0400/0391-0400/#395-longest-substring-with-at-least-k-repeating-characters-starstar","text":"","title":"395. Longest Substring with At Least K Repeating Characters $\\star\\star$"},{"location":"golang/0301-0400/0391-0400/#396-rotate-function-starstar","text":"","title":"396. Rotate Function $\\star\\star$"},{"location":"golang/0301-0400/0391-0400/#397-integer-replacement-starstar","text":"","title":"397. Integer Replacement $\\star\\star$"},{"location":"golang/0301-0400/0391-0400/#398-random-pick-index-starstar","text":"","title":"398. Random Pick Index $\\star\\star$"},{"location":"golang/0301-0400/0391-0400/#399-evaluate-division-starstar","text":"","title":"399. Evaluate Division $\\star\\star$"},{"location":"golang/0301-0400/0391-0400/#400-nth-digit-starstar","text":"","title":"400. Nth Digit $\\star\\star$"},{"location":"golang/0401-0500/0401-0410/","text":"401. Binary Watch $\\star$ 402. Remove K Digits $\\star\\star$ 403. Frog Jump $\\star\\star\\star$ 404. Sum of Left Leaves $\\star$ 405. Convert a Number to Hexadecimal $\\star$ 406. Queue Reconstruction by Height $\\star\\star$ 407. Trapping Rain Water II $\\star\\star\\star$ 408. Valid Word Abbreviation $\\star$ 409. Longest Palindrome $\\star$ 410. Split Array Largest Sum $\\star\\star\\star$","title":"0401-0410"},{"location":"golang/0401-0500/0401-0410/#401-binary-watch-star","text":"","title":"401. Binary Watch $\\star$"},{"location":"golang/0401-0500/0401-0410/#402-remove-k-digits-starstar","text":"","title":"402. Remove K Digits $\\star\\star$"},{"location":"golang/0401-0500/0401-0410/#403-frog-jump-starstarstar","text":"","title":"403. Frog Jump $\\star\\star\\star$"},{"location":"golang/0401-0500/0401-0410/#404-sum-of-left-leaves-star","text":"","title":"404. Sum of Left Leaves $\\star$"},{"location":"golang/0401-0500/0401-0410/#405-convert-a-number-to-hexadecimal-star","text":"","title":"405. Convert a Number to Hexadecimal $\\star$"},{"location":"golang/0401-0500/0401-0410/#406-queue-reconstruction-by-height-starstar","text":"","title":"406. Queue Reconstruction by Height $\\star\\star$"},{"location":"golang/0401-0500/0401-0410/#407-trapping-rain-water-ii-starstarstar","text":"","title":"407. Trapping Rain Water II $\\star\\star\\star$"},{"location":"golang/0401-0500/0401-0410/#408-valid-word-abbreviation-star","text":"","title":"408. Valid Word Abbreviation $\\star$"},{"location":"golang/0401-0500/0401-0410/#409-longest-palindrome-star","text":"","title":"409. Longest Palindrome $\\star$"},{"location":"golang/0401-0500/0401-0410/#410-split-array-largest-sum-starstarstar","text":"","title":"410. Split Array Largest Sum $\\star\\star\\star$"},{"location":"golang/0401-0500/0411-0420/","text":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$ 412. Fizz Buzz $\\star$ 413. Arithmetic Slices $\\star\\star$ 414. Third Maximum Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int thirdMax ( vector < int >& nums ) { priority_queue < int , vector < int > , compare > pq ; unordered_set < int > set ; for ( int num : nums ) if ( ! set . count ( num )) { set . insert ( num ); pq . push ( num ); if ( pq . size () > 3 ) pq . pop (); } if ( pq . size () == 2 ) pq . pop (); return pq . top (); } private : struct compare { bool operator ()( const int a , const int b ) { return a > b ; } }; }; 415. Add Strings $\\star$ 416. Partition Equal Subset Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 func canPartition ( nums [] int ) bool { // return func1 ( nums ); return func2 ( nums ); } /* pack[i][v] means: * 1. The i-th item, weight=nums[i-1] * 2. The v capacity package */ func func1 ( nums [] int ) bool { sum : = 0 ; for i : = 0 ; i < len ( nums ); i ++ { sum += nums [ i ] ; } if sum % 2 != 0 { return false ; } vol : = sum / 2 ; N : = len ( nums ); pack : = make ( [][] bool , N + 1 ); for i : = 0 ; i <= N ; i ++ { pack [ i ] = make ( [] bool , vol + 1 ); } pack [ 0 ][ 0 ] = true ; for i : = 1 ; i <= N ; i ++ { curr_v : = nums [ i-1 ] ; for v : = vol ; v >= 0 ; v -- { if v >= curr_v { pack [ i ][ v ] = pack [ i-1 ][ v ] || pack [ i-1 ][ v-curr_v ] ; } else { pack [ i ][ v ] = pack [ i-1 ][ v ] ; } } } for i : = 0 ; i <= N ; i ++ { if pack [ i ][ vol ] == true { return true } } return false } func func2 ( nums [] int ) bool { sum : = 0 ; for i : = 0 ; i < len ( nums ); i ++ { sum += nums [ i ] ; } if sum % 2 != 0 { return false ; } vol : = sum / 2 ; N : = len ( nums ); pack : = make ( [] bool , vol + 1 ); pack [ 0 ] = true ; for i : = 1 ; i <= N ; i ++ { curr_v : = nums [ i-1 ] ; for v : = vol ; v >= 0 ; v -- { if v >= curr_v { pack [ v ] = pack [ v ] || pack [ v-curr_v ] ; } else { pack [ v ] = pack [ v ] ; } } if pack [ vol ] == true { return true ; } } return false } 417. Pacific Atlantic Water Flow $\\star\\star$ 418. Sentence Screen Fitting $\\star\\star$ 419. Battleships in a Board $\\star\\star$ 420. Strong Password Checker $\\star\\star\\star$","title":"0411-0420"},{"location":"golang/0401-0500/0411-0420/#411-minimum-unique-word-abbreviation-starstarstar","text":"","title":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$"},{"location":"golang/0401-0500/0411-0420/#412-fizz-buzz-star","text":"","title":"412. Fizz Buzz $\\star$"},{"location":"golang/0401-0500/0411-0420/#413-arithmetic-slices-starstar","text":"","title":"413. Arithmetic Slices $\\star\\star$"},{"location":"golang/0401-0500/0411-0420/#414-third-maximum-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int thirdMax ( vector < int >& nums ) { priority_queue < int , vector < int > , compare > pq ; unordered_set < int > set ; for ( int num : nums ) if ( ! set . count ( num )) { set . insert ( num ); pq . push ( num ); if ( pq . size () > 3 ) pq . pop (); } if ( pq . size () == 2 ) pq . pop (); return pq . top (); } private : struct compare { bool operator ()( const int a , const int b ) { return a > b ; } }; };","title":"414. Third Maximum Number $\\star$"},{"location":"golang/0401-0500/0411-0420/#415-add-strings-star","text":"","title":"415. Add Strings $\\star$"},{"location":"golang/0401-0500/0411-0420/#416-partition-equal-subset-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 func canPartition ( nums [] int ) bool { // return func1 ( nums ); return func2 ( nums ); } /* pack[i][v] means: * 1. The i-th item, weight=nums[i-1] * 2. The v capacity package */ func func1 ( nums [] int ) bool { sum : = 0 ; for i : = 0 ; i < len ( nums ); i ++ { sum += nums [ i ] ; } if sum % 2 != 0 { return false ; } vol : = sum / 2 ; N : = len ( nums ); pack : = make ( [][] bool , N + 1 ); for i : = 0 ; i <= N ; i ++ { pack [ i ] = make ( [] bool , vol + 1 ); } pack [ 0 ][ 0 ] = true ; for i : = 1 ; i <= N ; i ++ { curr_v : = nums [ i-1 ] ; for v : = vol ; v >= 0 ; v -- { if v >= curr_v { pack [ i ][ v ] = pack [ i-1 ][ v ] || pack [ i-1 ][ v-curr_v ] ; } else { pack [ i ][ v ] = pack [ i-1 ][ v ] ; } } } for i : = 0 ; i <= N ; i ++ { if pack [ i ][ vol ] == true { return true } } return false } func func2 ( nums [] int ) bool { sum : = 0 ; for i : = 0 ; i < len ( nums ); i ++ { sum += nums [ i ] ; } if sum % 2 != 0 { return false ; } vol : = sum / 2 ; N : = len ( nums ); pack : = make ( [] bool , vol + 1 ); pack [ 0 ] = true ; for i : = 1 ; i <= N ; i ++ { curr_v : = nums [ i-1 ] ; for v : = vol ; v >= 0 ; v -- { if v >= curr_v { pack [ v ] = pack [ v ] || pack [ v-curr_v ] ; } else { pack [ v ] = pack [ v ] ; } } if pack [ vol ] == true { return true ; } } return false }","title":"416. Partition Equal Subset Sum $\\star\\star$"},{"location":"golang/0401-0500/0411-0420/#417-pacific-atlantic-water-flow-starstar","text":"","title":"417. Pacific Atlantic Water Flow $\\star\\star$"},{"location":"golang/0401-0500/0411-0420/#418-sentence-screen-fitting-starstar","text":"","title":"418. Sentence Screen Fitting $\\star\\star$"},{"location":"golang/0401-0500/0411-0420/#419-battleships-in-a-board-starstar","text":"","title":"419. Battleships in a Board $\\star\\star$"},{"location":"golang/0401-0500/0411-0420/#420-strong-password-checker-starstarstar","text":"","title":"420. Strong Password Checker $\\star\\star\\star$"},{"location":"golang/0401-0500/0421-0430/","text":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$ 422. Valid Word Square $\\star$ 423. Reconstruct Original Digits from English $\\star\\star$ 424. Longest Repeating Character Replacement $\\star\\star$ 425. Word Squares $\\star\\star\\star$ 426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$ 427. Construct Quad Tree $\\star\\star$ 428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$ 429. N-ary Tree Level Order Traversal $\\star\\star$ 430. Flatten a Multilevel Doubly Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * flatten ( Node * head ) { for ( Node * curr = head ; curr ; curr = curr -> next ) if ( curr -> child ) { Node * next = curr -> next ; curr -> next = curr -> child ; curr -> next -> prev = curr ; curr -> child = NULL ; Node * tail = curr -> next ; while ( tail -> next ) tail = tail -> next ; tail -> next = next ; if ( next ) next -> prev = tail ; } return head ; } };","title":"0421-0430"},{"location":"golang/0401-0500/0421-0430/#421-maximum-xor-of-two-numbers-in-an-array-starstar","text":"","title":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$"},{"location":"golang/0401-0500/0421-0430/#422-valid-word-square-star","text":"","title":"422. Valid Word Square $\\star$"},{"location":"golang/0401-0500/0421-0430/#423-reconstruct-original-digits-from-english-starstar","text":"","title":"423. Reconstruct Original Digits from English $\\star\\star$"},{"location":"golang/0401-0500/0421-0430/#424-longest-repeating-character-replacement-starstar","text":"","title":"424. Longest Repeating Character Replacement $\\star\\star$"},{"location":"golang/0401-0500/0421-0430/#425-word-squares-starstarstar","text":"","title":"425. Word Squares $\\star\\star\\star$"},{"location":"golang/0401-0500/0421-0430/#426-convert-binary-search-tree-to-sorted-doubly-linked-list-starstar","text":"","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$"},{"location":"golang/0401-0500/0421-0430/#427-construct-quad-tree-starstar","text":"","title":"427. Construct Quad Tree $\\star\\star$"},{"location":"golang/0401-0500/0421-0430/#428-serialize-and-deserialize-n-ary-tree-starstarstar","text":"","title":"428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$"},{"location":"golang/0401-0500/0421-0430/#429-n-ary-tree-level-order-traversal-starstar","text":"","title":"429. N-ary Tree Level Order Traversal $\\star\\star$"},{"location":"golang/0401-0500/0421-0430/#430-flatten-a-multilevel-doubly-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * flatten ( Node * head ) { for ( Node * curr = head ; curr ; curr = curr -> next ) if ( curr -> child ) { Node * next = curr -> next ; curr -> next = curr -> child ; curr -> next -> prev = curr ; curr -> child = NULL ; Node * tail = curr -> next ; while ( tail -> next ) tail = tail -> next ; tail -> next = next ; if ( next ) next -> prev = tail ; } return head ; } };","title":"430. Flatten a Multilevel Doubly Linked List $\\star\\star$"},{"location":"golang/0401-0500/0431-0440/","text":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$ 432. All O`one Data Structure $\\star\\star\\star$ 433. Minimum Genetic Mutation $\\star\\star$ 434. Number of Segments in a String $\\star$ 435. Non-overlapping Intervals $\\star\\star$ 436. Find Right Interval $\\star\\star$ 437. Path Sum III $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int pathSum ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return helper ( root , sum ) + pathSum ( root -> left , sum ) + pathSum ( root -> right , sum ); } private : int helper ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return ( sum == root -> val ) + helper ( root -> left , sum - root -> val ) + helper ( root -> right , sum - root -> val ); } }; 438. Find All Anagrams in a String $\\star\\star$ 439. Ternary Expression Parser $\\star\\star$ 440. K-th Smallest in Lexicographical Order $\\star\\star\\star$","title":"0431-0440"},{"location":"golang/0401-0500/0431-0440/#431-encode-n-ary-tree-to-binary-tree-starstarstar","text":"","title":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$"},{"location":"golang/0401-0500/0431-0440/#432-all-oone-data-structure-starstarstar","text":"","title":"432. All O`one Data Structure $\\star\\star\\star$"},{"location":"golang/0401-0500/0431-0440/#433-minimum-genetic-mutation-starstar","text":"","title":"433. Minimum Genetic Mutation $\\star\\star$"},{"location":"golang/0401-0500/0431-0440/#434-number-of-segments-in-a-string-star","text":"","title":"434. Number of Segments in a String $\\star$"},{"location":"golang/0401-0500/0431-0440/#435-non-overlapping-intervals-starstar","text":"","title":"435. Non-overlapping Intervals $\\star\\star$"},{"location":"golang/0401-0500/0431-0440/#436-find-right-interval-starstar","text":"","title":"436. Find Right Interval $\\star\\star$"},{"location":"golang/0401-0500/0431-0440/#437-path-sum-iii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int pathSum ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return helper ( root , sum ) + pathSum ( root -> left , sum ) + pathSum ( root -> right , sum ); } private : int helper ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return ( sum == root -> val ) + helper ( root -> left , sum - root -> val ) + helper ( root -> right , sum - root -> val ); } };","title":"437. Path Sum III $\\star$"},{"location":"golang/0401-0500/0431-0440/#438-find-all-anagrams-in-a-string-starstar","text":"","title":"438. Find All Anagrams in a String $\\star\\star$"},{"location":"golang/0401-0500/0431-0440/#439-ternary-expression-parser-starstar","text":"","title":"439. Ternary Expression Parser $\\star\\star$"},{"location":"golang/0401-0500/0431-0440/#440-k-th-smallest-in-lexicographical-order-starstarstar","text":"","title":"440. K-th Smallest in Lexicographical Order $\\star\\star\\star$"},{"location":"golang/0401-0500/0441-0450/","text":"441. Arranging Coins $\\star$ 442. Find All Duplicates in an Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > findDuplicates ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { nums [ abs ( num ) - 1 ] *= - 1 ; if ( nums [ abs ( num ) - 1 ] > 0 ) ans . push_back ( abs ( num )); } return ans ; } }; 443. String Compression $\\star$ 444. Sequence Reconstruction $\\star\\star$ 445. Add Two Numbers II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { stack < ListNode *> stack1 ; stack < ListNode *> stack2 ; while ( l1 ) { stack1 . push ( l1 ); l1 = l1 -> next ; } while ( l2 ) { stack2 . push ( l2 ); l2 = l2 -> next ; } ListNode * head = NULL ; int carry = 0 ; while ( carry || ! stack1 . empty () || ! stack2 . empty ()) { if ( ! stack1 . empty ()) { carry += stack1 . top () -> val ; stack1 . pop (); } if ( ! stack2 . empty ()) { carry += stack2 . top () -> val ; stack2 . pop (); } ListNode * node = new ListNode ( carry % 10 ); node -> next = head ; head = node ; carry /= 10 ; } return head ; } }; 446. Arithmetic Slices II - Subsequence $\\star\\star\\star$ 447. Number of Boomerangs $\\star$ 448. Find All Numbers Disappeared in an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > findDisappearedNumbers ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { int index = abs ( num ) - 1 ; nums [ index ] = - abs ( nums [ index ]); } for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > 0 ) ans . push_back ( i + 1 ); return ans ; } }; 449. Serialize and Deserialize BST $\\star\\star$ 450. Delete Node in a BST $\\star\\star$","title":"0441-0450"},{"location":"golang/0401-0500/0441-0450/#441-arranging-coins-star","text":"","title":"441. Arranging Coins $\\star$"},{"location":"golang/0401-0500/0441-0450/#442-find-all-duplicates-in-an-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > findDuplicates ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { nums [ abs ( num ) - 1 ] *= - 1 ; if ( nums [ abs ( num ) - 1 ] > 0 ) ans . push_back ( abs ( num )); } return ans ; } };","title":"442. Find All Duplicates in an Array $\\star\\star$"},{"location":"golang/0401-0500/0441-0450/#443-string-compression-star","text":"","title":"443. String Compression $\\star$"},{"location":"golang/0401-0500/0441-0450/#444-sequence-reconstruction-starstar","text":"","title":"444. Sequence Reconstruction $\\star\\star$"},{"location":"golang/0401-0500/0441-0450/#445-add-two-numbers-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { stack < ListNode *> stack1 ; stack < ListNode *> stack2 ; while ( l1 ) { stack1 . push ( l1 ); l1 = l1 -> next ; } while ( l2 ) { stack2 . push ( l2 ); l2 = l2 -> next ; } ListNode * head = NULL ; int carry = 0 ; while ( carry || ! stack1 . empty () || ! stack2 . empty ()) { if ( ! stack1 . empty ()) { carry += stack1 . top () -> val ; stack1 . pop (); } if ( ! stack2 . empty ()) { carry += stack2 . top () -> val ; stack2 . pop (); } ListNode * node = new ListNode ( carry % 10 ); node -> next = head ; head = node ; carry /= 10 ; } return head ; } };","title":"445. Add Two Numbers II $\\star\\star$"},{"location":"golang/0401-0500/0441-0450/#446-arithmetic-slices-ii-subsequence-starstarstar","text":"","title":"446. Arithmetic Slices II - Subsequence $\\star\\star\\star$"},{"location":"golang/0401-0500/0441-0450/#447-number-of-boomerangs-star","text":"","title":"447. Number of Boomerangs $\\star$"},{"location":"golang/0401-0500/0441-0450/#448-find-all-numbers-disappeared-in-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > findDisappearedNumbers ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { int index = abs ( num ) - 1 ; nums [ index ] = - abs ( nums [ index ]); } for ( int i = 0 ; i < nums . size (); ++ i ) if ( nums [ i ] > 0 ) ans . push_back ( i + 1 ); return ans ; } };","title":"448. Find All Numbers Disappeared in an Array $\\star$"},{"location":"golang/0401-0500/0441-0450/#449-serialize-and-deserialize-bst-starstar","text":"","title":"449. Serialize and Deserialize BST $\\star\\star$"},{"location":"golang/0401-0500/0441-0450/#450-delete-node-in-a-bst-starstar","text":"","title":"450. Delete Node in a BST $\\star\\star$"},{"location":"golang/0401-0500/0451-0460/","text":"451. Sort Characters By Frequency $\\star\\star$ 452. Minimum Number of Arrows to Burst Balloons $\\star\\star$ 453. Minimum Moves to Equal Array Elements $\\star$ 454. 4Sum II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fourSumCount ( vector < int >& A , vector < int >& B , vector < int >& C , vector < int >& D ) { int ans = 0 ; unordered_map < int , int > map ; for ( int a : A ) for ( int b : B ) ++ map [ a + b ]; for ( int c : C ) for ( int d : D ) ans += map . count ( - c - d ) ? map [ - c - d ] : 0 ; return ans ; } }; 455. Assign Cookies $\\star$ 456. 132 Pattern $\\star\\star$ 457. Circular Array Loop $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { if ( nums . size () < 2 ) return false ; function < int ( int ) > advance = [ & ]( int i ) { const int n = nums . size (); int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } }; 458. Poor Pigs $\\star\\star\\star$ 459. Repeated Substring Pattern $\\star$ 460. LFU Cache $\\star\\star\\star$","title":"0451-0460"},{"location":"golang/0401-0500/0451-0460/#451-sort-characters-by-frequency-starstar","text":"","title":"451. Sort Characters By Frequency $\\star\\star$"},{"location":"golang/0401-0500/0451-0460/#452-minimum-number-of-arrows-to-burst-balloons-starstar","text":"","title":"452. Minimum Number of Arrows to Burst Balloons $\\star\\star$"},{"location":"golang/0401-0500/0451-0460/#453-minimum-moves-to-equal-array-elements-star","text":"","title":"453. Minimum Moves to Equal Array Elements $\\star$"},{"location":"golang/0401-0500/0451-0460/#454-4sum-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fourSumCount ( vector < int >& A , vector < int >& B , vector < int >& C , vector < int >& D ) { int ans = 0 ; unordered_map < int , int > map ; for ( int a : A ) for ( int b : B ) ++ map [ a + b ]; for ( int c : C ) for ( int d : D ) ans += map . count ( - c - d ) ? map [ - c - d ] : 0 ; return ans ; } };","title":"454. 4Sum II $\\star\\star$"},{"location":"golang/0401-0500/0451-0460/#455-assign-cookies-star","text":"","title":"455. Assign Cookies $\\star$"},{"location":"golang/0401-0500/0451-0460/#456-132-pattern-starstar","text":"","title":"456. 132 Pattern $\\star\\star$"},{"location":"golang/0401-0500/0451-0460/#457-circular-array-loop-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { if ( nums . size () < 2 ) return false ; function < int ( int ) > advance = [ & ]( int i ) { const int n = nums . size (); int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } };","title":"457. Circular Array Loop $\\star\\star$"},{"location":"golang/0401-0500/0451-0460/#458-poor-pigs-starstarstar","text":"","title":"458. Poor Pigs $\\star\\star\\star$"},{"location":"golang/0401-0500/0451-0460/#459-repeated-substring-pattern-star","text":"","title":"459. Repeated Substring Pattern $\\star$"},{"location":"golang/0401-0500/0451-0460/#460-lfu-cache-starstarstar","text":"","title":"460. LFU Cache $\\star\\star\\star$"},{"location":"golang/0401-0500/0461-0470/","text":"461. Hamming Distance $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int hammingDistance ( int x , int y ) { int ans = 0 ; while ( x || y ) { ans += ( x % 2 ) ^ ( y % 2 ); x /= 2 ; y /= 2 ; } return ans ; } }; 462. Minimum Moves to Equal Array Elements II $\\star\\star$ 463. Island Perimeter $\\star$ 464. Can I Win $\\star\\star$ 465. Optimal Account Balancing $\\star\\star\\star$ 466. Count The Repetitions $\\star\\star\\star$ 467. Unique Substrings in Wraparound String $\\star\\star$ 468. Validate IP Address $\\star\\star$ 469. Convex Polygon $\\star\\star$ 470. Implement Rand10() Using Rand7() $\\star\\star$","title":"0461-0470"},{"location":"golang/0401-0500/0461-0470/#461-hamming-distance-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int hammingDistance ( int x , int y ) { int ans = 0 ; while ( x || y ) { ans += ( x % 2 ) ^ ( y % 2 ); x /= 2 ; y /= 2 ; } return ans ; } };","title":"461. Hamming Distance $\\star$"},{"location":"golang/0401-0500/0461-0470/#462-minimum-moves-to-equal-array-elements-ii-starstar","text":"","title":"462. Minimum Moves to Equal Array Elements II $\\star\\star$"},{"location":"golang/0401-0500/0461-0470/#463-island-perimeter-star","text":"","title":"463. Island Perimeter $\\star$"},{"location":"golang/0401-0500/0461-0470/#464-can-i-win-starstar","text":"","title":"464. Can I Win $\\star\\star$"},{"location":"golang/0401-0500/0461-0470/#465-optimal-account-balancing-starstarstar","text":"","title":"465. Optimal Account Balancing $\\star\\star\\star$"},{"location":"golang/0401-0500/0461-0470/#466-count-the-repetitions-starstarstar","text":"","title":"466. Count The Repetitions $\\star\\star\\star$"},{"location":"golang/0401-0500/0461-0470/#467-unique-substrings-in-wraparound-string-starstar","text":"","title":"467. Unique Substrings in Wraparound String $\\star\\star$"},{"location":"golang/0401-0500/0461-0470/#468-validate-ip-address-starstar","text":"","title":"468. Validate IP Address $\\star\\star$"},{"location":"golang/0401-0500/0461-0470/#469-convex-polygon-starstar","text":"","title":"469. Convex Polygon $\\star\\star$"},{"location":"golang/0401-0500/0461-0470/#470-implement-rand10-using-rand7-starstar","text":"","title":"470. Implement Rand10() Using Rand7() $\\star\\star$"},{"location":"golang/0401-0500/0471-0480/","text":"471. Encode String with Shortest Length $\\star\\star\\star$ 472. Concatenated Words $\\star\\star\\star$ 473. Matchsticks to Square $\\star\\star$ 474. Ones and Zeroes $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 func findMaxForm ( strs [] string , m int , n int ) int { // return func1 ( strs , m , n ); return func2 ( strs , m , n ); } // O ( len * m * n ) time , 2 * O ( m * n ) space func func1 ( strs [] string , m int , n int ) int { dp1 : = make ( [][] int , m + 1 ); dp2 : = make ( [][] int , m + 1 ); for i : = 0 ; i < m + 1 ; i ++ { dp1 [ i ] = make ( [] int , n + 1 ); dp2 [ i ] = make ( [] int , n + 1 ); } for i : = 1 ; i <= len ( strs ); i ++ { cnt0 , cnt1 : = count01 ( strs [ i-1 ] ); for j0 : = cnt0 ; j0 <= m ; j0 ++ { for j1 : = cnt1 ; j1 <= n ; j1 ++ { dp2 [ j0 ][ j1 ] = max ( dp1 [ j0 ][ j1 ] , 1 + dp1 [ j0-cnt0 ][ j1-cnt1 ] ); } } for j0 : = 0 ; j0 <= m ; j0 ++ { for j1 : = 0 ; j1 <= n ; j1 ++ { dp1 [ j0 ][ j1 ] = dp2 [ j0 ][ j1 ] ; } } } return dp2 [ m ][ n ] ; } // O ( len * m * n ) time , O ( m * n ) space func func2 ( strs [] string , m int , n int ) int { dp1 : = make ( [][] int , m + 1 ); for i : = 0 ; i < m + 1 ; i ++ { dp1 [ i ] = make ( [] int , n + 1 ); } for i : = 1 ; i <= len ( strs ); i ++ { cnt0 , cnt1 : = count01 ( strs [ i-1 ] ); for j0 : = m ; j0 >= cnt0 ; j0 -- { for j1 : = n ; j1 >= cnt1 ; j1 -- { dp1 [ j0 ][ j1 ] = max ( dp1 [ j0 ][ j1 ] , 1 + dp1 [ j0-cnt0 ][ j1-cnt1 ] ); } } } return dp1 [ m ][ n ] ; } func count01 ( str string ) ( int , int ) { cnt0 : = 0 ; cnt1 : = 0 ; for _ , s : = range str { if s == '0' { cnt0 ++ ; } if s == '1' { cnt1 ++ ; } } return cnt0 , cnt1 ; } func max ( a int , b int ) int { if a > b { return a ; } return b ; } 475. Heaters $\\star$ 476. Number Complement $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int findComplement ( int num ) { unsigned int mask = ~ 0 ; while ( num & mask ) mask <<= 1 ; return ~ num ^ mask ; } }; 477. Total Hamming Distance $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int totalHammingDistance ( vector < int >& nums ) { int ans = 0 ; int mask = 1 ; for ( int i = 0 ; i < 30 ; ++ i ) { int onesCount = 0 ; for ( int num : nums ) if ( num & mask ) ++ onesCount ; ans += ( nums . size () - onesCount ) * onesCount ; mask = mask << 1 ; } return ans ; } }; 478. Generate Random Point in a Circle $\\star\\star$ 479. Largest Palindrome Product $\\star\\star\\star$ 480. Sliding Window Median $\\star\\star\\star$","title":"0471-0480"},{"location":"golang/0401-0500/0471-0480/#471-encode-string-with-shortest-length-starstarstar","text":"","title":"471. Encode String with Shortest Length $\\star\\star\\star$"},{"location":"golang/0401-0500/0471-0480/#472-concatenated-words-starstarstar","text":"","title":"472. Concatenated Words $\\star\\star\\star$"},{"location":"golang/0401-0500/0471-0480/#473-matchsticks-to-square-starstar","text":"","title":"473. Matchsticks to Square $\\star\\star$"},{"location":"golang/0401-0500/0471-0480/#474-ones-and-zeroes-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 func findMaxForm ( strs [] string , m int , n int ) int { // return func1 ( strs , m , n ); return func2 ( strs , m , n ); } // O ( len * m * n ) time , 2 * O ( m * n ) space func func1 ( strs [] string , m int , n int ) int { dp1 : = make ( [][] int , m + 1 ); dp2 : = make ( [][] int , m + 1 ); for i : = 0 ; i < m + 1 ; i ++ { dp1 [ i ] = make ( [] int , n + 1 ); dp2 [ i ] = make ( [] int , n + 1 ); } for i : = 1 ; i <= len ( strs ); i ++ { cnt0 , cnt1 : = count01 ( strs [ i-1 ] ); for j0 : = cnt0 ; j0 <= m ; j0 ++ { for j1 : = cnt1 ; j1 <= n ; j1 ++ { dp2 [ j0 ][ j1 ] = max ( dp1 [ j0 ][ j1 ] , 1 + dp1 [ j0-cnt0 ][ j1-cnt1 ] ); } } for j0 : = 0 ; j0 <= m ; j0 ++ { for j1 : = 0 ; j1 <= n ; j1 ++ { dp1 [ j0 ][ j1 ] = dp2 [ j0 ][ j1 ] ; } } } return dp2 [ m ][ n ] ; } // O ( len * m * n ) time , O ( m * n ) space func func2 ( strs [] string , m int , n int ) int { dp1 : = make ( [][] int , m + 1 ); for i : = 0 ; i < m + 1 ; i ++ { dp1 [ i ] = make ( [] int , n + 1 ); } for i : = 1 ; i <= len ( strs ); i ++ { cnt0 , cnt1 : = count01 ( strs [ i-1 ] ); for j0 : = m ; j0 >= cnt0 ; j0 -- { for j1 : = n ; j1 >= cnt1 ; j1 -- { dp1 [ j0 ][ j1 ] = max ( dp1 [ j0 ][ j1 ] , 1 + dp1 [ j0-cnt0 ][ j1-cnt1 ] ); } } } return dp1 [ m ][ n ] ; } func count01 ( str string ) ( int , int ) { cnt0 : = 0 ; cnt1 : = 0 ; for _ , s : = range str { if s == '0' { cnt0 ++ ; } if s == '1' { cnt1 ++ ; } } return cnt0 , cnt1 ; } func max ( a int , b int ) int { if a > b { return a ; } return b ; }","title":"474. Ones and Zeroes $\\star\\star$"},{"location":"golang/0401-0500/0471-0480/#475-heaters-star","text":"","title":"475. Heaters $\\star$"},{"location":"golang/0401-0500/0471-0480/#476-number-complement-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int findComplement ( int num ) { unsigned int mask = ~ 0 ; while ( num & mask ) mask <<= 1 ; return ~ num ^ mask ; } };","title":"476. Number Complement $\\star$"},{"location":"golang/0401-0500/0471-0480/#477-total-hamming-distance-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int totalHammingDistance ( vector < int >& nums ) { int ans = 0 ; int mask = 1 ; for ( int i = 0 ; i < 30 ; ++ i ) { int onesCount = 0 ; for ( int num : nums ) if ( num & mask ) ++ onesCount ; ans += ( nums . size () - onesCount ) * onesCount ; mask = mask << 1 ; } return ans ; } };","title":"477. Total Hamming Distance $\\star\\star$"},{"location":"golang/0401-0500/0471-0480/#478-generate-random-point-in-a-circle-starstar","text":"","title":"478. Generate Random Point in a Circle $\\star\\star$"},{"location":"golang/0401-0500/0471-0480/#479-largest-palindrome-product-starstarstar","text":"","title":"479. Largest Palindrome Product $\\star\\star\\star$"},{"location":"golang/0401-0500/0471-0480/#480-sliding-window-median-starstarstar","text":"","title":"480. Sliding Window Median $\\star\\star\\star$"},{"location":"golang/0401-0500/0481-0490/","text":"481. Magical String $\\star\\star$ 482. License Key Formatting $\\star$ 483. Smallest Good Base $\\star\\star\\star$ 484. Find Permutation $\\star\\star$ 485. Max Consecutive Ones $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findMaxConsecutiveOnes ( vector < int >& nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = max ( ans , sum ); } } return ans ; } }; 486. Predict the Winner $\\star\\star$ 487. Max Consecutive Ones II $\\star\\star$ 488. Zuma Game $\\star\\star\\star$ 489. Robot Room Cleaner $\\star\\star\\star$ 490. The Maze $\\star\\star$","title":"0481-0490"},{"location":"golang/0401-0500/0481-0490/#481-magical-string-starstar","text":"","title":"481. Magical String $\\star\\star$"},{"location":"golang/0401-0500/0481-0490/#482-license-key-formatting-star","text":"","title":"482. License Key Formatting $\\star$"},{"location":"golang/0401-0500/0481-0490/#483-smallest-good-base-starstarstar","text":"","title":"483. Smallest Good Base $\\star\\star\\star$"},{"location":"golang/0401-0500/0481-0490/#484-find-permutation-starstar","text":"","title":"484. Find Permutation $\\star\\star$"},{"location":"golang/0401-0500/0481-0490/#485-max-consecutive-ones-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findMaxConsecutiveOnes ( vector < int >& nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = max ( ans , sum ); } } return ans ; } };","title":"485. Max Consecutive Ones $\\star$"},{"location":"golang/0401-0500/0481-0490/#486-predict-the-winner-starstar","text":"","title":"486. Predict the Winner $\\star\\star$"},{"location":"golang/0401-0500/0481-0490/#487-max-consecutive-ones-ii-starstar","text":"","title":"487. Max Consecutive Ones II $\\star\\star$"},{"location":"golang/0401-0500/0481-0490/#488-zuma-game-starstarstar","text":"","title":"488. Zuma Game $\\star\\star\\star$"},{"location":"golang/0401-0500/0481-0490/#489-robot-room-cleaner-starstarstar","text":"","title":"489. Robot Room Cleaner $\\star\\star\\star$"},{"location":"golang/0401-0500/0481-0490/#490-the-maze-starstar","text":"","title":"490. The Maze $\\star\\star$"},{"location":"golang/0401-0500/0491-0500/","text":"491. Increasing Subsequences $\\star\\star$ 492. Construct the Rectangle $\\star$ 493. Reverse Pairs $\\star\\star\\star$ 494. Target Sum $\\star\\star$ 495. Teemo Attacking $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int findPoisonedDuration ( vector < int >& timeSeries , int duration ) { if ( timeSeries . empty () || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . size (); ++ i ) ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ); return ans + duration ; } }; 496. Next Greater Element I $\\star$ 497. Random Point in Non-overlapping Rectangles $\\star\\star$ 498. Diagonal Traverse $\\star\\star$ 499. The Maze III $\\star\\star\\star$ 500. Keyboard Row $\\star$","title":"0491-0500"},{"location":"golang/0401-0500/0491-0500/#491-increasing-subsequences-starstar","text":"","title":"491. Increasing Subsequences $\\star\\star$"},{"location":"golang/0401-0500/0491-0500/#492-construct-the-rectangle-star","text":"","title":"492. Construct the Rectangle $\\star$"},{"location":"golang/0401-0500/0491-0500/#493-reverse-pairs-starstarstar","text":"","title":"493. Reverse Pairs $\\star\\star\\star$"},{"location":"golang/0401-0500/0491-0500/#494-target-sum-starstar","text":"","title":"494. Target Sum $\\star\\star$"},{"location":"golang/0401-0500/0491-0500/#495-teemo-attacking-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int findPoisonedDuration ( vector < int >& timeSeries , int duration ) { if ( timeSeries . empty () || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . size (); ++ i ) ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ); return ans + duration ; } };","title":"495. Teemo Attacking $\\star\\star$"},{"location":"golang/0401-0500/0491-0500/#496-next-greater-element-i-star","text":"","title":"496. Next Greater Element I $\\star$"},{"location":"golang/0401-0500/0491-0500/#497-random-point-in-non-overlapping-rectangles-starstar","text":"","title":"497. Random Point in Non-overlapping Rectangles $\\star\\star$"},{"location":"golang/0401-0500/0491-0500/#498-diagonal-traverse-starstar","text":"","title":"498. Diagonal Traverse $\\star\\star$"},{"location":"golang/0401-0500/0491-0500/#499-the-maze-iii-starstarstar","text":"","title":"499. The Maze III $\\star\\star\\star$"},{"location":"golang/0401-0500/0491-0500/#500-keyboard-row-star","text":"","title":"500. Keyboard Row $\\star$"},{"location":"golang/0501-0600/0501-0510/","text":"501. Find Mode in Binary Search Tree $\\star$ 502. IPO $\\star\\star\\star$ 503. Next Greater Element II $\\star\\star$ 504. Base 7 $\\star$ 505. The Maze II $\\star\\star$ 506. Relative Ranks $\\star$ 507. Perfect Number $\\star$ 508. Most Frequent Subtree Sum $\\star\\star$ 509. Fibonacci Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fib ( int N ) { if ( N < 2 ) return N ; int dp [] = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ]; dp [ 1 ] = dp [ 2 ]; dp [ 2 ] = dp [ 0 ] + dp [ 1 ]; } return dp [ 2 ]; } }; 510. Inorder Successor in BST II $\\star\\star$","title":"0501-0510"},{"location":"golang/0501-0600/0501-0510/#501-find-mode-in-binary-search-tree-star","text":"","title":"501. Find Mode in Binary Search Tree $\\star$"},{"location":"golang/0501-0600/0501-0510/#502-ipo-starstarstar","text":"","title":"502. IPO $\\star\\star\\star$"},{"location":"golang/0501-0600/0501-0510/#503-next-greater-element-ii-starstar","text":"","title":"503. Next Greater Element II $\\star\\star$"},{"location":"golang/0501-0600/0501-0510/#504-base-7-star","text":"","title":"504. Base 7 $\\star$"},{"location":"golang/0501-0600/0501-0510/#505-the-maze-ii-starstar","text":"","title":"505. The Maze II $\\star\\star$"},{"location":"golang/0501-0600/0501-0510/#506-relative-ranks-star","text":"","title":"506. Relative Ranks $\\star$"},{"location":"golang/0501-0600/0501-0510/#507-perfect-number-star","text":"","title":"507. Perfect Number $\\star$"},{"location":"golang/0501-0600/0501-0510/#508-most-frequent-subtree-sum-starstar","text":"","title":"508. Most Frequent Subtree Sum $\\star\\star$"},{"location":"golang/0501-0600/0501-0510/#509-fibonacci-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fib ( int N ) { if ( N < 2 ) return N ; int dp [] = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; ++ i ) { dp [ 0 ] = dp [ 1 ]; dp [ 1 ] = dp [ 2 ]; dp [ 2 ] = dp [ 0 ] + dp [ 1 ]; } return dp [ 2 ]; } };","title":"509. Fibonacci Number $\\star$"},{"location":"golang/0501-0600/0501-0510/#510-inorder-successor-in-bst-ii-starstar","text":"","title":"510. Inorder Successor in BST II $\\star\\star$"},{"location":"golang/0501-0600/0511-0520/","text":"511. Game Play Analysis I $\\star$ 512. Game Play Analysis II $\\star$ 513. Find Bottom Left Tree Value $\\star\\star$ 514. Freedom Trail $\\star\\star\\star$ 515. Find Largest Value in Each Tree Row $\\star\\star$ 516. Longest Palindromic Subsequence $\\star\\star$ 517. Super Washing Machines $\\star\\star\\star$ 518. Coin Change 2 $\\star\\star$ 519. Random Flip Matrix $\\star\\star$ 520. Detect Capital $\\star$","title":"0511-0520"},{"location":"golang/0501-0600/0511-0520/#511-game-play-analysis-i-star","text":"","title":"511. Game Play Analysis I $\\star$"},{"location":"golang/0501-0600/0511-0520/#512-game-play-analysis-ii-star","text":"","title":"512. Game Play Analysis II $\\star$"},{"location":"golang/0501-0600/0511-0520/#513-find-bottom-left-tree-value-starstar","text":"","title":"513. Find Bottom Left Tree Value $\\star\\star$"},{"location":"golang/0501-0600/0511-0520/#514-freedom-trail-starstarstar","text":"","title":"514. Freedom Trail $\\star\\star\\star$"},{"location":"golang/0501-0600/0511-0520/#515-find-largest-value-in-each-tree-row-starstar","text":"","title":"515. Find Largest Value in Each Tree Row $\\star\\star$"},{"location":"golang/0501-0600/0511-0520/#516-longest-palindromic-subsequence-starstar","text":"","title":"516. Longest Palindromic Subsequence $\\star\\star$"},{"location":"golang/0501-0600/0511-0520/#517-super-washing-machines-starstarstar","text":"","title":"517. Super Washing Machines $\\star\\star\\star$"},{"location":"golang/0501-0600/0511-0520/#518-coin-change-2-starstar","text":"","title":"518. Coin Change 2 $\\star\\star$"},{"location":"golang/0501-0600/0511-0520/#519-random-flip-matrix-starstar","text":"","title":"519. Random Flip Matrix $\\star\\star$"},{"location":"golang/0501-0600/0511-0520/#520-detect-capital-star","text":"","title":"520. Detect Capital $\\star$"},{"location":"golang/0501-0600/0521-0530/","text":"521. Longest Uncommon Subsequence I $\\star$ 522. Longest Uncommon Subsequence II $\\star\\star$ 523. Continuous Subarray Sum $\\star\\star$ 524. Longest Word in Dictionary through Deleting $\\star\\star$ 525. Contiguous Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int findMaxLength ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int ans = 0 ; int sum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ] ? 1 : - 1 ; if ( sum == 0 ) { ans = i + 1 ; } else if ( map . count ( sum )) { ans = max ( ans , i - map [ sum ]); } else { map [ sum ] = i ; } } return ans ; } }; 526. Beautiful Arrangement $\\star\\star$ 527. Word Abbreviation $\\star\\star\\star$ 528. Random Pick with Weight $\\star\\star$ 529. Minesweeper $\\star\\star$ 530. Minimum Absolute Difference in BST $\\star$","title":"0521-0530"},{"location":"golang/0501-0600/0521-0530/#521-longest-uncommon-subsequence-i-star","text":"","title":"521. Longest Uncommon Subsequence I  $\\star$"},{"location":"golang/0501-0600/0521-0530/#522-longest-uncommon-subsequence-ii-starstar","text":"","title":"522. Longest Uncommon Subsequence II $\\star\\star$"},{"location":"golang/0501-0600/0521-0530/#523-continuous-subarray-sum-starstar","text":"","title":"523. Continuous Subarray Sum $\\star\\star$"},{"location":"golang/0501-0600/0521-0530/#524-longest-word-in-dictionary-through-deleting-starstar","text":"","title":"524. Longest Word in Dictionary through Deleting $\\star\\star$"},{"location":"golang/0501-0600/0521-0530/#525-contiguous-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int findMaxLength ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int ans = 0 ; int sum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ] ? 1 : - 1 ; if ( sum == 0 ) { ans = i + 1 ; } else if ( map . count ( sum )) { ans = max ( ans , i - map [ sum ]); } else { map [ sum ] = i ; } } return ans ; } };","title":"525. Contiguous Array $\\star\\star$"},{"location":"golang/0501-0600/0521-0530/#526-beautiful-arrangement-starstar","text":"","title":"526. Beautiful Arrangement $\\star\\star$"},{"location":"golang/0501-0600/0521-0530/#527-word-abbreviation-starstarstar","text":"","title":"527. Word Abbreviation $\\star\\star\\star$"},{"location":"golang/0501-0600/0521-0530/#528-random-pick-with-weight-starstar","text":"","title":"528. Random Pick with Weight $\\star\\star$"},{"location":"golang/0501-0600/0521-0530/#529-minesweeper-starstar","text":"","title":"529. Minesweeper $\\star\\star$"},{"location":"golang/0501-0600/0521-0530/#530-minimum-absolute-difference-in-bst-star","text":"","title":"530. Minimum Absolute Difference in BST $\\star$"},{"location":"golang/0501-0600/0531-0540/","text":"531. Lonely Pixel I $\\star\\star$ 532. K-diff Pairs in an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int findPairs ( vector < int >& nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) map [ nums [ i ]] = i ; for ( int i = 0 ; i < nums . size (); ++ i ) { int target = nums [ i ] + k ; if ( map . count ( target ) && map [ target ] != i ) { ++ ans ; map . erase ( target ); } } return ans ; } }; 533. Lonely Pixel II $\\star\\star$ 534. Game Play Analysis III $\\star\\star$ 535. Encode and Decode TinyURL $\\star\\star$ 536. Construct Binary Tree from String $\\star\\star$ 537. Complex Number Multiplication $\\star\\star$ 538. Convert BST to Greater Tree $\\star$ 539. Minimum Time Difference $\\star\\star$ 540. Single Element in a Sorted Array $\\star\\star$","title":"0531-0540"},{"location":"golang/0501-0600/0531-0540/#531-lonely-pixel-i-starstar","text":"","title":"531. Lonely Pixel I $\\star\\star$"},{"location":"golang/0501-0600/0531-0540/#532-k-diff-pairs-in-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int findPairs ( vector < int >& nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); ++ i ) map [ nums [ i ]] = i ; for ( int i = 0 ; i < nums . size (); ++ i ) { int target = nums [ i ] + k ; if ( map . count ( target ) && map [ target ] != i ) { ++ ans ; map . erase ( target ); } } return ans ; } };","title":"532. K-diff Pairs in an Array $\\star$"},{"location":"golang/0501-0600/0531-0540/#533-lonely-pixel-ii-starstar","text":"","title":"533. Lonely Pixel II $\\star\\star$"},{"location":"golang/0501-0600/0531-0540/#534-game-play-analysis-iii-starstar","text":"","title":"534. Game Play Analysis III $\\star\\star$"},{"location":"golang/0501-0600/0531-0540/#535-encode-and-decode-tinyurl-starstar","text":"","title":"535. Encode and Decode TinyURL $\\star\\star$"},{"location":"golang/0501-0600/0531-0540/#536-construct-binary-tree-from-string-starstar","text":"","title":"536. Construct Binary Tree from String $\\star\\star$"},{"location":"golang/0501-0600/0531-0540/#537-complex-number-multiplication-starstar","text":"","title":"537. Complex Number Multiplication $\\star\\star$"},{"location":"golang/0501-0600/0531-0540/#538-convert-bst-to-greater-tree-star","text":"","title":"538. Convert BST to Greater Tree $\\star$"},{"location":"golang/0501-0600/0531-0540/#539-minimum-time-difference-starstar","text":"","title":"539. Minimum Time Difference $\\star\\star$"},{"location":"golang/0501-0600/0531-0540/#540-single-element-in-a-sorted-array-starstar","text":"","title":"540. Single Element in a Sorted Array $\\star\\star$"},{"location":"golang/0501-0600/0541-0550/","text":"541. Reverse String II $\\star$ 542. 01 Matrix $\\star\\star$ 543. Diameter of Binary Tree $\\star$ 544. Output Contest Matches $\\star\\star$ 545. Boundary of Binary Tree $\\star\\star$ 546. Remove Boxes $\\star\\star\\star$ 547. Friend Circles $\\star\\star$ 548. Split Array with Equal Sum $\\star\\star$ 549. Binary Tree Longest Consecutive Sequence II $\\star\\star$ 550. Game Play Analysis IV $\\star\\star$","title":"0541-0550"},{"location":"golang/0501-0600/0541-0550/#541-reverse-string-ii-star","text":"","title":"541. Reverse String II $\\star$"},{"location":"golang/0501-0600/0541-0550/#542-01-matrix-starstar","text":"","title":"542. 01 Matrix $\\star\\star$"},{"location":"golang/0501-0600/0541-0550/#543-diameter-of-binary-tree-star","text":"","title":"543. Diameter of Binary Tree $\\star$"},{"location":"golang/0501-0600/0541-0550/#544-output-contest-matches-starstar","text":"","title":"544. Output Contest Matches $\\star\\star$"},{"location":"golang/0501-0600/0541-0550/#545-boundary-of-binary-tree-starstar","text":"","title":"545. Boundary of Binary Tree $\\star\\star$"},{"location":"golang/0501-0600/0541-0550/#546-remove-boxes-starstarstar","text":"","title":"546. Remove Boxes $\\star\\star\\star$"},{"location":"golang/0501-0600/0541-0550/#547-friend-circles-starstar","text":"","title":"547. Friend Circles $\\star\\star$"},{"location":"golang/0501-0600/0541-0550/#548-split-array-with-equal-sum-starstar","text":"","title":"548. Split Array with Equal Sum $\\star\\star$"},{"location":"golang/0501-0600/0541-0550/#549-binary-tree-longest-consecutive-sequence-ii-starstar","text":"","title":"549. Binary Tree Longest Consecutive Sequence II $\\star\\star$"},{"location":"golang/0501-0600/0541-0550/#550-game-play-analysis-iv-starstar","text":"","title":"550. Game Play Analysis IV $\\star\\star$"},{"location":"golang/0501-0600/0551-0560/","text":"551. Student Attendance Record I $\\star$ 552. Student Attendance Record II $\\star\\star\\star$ 553. Optimal Division $\\star\\star$ 554. Brick Wall $\\star\\star$ 555. Split Concatenated Strings $\\star\\star$ 556. Next Greater Element III $\\star\\star$ 557. Reverse Words in a String III $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string reverseWords ( string s ) { int i = 0 ; int j = 0 ; while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( s . begin () + i , s . begin () + j ); } return s ; } }; 558. Quad Tree Intersection $\\star$ 559. Maximum Depth of N-ary Tree $\\star$ 560. Subarray Sum Equals K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraySum ( vector < int >& nums , int k ) { int ans = 0 ; int sum = 0 ; unordered_map < int , int > map ; map [ 0 ] = 1 ; for ( int num : nums ) { sum += num ; ans += map [ sum - k ]; ++ map [ sum ]; } return ans ; } };","title":"0551-0560"},{"location":"golang/0501-0600/0551-0560/#551-student-attendance-record-i-star","text":"","title":"551. Student Attendance Record I $\\star$"},{"location":"golang/0501-0600/0551-0560/#552-student-attendance-record-ii-starstarstar","text":"","title":"552. Student Attendance Record II $\\star\\star\\star$"},{"location":"golang/0501-0600/0551-0560/#553-optimal-division-starstar","text":"","title":"553. Optimal Division $\\star\\star$"},{"location":"golang/0501-0600/0551-0560/#554-brick-wall-starstar","text":"","title":"554. Brick Wall $\\star\\star$"},{"location":"golang/0501-0600/0551-0560/#555-split-concatenated-strings-starstar","text":"","title":"555. Split Concatenated Strings $\\star\\star$"},{"location":"golang/0501-0600/0551-0560/#556-next-greater-element-iii-starstar","text":"","title":"556. Next Greater Element III $\\star\\star$"},{"location":"golang/0501-0600/0551-0560/#557-reverse-words-in-a-string-iii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string reverseWords ( string s ) { int i = 0 ; int j = 0 ; while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) ++ i ; while ( j < i || j < s . length () && s [ j ] != ' ' ) ++ j ; reverse ( s . begin () + i , s . begin () + j ); } return s ; } };","title":"557. Reverse Words in a String III $\\star$"},{"location":"golang/0501-0600/0551-0560/#558-quad-tree-intersection-star","text":"","title":"558. Quad Tree Intersection $\\star$"},{"location":"golang/0501-0600/0551-0560/#559-maximum-depth-of-n-ary-tree-star","text":"","title":"559. Maximum Depth of N-ary Tree $\\star$"},{"location":"golang/0501-0600/0551-0560/#560-subarray-sum-equals-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraySum ( vector < int >& nums , int k ) { int ans = 0 ; int sum = 0 ; unordered_map < int , int > map ; map [ 0 ] = 1 ; for ( int num : nums ) { sum += num ; ans += map [ sum - k ]; ++ map [ sum ]; } return ans ; } };","title":"560. Subarray Sum Equals K $\\star\\star$"},{"location":"golang/0501-0600/0561-0570/","text":"561. Array Partition I $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int arrayPairSum ( vector < int >& nums ) { int ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < nums . size (); i += 2 ) ans += nums [ i ]; return ans ; } }; 562. Longest Line of Consecutive One in Matrix $\\star\\star$ 563. Binary Tree Tilt $\\star$ 564. Find the Closest Palindrome $\\star\\star\\star$ 565. Array Nesting $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int arrayNesting ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ]; nums [ temp ] = - 1 ; ++ count ; } ans = max ( ans , count ); } return ans ; } }; 566. Reshape the Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < vector < int >> matrixReshape ( vector < vector < int >>& nums , int r , int c ) { if ( nums . empty () || r * c != nums . size () * nums [ 0 ]. size ()) return nums ; vector < vector < int >> ans ( r , vector < int > ( c )); int k = 0 ; for ( vector < int >& row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; ++ k ; } return ans ; } }; 567. Permutation in String $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool checkInclusion ( string s1 , string s2 ) { const int m = s1 . length (); const int n = s2 . length (); vector < int > map1 ( 26 ); vector < int > map2 ( 26 ); for ( char c : s1 ) ++ map1 [ c - 'a' ]; for ( int i = 0 ; i < n ; ++ i ) { if ( i >= m ) -- map2 [ s2 [ i - m ] - 'a' ]; ++ map2 [ s2 [ i ] - 'a' ]; if ( map1 == map2 ) return true ; } return false ; } }; 568. Maximum Vacation Days $\\star\\star\\star$ 569. Median Employee Salary $\\star\\star\\star$ 570. Managers with at Least 5 Direct Reports $\\star\\star$","title":"0561-0570"},{"location":"golang/0501-0600/0561-0570/#561-array-partition-i-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int arrayPairSum ( vector < int >& nums ) { int ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < nums . size (); i += 2 ) ans += nums [ i ]; return ans ; } };","title":"561. Array Partition I $\\star$"},{"location":"golang/0501-0600/0561-0570/#562-longest-line-of-consecutive-one-in-matrix-starstar","text":"","title":"562. Longest Line of Consecutive One in Matrix $\\star\\star$"},{"location":"golang/0501-0600/0561-0570/#563-binary-tree-tilt-star","text":"","title":"563. Binary Tree Tilt $\\star$"},{"location":"golang/0501-0600/0561-0570/#564-find-the-closest-palindrome-starstarstar","text":"","title":"564. Find the Closest Palindrome $\\star\\star\\star$"},{"location":"golang/0501-0600/0561-0570/#565-array-nesting-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int arrayNesting ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ]; nums [ temp ] = - 1 ; ++ count ; } ans = max ( ans , count ); } return ans ; } };","title":"565. Array Nesting $\\star\\star$"},{"location":"golang/0501-0600/0561-0570/#566-reshape-the-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < vector < int >> matrixReshape ( vector < vector < int >>& nums , int r , int c ) { if ( nums . empty () || r * c != nums . size () * nums [ 0 ]. size ()) return nums ; vector < vector < int >> ans ( r , vector < int > ( c )); int k = 0 ; for ( vector < int >& row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; ++ k ; } return ans ; } };","title":"566. Reshape the Matrix $\\star$"},{"location":"golang/0501-0600/0561-0570/#567-permutation-in-string-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool checkInclusion ( string s1 , string s2 ) { const int m = s1 . length (); const int n = s2 . length (); vector < int > map1 ( 26 ); vector < int > map2 ( 26 ); for ( char c : s1 ) ++ map1 [ c - 'a' ]; for ( int i = 0 ; i < n ; ++ i ) { if ( i >= m ) -- map2 [ s2 [ i - m ] - 'a' ]; ++ map2 [ s2 [ i ] - 'a' ]; if ( map1 == map2 ) return true ; } return false ; } };","title":"567. Permutation in String $\\star\\star$"},{"location":"golang/0501-0600/0561-0570/#568-maximum-vacation-days-starstarstar","text":"","title":"568. Maximum Vacation Days $\\star\\star\\star$"},{"location":"golang/0501-0600/0561-0570/#569-median-employee-salary-starstarstar","text":"","title":"569. Median Employee Salary $\\star\\star\\star$"},{"location":"golang/0501-0600/0561-0570/#570-managers-with-at-least-5-direct-reports-starstar","text":"","title":"570. Managers with at Least 5 Direct Reports $\\star\\star$"},{"location":"golang/0501-0600/0571-0580/","text":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$ 572. Subtree of Another Tree $\\star$ 573. Squirrel Simulation $\\star\\star$ 574. Winning Candidate $\\star\\star$ 575. Distribute Candies $\\star$ 576. Out of Boundary Paths $\\star\\star$ 577. Employee Bonus $\\star$ 578. Get Highest Answer Rate Question $\\star\\star$ 579. Find Cumulative Salary of an Employee $\\star\\star\\star$ 580. Count Student Number in Departments $\\star\\star$","title":"0571-0580"},{"location":"golang/0501-0600/0571-0580/#571-find-median-given-frequency-of-numbers-starstarstar","text":"","title":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$"},{"location":"golang/0501-0600/0571-0580/#572-subtree-of-another-tree-star","text":"","title":"572. Subtree of Another Tree $\\star$"},{"location":"golang/0501-0600/0571-0580/#573-squirrel-simulation-starstar","text":"","title":"573. Squirrel Simulation $\\star\\star$"},{"location":"golang/0501-0600/0571-0580/#574-winning-candidate-starstar","text":"","title":"574. Winning Candidate $\\star\\star$"},{"location":"golang/0501-0600/0571-0580/#575-distribute-candies-star","text":"","title":"575. Distribute Candies $\\star$"},{"location":"golang/0501-0600/0571-0580/#576-out-of-boundary-paths-starstar","text":"","title":"576. Out of Boundary Paths $\\star\\star$"},{"location":"golang/0501-0600/0571-0580/#577-employee-bonus-star","text":"","title":"577. Employee Bonus $\\star$"},{"location":"golang/0501-0600/0571-0580/#578-get-highest-answer-rate-question-starstar","text":"","title":"578. Get Highest Answer Rate Question $\\star\\star$"},{"location":"golang/0501-0600/0571-0580/#579-find-cumulative-salary-of-an-employee-starstarstar","text":"","title":"579. Find Cumulative Salary of an Employee $\\star\\star\\star$"},{"location":"golang/0501-0600/0571-0580/#580-count-student-number-in-departments-starstar","text":"","title":"580. Count Student Number in Departments $\\star\\star$"},{"location":"golang/0501-0600/0581-0590/","text":"581. Shortest Unsorted Continuous Subarray $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int findUnsortedSubarray ( vector < int >& nums ) { int min = INT_MAX ; int max = INT_MIN ; bool flag = false ; for ( int i = 1 ; i < nums . size (); ++ i ) { if ( nums [ i ] < nums [ i - 1 ]) flag = true ; if ( flag ) min = std :: min ( min , nums [ i ]); } flag = false ; for ( int i = nums . size () - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ]) flag = true ; if ( flag ) max = std :: max ( max , nums [ i ]); } int l ; for ( l = 0 ; l < nums . size (); ++ l ) if ( nums [ l ] > min ) break ; int r ; for ( r = nums . size () - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } }; 582. Kill Process $\\star\\star$ 583. Delete Operation for Two Strings $\\star\\star$ 584. Find Customer Referee $\\star$ 585. Investments in 2016 $\\star\\star$ 586. Customer Placing the Largest Number of Orders $\\star$ 587. Erect the Fence $\\star\\star\\star$ 588. Design In-Memory File System $\\star\\star\\star$ 589. N-ary Tree Preorder Traversal $\\star$ 590. N-ary Tree Postorder Traversal $\\star$","title":"0581-0590"},{"location":"golang/0501-0600/0581-0590/#581-shortest-unsorted-continuous-subarray-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int findUnsortedSubarray ( vector < int >& nums ) { int min = INT_MAX ; int max = INT_MIN ; bool flag = false ; for ( int i = 1 ; i < nums . size (); ++ i ) { if ( nums [ i ] < nums [ i - 1 ]) flag = true ; if ( flag ) min = std :: min ( min , nums [ i ]); } flag = false ; for ( int i = nums . size () - 2 ; i >= 0 ; -- i ) { if ( nums [ i ] > nums [ i + 1 ]) flag = true ; if ( flag ) max = std :: max ( max , nums [ i ]); } int l ; for ( l = 0 ; l < nums . size (); ++ l ) if ( nums [ l ] > min ) break ; int r ; for ( r = nums . size () - 1 ; r >= 0 ; -- r ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } };","title":"581. Shortest Unsorted Continuous Subarray $\\star$"},{"location":"golang/0501-0600/0581-0590/#582-kill-process-starstar","text":"","title":"582. Kill Process $\\star\\star$"},{"location":"golang/0501-0600/0581-0590/#583-delete-operation-for-two-strings-starstar","text":"","title":"583. Delete Operation for Two Strings $\\star\\star$"},{"location":"golang/0501-0600/0581-0590/#584-find-customer-referee-star","text":"","title":"584. Find Customer Referee $\\star$"},{"location":"golang/0501-0600/0581-0590/#585-investments-in-2016-starstar","text":"","title":"585. Investments in 2016 $\\star\\star$"},{"location":"golang/0501-0600/0581-0590/#586-customer-placing-the-largest-number-of-orders-star","text":"","title":"586. Customer Placing the Largest Number of Orders $\\star$"},{"location":"golang/0501-0600/0581-0590/#587-erect-the-fence-starstarstar","text":"","title":"587. Erect the Fence $\\star\\star\\star$"},{"location":"golang/0501-0600/0581-0590/#588-design-in-memory-file-system-starstarstar","text":"","title":"588. Design In-Memory File System $\\star\\star\\star$"},{"location":"golang/0501-0600/0581-0590/#589-n-ary-tree-preorder-traversal-star","text":"","title":"589. N-ary Tree Preorder Traversal $\\star$"},{"location":"golang/0501-0600/0581-0590/#590-n-ary-tree-postorder-traversal-star","text":"","title":"590. N-ary Tree Postorder Traversal $\\star$"},{"location":"golang/0501-0600/0591-0600/","text":"591. Tag Validator $\\star\\star\\star$ 592. Fraction Addition and Subtraction $\\star\\star$ 593. Valid Square $\\star\\star$ 594. Longest Harmonious Subsequence $\\star$ 595. Big Countries $\\star$ 596. Classes More Than 5 Students $\\star$ 597. Friend Requests I: Overall Acceptance Rate $\\star$ 598. Range Addition II $\\star$ 599. Minimum Index Sum of Two Lists $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < string > findRestaurant ( vector < string >& list1 , vector < string >& list2 ) { vector < string > ans ; unordered_map < string , int > map ; for ( int i = 0 ; i < list1 . size (); ++ i ) map [ list1 [ i ]] = i ; int min = INT_MAX ; for ( int i = 0 ; i < list2 . size (); ++ i ) { if ( ! map . count ( list2 [ i ])) continue ; int sum = map [ list2 [ i ]] + i ; if ( sum < min ) ans . clear (); if ( sum <= min ) { min = sum ; ans . push_back ( list2 [ i ]); } } return ans ; } }; 600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$","title":"0591-0600"},{"location":"golang/0501-0600/0591-0600/#591-tag-validator-starstarstar","text":"","title":"591. Tag Validator $\\star\\star\\star$"},{"location":"golang/0501-0600/0591-0600/#592-fraction-addition-and-subtraction-starstar","text":"","title":"592. Fraction Addition and Subtraction $\\star\\star$"},{"location":"golang/0501-0600/0591-0600/#593-valid-square-starstar","text":"","title":"593. Valid Square $\\star\\star$"},{"location":"golang/0501-0600/0591-0600/#594-longest-harmonious-subsequence-star","text":"","title":"594. Longest Harmonious Subsequence $\\star$"},{"location":"golang/0501-0600/0591-0600/#595-big-countries-star","text":"","title":"595. Big Countries $\\star$"},{"location":"golang/0501-0600/0591-0600/#596-classes-more-than-5-students-star","text":"","title":"596. Classes More Than 5 Students $\\star$"},{"location":"golang/0501-0600/0591-0600/#597-friend-requests-i-overall-acceptance-rate-star","text":"","title":"597. Friend Requests I: Overall Acceptance Rate $\\star$"},{"location":"golang/0501-0600/0591-0600/#598-range-addition-ii-star","text":"","title":"598. Range Addition II $\\star$"},{"location":"golang/0501-0600/0591-0600/#599-minimum-index-sum-of-two-lists-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < string > findRestaurant ( vector < string >& list1 , vector < string >& list2 ) { vector < string > ans ; unordered_map < string , int > map ; for ( int i = 0 ; i < list1 . size (); ++ i ) map [ list1 [ i ]] = i ; int min = INT_MAX ; for ( int i = 0 ; i < list2 . size (); ++ i ) { if ( ! map . count ( list2 [ i ])) continue ; int sum = map [ list2 [ i ]] + i ; if ( sum < min ) ans . clear (); if ( sum <= min ) { min = sum ; ans . push_back ( list2 [ i ]); } } return ans ; } };","title":"599. Minimum Index Sum of Two Lists $\\star$"},{"location":"golang/0501-0600/0591-0600/#600-non-negative-integers-without-consecutive-ones-starstarstar","text":"","title":"600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$"},{"location":"golang/0601-0700/0601-0610/","text":"601. Human Traffic of Stadium $\\star\\star\\star$ 602. Friend Requests II: Who Has the Most Friends $\\star\\star$ 603. Consecutive Available Seats $\\star$ 604. Design Compressed String Iterator $\\star$ 605. Can Place Flowers $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canPlaceFlowers ( vector < int >& flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . size (); ++ i ) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . size () - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; -- n ; } if ( n <= 0 ) return true ; } return false ; } }; 606. Construct String from Binary Tree $\\star$ 607. Sales Person $\\star$ 608. Tree Node $\\star\\star$ 609. Find Duplicate File in System $\\star\\star$ 610. Triangle Judgement $\\star$","title":"0601-0610"},{"location":"golang/0601-0700/0601-0610/#601-human-traffic-of-stadium-starstarstar","text":"","title":"601. Human Traffic of Stadium $\\star\\star\\star$"},{"location":"golang/0601-0700/0601-0610/#602-friend-requests-ii-who-has-the-most-friends-starstar","text":"","title":"602. Friend Requests II: Who Has the Most Friends $\\star\\star$"},{"location":"golang/0601-0700/0601-0610/#603-consecutive-available-seats-star","text":"","title":"603. Consecutive Available Seats $\\star$"},{"location":"golang/0601-0700/0601-0610/#604-design-compressed-string-iterator-star","text":"","title":"604. Design Compressed String Iterator $\\star$"},{"location":"golang/0601-0700/0601-0610/#605-can-place-flowers-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canPlaceFlowers ( vector < int >& flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . size (); ++ i ) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . size () - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; -- n ; } if ( n <= 0 ) return true ; } return false ; } };","title":"605. Can Place Flowers $\\star$"},{"location":"golang/0601-0700/0601-0610/#606-construct-string-from-binary-tree-star","text":"","title":"606. Construct String from Binary Tree $\\star$"},{"location":"golang/0601-0700/0601-0610/#607-sales-person-star","text":"","title":"607. Sales Person $\\star$"},{"location":"golang/0601-0700/0601-0610/#608-tree-node-starstar","text":"","title":"608. Tree Node $\\star\\star$"},{"location":"golang/0601-0700/0601-0610/#609-find-duplicate-file-in-system-starstar","text":"","title":"609. Find Duplicate File in System $\\star\\star$"},{"location":"golang/0601-0700/0601-0610/#610-triangle-judgement-star","text":"","title":"610. Triangle Judgement $\\star$"},{"location":"golang/0601-0700/0611-0620/","text":"611. Valid Triangle Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int triangleNumber ( vector < int >& nums ) { int ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int k = nums . size () - 1 ; k > 1 ; -- k ) for ( int i = 0 , j = k - 1 ; i < j ;) { if ( nums [ i ] + nums [ j ] > nums [ k ]) { ans += j - i ; -- j ; } else ++ i ; } return ans ; } }; 612. Shortest Distance in a Plane $\\star\\star$ 613. Shortest Distance in a Line $\\star$ 614. Second Degree Follower $\\star\\star$ 615. Average Salary: Departments VS Company $\\star\\star\\star$ 616. Add Bold Tag in String $\\star\\star$ 617. Merge Two Binary Trees $\\star$ 618. Students Report By Geography $\\star\\star\\star$ 619. Biggest Single Number $\\star$ 620. Not Boring Movies $\\star$","title":"0611-0620"},{"location":"golang/0601-0700/0611-0620/#611-valid-triangle-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int triangleNumber ( vector < int >& nums ) { int ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int k = nums . size () - 1 ; k > 1 ; -- k ) for ( int i = 0 , j = k - 1 ; i < j ;) { if ( nums [ i ] + nums [ j ] > nums [ k ]) { ans += j - i ; -- j ; } else ++ i ; } return ans ; } };","title":"611. Valid Triangle Number $\\star\\star$"},{"location":"golang/0601-0700/0611-0620/#612-shortest-distance-in-a-plane-starstar","text":"","title":"612. Shortest Distance in a Plane $\\star\\star$"},{"location":"golang/0601-0700/0611-0620/#613-shortest-distance-in-a-line-star","text":"","title":"613. Shortest Distance in a Line $\\star$"},{"location":"golang/0601-0700/0611-0620/#614-second-degree-follower-starstar","text":"","title":"614. Second Degree Follower $\\star\\star$"},{"location":"golang/0601-0700/0611-0620/#615-average-salary-departments-vs-company-starstarstar","text":"","title":"615. Average Salary: Departments VS Company $\\star\\star\\star$"},{"location":"golang/0601-0700/0611-0620/#616-add-bold-tag-in-string-starstar","text":"","title":"616. Add Bold Tag in String $\\star\\star$"},{"location":"golang/0601-0700/0611-0620/#617-merge-two-binary-trees-star","text":"","title":"617. Merge Two Binary Trees $\\star$"},{"location":"golang/0601-0700/0611-0620/#618-students-report-by-geography-starstarstar","text":"","title":"618. Students Report By Geography $\\star\\star\\star$"},{"location":"golang/0601-0700/0611-0620/#619-biggest-single-number-star","text":"","title":"619. Biggest Single Number $\\star$"},{"location":"golang/0601-0700/0611-0620/#620-not-boring-movies-star","text":"","title":"620. Not Boring Movies $\\star$"},{"location":"golang/0601-0700/0621-0630/","text":"621. Task Scheduler $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int leastInterval ( vector < char >& tasks , int n ) { vector < int > count ( 26 , 0 ); for ( char task : tasks ) ++ count [ task - 'A' ]; const int maxCount = * max_element ( count . begin (), count . end ()); int ans = ( maxCount - 1 ) * ( n + 1 ); ans += count_if ( count . begin (), count . end (), [ maxCount ]( int freq ) { return freq == maxCount ; }); return max ( ans , ( int ) tasks . size ()); } }; 622. Design Circular Queue $\\star\\star$ 623. Add One Row to Tree $\\star\\star$ 624. Maximum Distance in Arrays $\\star$ 625. Minimum Factorization $\\star\\star$ 626. Exchange Seats $\\star\\star$ 627. Swap Salary $\\star$ 628. Maximum Product of Three Numbers $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int maximumProduct ( vector < int >& nums ) { int min = INT_MAX ; int secondMin = INT_MAX ; int max = INT_MIN ; int secondMax = INT_MIN ; int thirdMax = INT_MIN ; for ( int num : nums ) { if ( num <= min ) { secondMin = min ; min = num ; } else if ( num <= secondMin ) secondMin = num ; if ( num >= max ) { thirdMax = secondMax ; secondMax = max ; max = num ; } else if ( num >= secondMax ) { thirdMax = secondMax ; secondMax = num ; } else if ( num >= thirdMax ) thirdMax = num ; } return std :: max ( min * secondMin * max , max * secondMax * thirdMax ); } }; 629. K Inverse Pairs Array $\\star\\star\\star$ 630. Course Schedule III $\\star\\star\\star$","title":"0621-0630"},{"location":"golang/0601-0700/0621-0630/#621-task-scheduler-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int leastInterval ( vector < char >& tasks , int n ) { vector < int > count ( 26 , 0 ); for ( char task : tasks ) ++ count [ task - 'A' ]; const int maxCount = * max_element ( count . begin (), count . end ()); int ans = ( maxCount - 1 ) * ( n + 1 ); ans += count_if ( count . begin (), count . end (), [ maxCount ]( int freq ) { return freq == maxCount ; }); return max ( ans , ( int ) tasks . size ()); } };","title":"621. Task Scheduler $\\star\\star$"},{"location":"golang/0601-0700/0621-0630/#622-design-circular-queue-starstar","text":"","title":"622. Design Circular Queue $\\star\\star$"},{"location":"golang/0601-0700/0621-0630/#623-add-one-row-to-tree-starstar","text":"","title":"623. Add One Row to Tree $\\star\\star$"},{"location":"golang/0601-0700/0621-0630/#624-maximum-distance-in-arrays-star","text":"","title":"624. Maximum Distance in Arrays $\\star$"},{"location":"golang/0601-0700/0621-0630/#625-minimum-factorization-starstar","text":"","title":"625. Minimum Factorization $\\star\\star$"},{"location":"golang/0601-0700/0621-0630/#626-exchange-seats-starstar","text":"","title":"626. Exchange Seats $\\star\\star$"},{"location":"golang/0601-0700/0621-0630/#627-swap-salary-star","text":"","title":"627. Swap Salary $\\star$"},{"location":"golang/0601-0700/0621-0630/#628-maximum-product-of-three-numbers-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int maximumProduct ( vector < int >& nums ) { int min = INT_MAX ; int secondMin = INT_MAX ; int max = INT_MIN ; int secondMax = INT_MIN ; int thirdMax = INT_MIN ; for ( int num : nums ) { if ( num <= min ) { secondMin = min ; min = num ; } else if ( num <= secondMin ) secondMin = num ; if ( num >= max ) { thirdMax = secondMax ; secondMax = max ; max = num ; } else if ( num >= secondMax ) { thirdMax = secondMax ; secondMax = num ; } else if ( num >= thirdMax ) thirdMax = num ; } return std :: max ( min * secondMin * max , max * secondMax * thirdMax ); } };","title":"628. Maximum Product of Three Numbers $\\star$"},{"location":"golang/0601-0700/0621-0630/#629-k-inverse-pairs-array-starstarstar","text":"","title":"629. K Inverse Pairs Array $\\star\\star\\star$"},{"location":"golang/0601-0700/0621-0630/#630-course-schedule-iii-starstarstar","text":"","title":"630. Course Schedule III $\\star\\star\\star$"},{"location":"golang/0601-0700/0631-0640/","text":"631. Design Excel Sum Formula $\\star\\star\\star$ 632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$ 633. Sum of Square Numbers $\\star$ 634. Find the Derangement of An Array $\\star\\star$ 635. Design Log Storage System $\\star\\star$ 636. Exclusive Time of Functions $\\star\\star$ 637. Average of Levels in Binary Tree $\\star$ 638. Shopping Offers $\\star\\star$ 639. Decode Ways II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int numDecodings ( string s ) { if ( s . empty ()) return 0 ; long dp1 = count ( s [ 0 ]); long dp2 = 1 ; for ( int i = 1 ; i < s . length (); ++ i ) { long dp = count ( s [ i ]) * dp1 + count ( s [ i - 1 ], s [ i ]) * dp2 ; dp %= int ( 1e9 + 7 ); dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : int count ( char c ) { if ( c == '*' ) return 9 ; return c != '0' ; } int count ( char c1 , char c2 ) { if ( c1 == '*' && c2 == '*' ) return 15 ; if ( c1 == '*' ) return ( c2 >= '0' && c2 <= '6' ) ? 2 : 1 ; if ( c2 == '*' ) { if ( c1 == '1' ) return 9 ; if ( c1 == '2' ) return 6 ; return 0 ; } return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } }; 640. Solve the Equation $\\star\\star$","title":"0631-0640"},{"location":"golang/0601-0700/0631-0640/#631-design-excel-sum-formula-starstarstar","text":"","title":"631. Design Excel Sum Formula $\\star\\star\\star$"},{"location":"golang/0601-0700/0631-0640/#632-smallest-range-covering-elements-from-k-lists-starstarstar","text":"","title":"632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$"},{"location":"golang/0601-0700/0631-0640/#633-sum-of-square-numbers-star","text":"","title":"633. Sum of Square Numbers $\\star$"},{"location":"golang/0601-0700/0631-0640/#634-find-the-derangement-of-an-array-starstar","text":"","title":"634. Find the Derangement of An Array $\\star\\star$"},{"location":"golang/0601-0700/0631-0640/#635-design-log-storage-system-starstar","text":"","title":"635. Design Log Storage System $\\star\\star$"},{"location":"golang/0601-0700/0631-0640/#636-exclusive-time-of-functions-starstar","text":"","title":"636. Exclusive Time of Functions $\\star\\star$"},{"location":"golang/0601-0700/0631-0640/#637-average-of-levels-in-binary-tree-star","text":"","title":"637. Average of Levels in Binary Tree $\\star$"},{"location":"golang/0601-0700/0631-0640/#638-shopping-offers-starstar","text":"","title":"638. Shopping Offers $\\star\\star$"},{"location":"golang/0601-0700/0631-0640/#639-decode-ways-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int numDecodings ( string s ) { if ( s . empty ()) return 0 ; long dp1 = count ( s [ 0 ]); long dp2 = 1 ; for ( int i = 1 ; i < s . length (); ++ i ) { long dp = count ( s [ i ]) * dp1 + count ( s [ i - 1 ], s [ i ]) * dp2 ; dp %= int ( 1e9 + 7 ); dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : int count ( char c ) { if ( c == '*' ) return 9 ; return c != '0' ; } int count ( char c1 , char c2 ) { if ( c1 == '*' && c2 == '*' ) return 15 ; if ( c1 == '*' ) return ( c2 >= '0' && c2 <= '6' ) ? 2 : 1 ; if ( c2 == '*' ) { if ( c1 == '1' ) return 9 ; if ( c1 == '2' ) return 6 ; return 0 ; } return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } };","title":"639. Decode Ways II $\\star\\star\\star$"},{"location":"golang/0601-0700/0631-0640/#640-solve-the-equation-starstar","text":"","title":"640. Solve the Equation $\\star\\star$"},{"location":"golang/0601-0700/0641-0650/","text":"641. Design Circular Deque $\\star\\star$ 642. Design Search Autocomplete System $\\star\\star\\star$ 643. Maximum Average Subarray I $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : double findMaxAverage ( vector < int >& nums , int k ) { double sum = accumulate ( nums . begin (), nums . begin () + k , 0 ); double ans = sum ; for ( int i = k ; i < nums . size (); ++ i ) { sum += nums [ i ] - nums [ i - k ]; ans = max ( ans , sum ); } return ans / k ; } }; 644. Maximum Average Subarray II $\\star\\star\\star$ 645. Set Mismatch $\\star$ 646. Maximum Length of Pair Chain $\\star\\star$ 647. Palindromic Substrings $\\star\\star$ 648. Replace Words $\\star\\star$ 649. Dota2 Senate $\\star\\star$ 650. 2 Keys Keyboard $\\star\\star$","title":"0641-0650"},{"location":"golang/0601-0700/0641-0650/#641-design-circular-deque-starstar","text":"","title":"641. Design Circular Deque $\\star\\star$"},{"location":"golang/0601-0700/0641-0650/#642-design-search-autocomplete-system-starstarstar","text":"","title":"642. Design Search Autocomplete System $\\star\\star\\star$"},{"location":"golang/0601-0700/0641-0650/#643-maximum-average-subarray-i-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : double findMaxAverage ( vector < int >& nums , int k ) { double sum = accumulate ( nums . begin (), nums . begin () + k , 0 ); double ans = sum ; for ( int i = k ; i < nums . size (); ++ i ) { sum += nums [ i ] - nums [ i - k ]; ans = max ( ans , sum ); } return ans / k ; } };","title":"643. Maximum Average Subarray I $\\star$"},{"location":"golang/0601-0700/0641-0650/#644-maximum-average-subarray-ii-starstarstar","text":"","title":"644. Maximum Average Subarray II $\\star\\star\\star$"},{"location":"golang/0601-0700/0641-0650/#645-set-mismatch-star","text":"","title":"645. Set Mismatch $\\star$"},{"location":"golang/0601-0700/0641-0650/#646-maximum-length-of-pair-chain-starstar","text":"","title":"646. Maximum Length of Pair Chain $\\star\\star$"},{"location":"golang/0601-0700/0641-0650/#647-palindromic-substrings-starstar","text":"","title":"647. Palindromic Substrings $\\star\\star$"},{"location":"golang/0601-0700/0641-0650/#648-replace-words-starstar","text":"","title":"648. Replace Words $\\star\\star$"},{"location":"golang/0601-0700/0641-0650/#649-dota2-senate-starstar","text":"","title":"649. Dota2 Senate $\\star\\star$"},{"location":"golang/0601-0700/0641-0650/#650-2-keys-keyboard-starstar","text":"","title":"650. 2 Keys Keyboard $\\star\\star$"},{"location":"golang/0601-0700/0651-0660/","text":"651. 4 Keys Keyboard $\\star\\star$ 652. Find Duplicate Subtrees $\\star\\star$ 653. Two Sum IV - Input is a BST $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool findTarget ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == k ) return true ; if ( sum < k ) ++ l ; else -- r ; } return false ; } void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } }; 654. Maximum Binary Tree $\\star\\star$ 655. Print Binary Tree $\\star\\star$ 656. Coin Path $\\star\\star\\star$ 657. Robot Return to Origin $\\star$ 658. Find K Closest Elements $\\star\\star$ 659. Split Array into Consecutive Subsequences $\\star\\star$ 660. Remove 9 $\\star\\star\\star$","title":"0651-0660"},{"location":"golang/0601-0700/0651-0660/#651-4-keys-keyboard-starstar","text":"","title":"651. 4 Keys Keyboard $\\star\\star$"},{"location":"golang/0601-0700/0651-0660/#652-find-duplicate-subtrees-starstar","text":"","title":"652. Find Duplicate Subtrees $\\star\\star$"},{"location":"golang/0601-0700/0651-0660/#653-two-sum-iv-input-is-a-bst-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool findTarget ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == k ) return true ; if ( sum < k ) ++ l ; else -- r ; } return false ; } void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } };","title":"653. Two Sum IV - Input is a BST $\\star$"},{"location":"golang/0601-0700/0651-0660/#654-maximum-binary-tree-starstar","text":"","title":"654. Maximum Binary Tree $\\star\\star$"},{"location":"golang/0601-0700/0651-0660/#655-print-binary-tree-starstar","text":"","title":"655. Print Binary Tree $\\star\\star$"},{"location":"golang/0601-0700/0651-0660/#656-coin-path-starstarstar","text":"","title":"656. Coin Path $\\star\\star\\star$"},{"location":"golang/0601-0700/0651-0660/#657-robot-return-to-origin-star","text":"","title":"657. Robot Return to Origin $\\star$"},{"location":"golang/0601-0700/0651-0660/#658-find-k-closest-elements-starstar","text":"","title":"658. Find K Closest Elements $\\star\\star$"},{"location":"golang/0601-0700/0651-0660/#659-split-array-into-consecutive-subsequences-starstar","text":"","title":"659. Split Array into Consecutive Subsequences $\\star\\star$"},{"location":"golang/0601-0700/0651-0660/#660-remove-9-starstarstar","text":"","title":"660. Remove 9 $\\star\\star\\star$"},{"location":"golang/0601-0700/0661-0670/","text":"661. Image Smoother $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> imageSmoother ( vector < vector < int >>& M ) { const int m = M . size (); const int n = M [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) { ones += M [ y ][ x ]; ++ count ; } ans [ i ][ j ] = ones / count ; } return ans ; } }; 662. Maximum Width of Binary Tree $\\star\\star$ 663. Equal Tree Partition $\\star\\star$ 664. Strange Printer $\\star\\star\\star$ 665. Non-decreasing Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool checkPossibility ( vector < int >& nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) if ( nums [ i ] > nums [ i + 1 ]) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . size () - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ]; } }; 666. Path Sum IV $\\star\\star$ 667. Beautiful Arrangement II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > constructArray ( int n , int k ) { vector < int > ans ; for ( int i = 0 ; i < n - k ; ++ i ) ans . push_back ( i + 1 ); for ( int i = 0 ; i < k ; ++ i ) { if ( i % 2 == 0 ) ans . push_back ( n - i / 2 ); else ans . push_back ( n - k + ( i + 1 ) / 2 ); } return ans ; } }; 668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$ 669. Trim a Binary Search Tree $\\star$ 670. Maximum Swap $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maximumSwap ( int num ) { string s = to_string ( num ); unordered_map < char , int > map ; for ( int i = 0 ; i < s . length (); ++ i ) map [ s [ i ]] = i ; for ( int i = 0 ; i < s . length (); ++ i ) for ( char digit = '9' ; digit > s [ i ]; -- digit ) if ( map [ digit ] > i ) { s [ map [ digit ]] = s [ i ]; s [ i ] = digit ; return stoi ( s ); } return num ; } };","title":"0661-0670"},{"location":"golang/0601-0700/0661-0670/#661-image-smoother-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> imageSmoother ( vector < vector < int >>& M ) { const int m = M . size (); const int n = M [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { int ones = 0 ; int count = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); ++ y ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); ++ x ) { ones += M [ y ][ x ]; ++ count ; } ans [ i ][ j ] = ones / count ; } return ans ; } };","title":"661. Image Smoother $\\star$"},{"location":"golang/0601-0700/0661-0670/#662-maximum-width-of-binary-tree-starstar","text":"","title":"662. Maximum Width of Binary Tree $\\star\\star$"},{"location":"golang/0601-0700/0661-0670/#663-equal-tree-partition-starstar","text":"","title":"663. Equal Tree Partition $\\star\\star$"},{"location":"golang/0601-0700/0661-0670/#664-strange-printer-starstarstar","text":"","title":"664. Strange Printer $\\star\\star\\star$"},{"location":"golang/0601-0700/0661-0670/#665-non-decreasing-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool checkPossibility ( vector < int >& nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . size (); ++ i ) if ( nums [ i ] > nums [ i + 1 ]) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . size () - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ]; } };","title":"665. Non-decreasing Array $\\star$"},{"location":"golang/0601-0700/0661-0670/#666-path-sum-iv-starstar","text":"","title":"666. Path Sum IV $\\star\\star$"},{"location":"golang/0601-0700/0661-0670/#667-beautiful-arrangement-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > constructArray ( int n , int k ) { vector < int > ans ; for ( int i = 0 ; i < n - k ; ++ i ) ans . push_back ( i + 1 ); for ( int i = 0 ; i < k ; ++ i ) { if ( i % 2 == 0 ) ans . push_back ( n - i / 2 ); else ans . push_back ( n - k + ( i + 1 ) / 2 ); } return ans ; } };","title":"667. Beautiful Arrangement II $\\star\\star$"},{"location":"golang/0601-0700/0661-0670/#668-kth-smallest-number-in-multiplication-table-starstarstar","text":"","title":"668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$"},{"location":"golang/0601-0700/0661-0670/#669-trim-a-binary-search-tree-star","text":"","title":"669. Trim a Binary Search Tree $\\star$"},{"location":"golang/0601-0700/0661-0670/#670-maximum-swap-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maximumSwap ( int num ) { string s = to_string ( num ); unordered_map < char , int > map ; for ( int i = 0 ; i < s . length (); ++ i ) map [ s [ i ]] = i ; for ( int i = 0 ; i < s . length (); ++ i ) for ( char digit = '9' ; digit > s [ i ]; -- digit ) if ( map [ digit ] > i ) { s [ map [ digit ]] = s [ i ]; s [ i ] = digit ; return stoi ( s ); } return num ; } };","title":"670. Maximum Swap $\\star\\star$"},{"location":"golang/0601-0700/0671-0680/","text":"671. Second Minimum Node In a Binary Tree $\\star$ 672. Bulb Switcher II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int flipLights ( int n , int m ) { n = min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return n == 1 ? 2 : n == 2 ? 3 : 4 ; if ( m == 2 ) return n == 1 ? 2 : n == 2 ? 4 : 7 ; return n == 1 ? 2 : n == 2 ? 4 : 8 ; } }; 673. Number of Longest Increasing Subsequence $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 func findNumberOfLIS ( nums [] int ) int { // return func1 ( nums ); return func2 ( nums ); } // iterative , from right to left func func1 ( nums [] int ) int { n : = len ( nums ); length : = make ( [] int , n ); count : = make ( [] int , n ); for i : = 0 ; i < n ; i ++ { length [ i ] = 1 ; count [ i ] = 1 ; } maxLen : = 1 ; for i : = n - 1 ; i >= 0 ; i -- { for j : = i + 1 ; j < n ; j ++ { if nums [ i ] < nums [ j ] { if length [ j ]+ 1 > length [ i ] { length [ i ] = length [ j ]+ 1 ; count [ i ] = count [ j ] ; } else if length [ j ]+ 1 == length [ i ] { count [ i ] += count [ j ] ; } } } // fmt . Printf ( \"i=%d, length=%d, count=%d\\n\" , i , length [ i ] , count [ i ] ); if length [ i ] > maxLen { maxLen = length [ i ] ; } } ret : = 0 ; for i : = 0 ; i < n ; i ++ { if length [ i ] == maxLen { ret += count [ i ] ; } } return ret ; } // iterative , from left to right func func2 ( nums [] int ) int { n : = len ( nums ); length : = make ( [] int , n ); count : = make ( [] int , n ); for i : = 0 ; i < n ; i ++ { length [ i ] = 1 ; count [ i ] = 1 ; } maxLen : = 1 ; for i : = 0 ; i < n ; i ++ { for j : = i - 1 ; j >= 0 ; j -- { if nums [ i ] > nums [ j ] { if length [ j ]+ 1 > length [ i ] { length [ i ] = length [ j ]+ 1 ; count [ i ] = count [ j ] ; } else if length [ j ]+ 1 == length [ i ] { count [ i ] += count [ j ] ; } } } if length [ i ] > maxLen { maxLen = length [ i ] ; } } ret : = 0 ; for i : = 0 ; i < n ; i ++ { if length [ i ] == maxLen { ret += count [ i ] ; } } return ret ; } 674. Longest Continuous Increasing Subsequence $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int findLengthOfLCIS ( vector < int >& nums ) { int ans = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ]) j = i ; ans = max ( ans , i - j + 1 ); } return ans ; } }; 675. Cut Off Trees for Golf Event $\\star\\star\\star$ 676. Implement Magic Dictionary $\\star\\star$ 677. Map Sum Pairs $\\star\\star$ 678. Valid Parenthesis String $\\star\\star$ 679. 24 Game $\\star\\star\\star$ 680. Valid Palindrome II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool validPalindrome ( string s ) { const int n = s . length (); for ( int i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] != s [ n - 1 - i ]) return validPalindrome ( s , i + 1 , n - 1 - i ) || validPalindrome ( s , i , n - 2 - i ); return true ; } private : bool validPalindrome ( string & s , int l , int r ) { for ( int i = l ; i <= l + ( r - l ) / 2 ; ++ i ) if ( s [ i ] != s [ r - i + l ]) return false ; return true ; } };","title":"0671-0680"},{"location":"golang/0601-0700/0671-0680/#671-second-minimum-node-in-a-binary-tree-star","text":"","title":"671. Second Minimum Node In a Binary Tree $\\star$"},{"location":"golang/0601-0700/0671-0680/#672-bulb-switcher-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int flipLights ( int n , int m ) { n = min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return n == 1 ? 2 : n == 2 ? 3 : 4 ; if ( m == 2 ) return n == 1 ? 2 : n == 2 ? 4 : 7 ; return n == 1 ? 2 : n == 2 ? 4 : 8 ; } };","title":"672. Bulb Switcher II $\\star\\star$"},{"location":"golang/0601-0700/0671-0680/#673-number-of-longest-increasing-subsequence-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 func findNumberOfLIS ( nums [] int ) int { // return func1 ( nums ); return func2 ( nums ); } // iterative , from right to left func func1 ( nums [] int ) int { n : = len ( nums ); length : = make ( [] int , n ); count : = make ( [] int , n ); for i : = 0 ; i < n ; i ++ { length [ i ] = 1 ; count [ i ] = 1 ; } maxLen : = 1 ; for i : = n - 1 ; i >= 0 ; i -- { for j : = i + 1 ; j < n ; j ++ { if nums [ i ] < nums [ j ] { if length [ j ]+ 1 > length [ i ] { length [ i ] = length [ j ]+ 1 ; count [ i ] = count [ j ] ; } else if length [ j ]+ 1 == length [ i ] { count [ i ] += count [ j ] ; } } } // fmt . Printf ( \"i=%d, length=%d, count=%d\\n\" , i , length [ i ] , count [ i ] ); if length [ i ] > maxLen { maxLen = length [ i ] ; } } ret : = 0 ; for i : = 0 ; i < n ; i ++ { if length [ i ] == maxLen { ret += count [ i ] ; } } return ret ; } // iterative , from left to right func func2 ( nums [] int ) int { n : = len ( nums ); length : = make ( [] int , n ); count : = make ( [] int , n ); for i : = 0 ; i < n ; i ++ { length [ i ] = 1 ; count [ i ] = 1 ; } maxLen : = 1 ; for i : = 0 ; i < n ; i ++ { for j : = i - 1 ; j >= 0 ; j -- { if nums [ i ] > nums [ j ] { if length [ j ]+ 1 > length [ i ] { length [ i ] = length [ j ]+ 1 ; count [ i ] = count [ j ] ; } else if length [ j ]+ 1 == length [ i ] { count [ i ] += count [ j ] ; } } } if length [ i ] > maxLen { maxLen = length [ i ] ; } } ret : = 0 ; for i : = 0 ; i < n ; i ++ { if length [ i ] == maxLen { ret += count [ i ] ; } } return ret ; }","title":"673. Number of Longest Increasing Subsequence $\\star\\star$"},{"location":"golang/0601-0700/0671-0680/#674-longest-continuous-increasing-subsequence-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int findLengthOfLCIS ( vector < int >& nums ) { int ans = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ]) j = i ; ans = max ( ans , i - j + 1 ); } return ans ; } };","title":"674. Longest Continuous Increasing Subsequence $\\star$"},{"location":"golang/0601-0700/0671-0680/#675-cut-off-trees-for-golf-event-starstarstar","text":"","title":"675. Cut Off Trees for Golf Event $\\star\\star\\star$"},{"location":"golang/0601-0700/0671-0680/#676-implement-magic-dictionary-starstar","text":"","title":"676. Implement Magic Dictionary $\\star\\star$"},{"location":"golang/0601-0700/0671-0680/#677-map-sum-pairs-starstar","text":"","title":"677. Map Sum Pairs $\\star\\star$"},{"location":"golang/0601-0700/0671-0680/#678-valid-parenthesis-string-starstar","text":"","title":"678. Valid Parenthesis String $\\star\\star$"},{"location":"golang/0601-0700/0671-0680/#679-24-game-starstarstar","text":"","title":"679. 24 Game $\\star\\star\\star$"},{"location":"golang/0601-0700/0671-0680/#680-valid-palindrome-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool validPalindrome ( string s ) { const int n = s . length (); for ( int i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] != s [ n - 1 - i ]) return validPalindrome ( s , i + 1 , n - 1 - i ) || validPalindrome ( s , i , n - 2 - i ); return true ; } private : bool validPalindrome ( string & s , int l , int r ) { for ( int i = l ; i <= l + ( r - l ) / 2 ; ++ i ) if ( s [ i ] != s [ r - i + l ]) return false ; return true ; } };","title":"680. Valid Palindrome II $\\star$"},{"location":"golang/0601-0700/0681-0690/","text":"681. Next Closest Time $\\star\\star$ 682. Baseball Game $\\star$ 683. K Empty Slots $\\star\\star\\star$ 684. Redundant Connection $\\star\\star$ 685. Redundant Connection II $\\star\\star\\star$ 686. Repeated String Match $\\star$ 687. Longest Univalue Path $\\star$ 688. Knight Probability in Chessboard $\\star\\star$ 689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : vector < int > maxSumOfThreeSubarrays ( vector < int >& nums , int k ) { vector < int > ans = { - 1 , - 1 , - 1 }; int subarrayCount = nums . size () - k + 1 ; vector < int > dp ( subarrayCount ); int sum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; if ( i >= k ) sum -= nums [ i - k ]; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } vector < int > left ( subarrayCount ); int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; ++ i ) { if ( dp [ i ] > dp [ maxIndex ]) maxIndex = i ; left [ i ] = maxIndex ; } vector < int > right ( subarrayCount ); maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; -- i ) { if ( dp [ i ] >= dp [ maxIndex ]) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; ++ i ) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]) ans = { left [ i - k ], i , right [ i + k ]}; return ans ; } }; 690. Employee Importance $\\star$","title":"0681-0690"},{"location":"golang/0601-0700/0681-0690/#681-next-closest-time-starstar","text":"","title":"681. Next Closest Time $\\star\\star$"},{"location":"golang/0601-0700/0681-0690/#682-baseball-game-star","text":"","title":"682. Baseball Game $\\star$"},{"location":"golang/0601-0700/0681-0690/#683-k-empty-slots-starstarstar","text":"","title":"683. K Empty Slots $\\star\\star\\star$"},{"location":"golang/0601-0700/0681-0690/#684-redundant-connection-starstar","text":"","title":"684. Redundant Connection $\\star\\star$"},{"location":"golang/0601-0700/0681-0690/#685-redundant-connection-ii-starstarstar","text":"","title":"685. Redundant Connection II $\\star\\star\\star$"},{"location":"golang/0601-0700/0681-0690/#686-repeated-string-match-star","text":"","title":"686. Repeated String Match $\\star$"},{"location":"golang/0601-0700/0681-0690/#687-longest-univalue-path-star","text":"","title":"687. Longest Univalue Path $\\star$"},{"location":"golang/0601-0700/0681-0690/#688-knight-probability-in-chessboard-starstar","text":"","title":"688. Knight Probability in Chessboard $\\star\\star$"},{"location":"golang/0601-0700/0681-0690/#689-maximum-sum-of-3-non-overlapping-subarrays-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : vector < int > maxSumOfThreeSubarrays ( vector < int >& nums , int k ) { vector < int > ans = { - 1 , - 1 , - 1 }; int subarrayCount = nums . size () - k + 1 ; vector < int > dp ( subarrayCount ); int sum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { sum += nums [ i ]; if ( i >= k ) sum -= nums [ i - k ]; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } vector < int > left ( subarrayCount ); int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; ++ i ) { if ( dp [ i ] > dp [ maxIndex ]) maxIndex = i ; left [ i ] = maxIndex ; } vector < int > right ( subarrayCount ); maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; -- i ) { if ( dp [ i ] >= dp [ maxIndex ]) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; ++ i ) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]) ans = { left [ i - k ], i , right [ i + k ]}; return ans ; } };","title":"689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$"},{"location":"golang/0601-0700/0681-0690/#690-employee-importance-star","text":"","title":"690. Employee Importance $\\star$"},{"location":"golang/0601-0700/0691-0700/","text":"691. Stickers to Spell Word $\\star\\star\\star$ 692. Top K Frequent Words $\\star\\star$ 693. Binary Number with Alternating Bits $\\star$ 694. Number of Distinct Islands $\\star\\star$ 695. Max Area of Island $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> visited ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = max ( ans , dfs ( grid , i , j , visited )); return ans ; } private : int dfs ( vector < vector < int >>& grid , int i , int j , vector < vector < bool >>& visited ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || visited [ i ][ j ] || grid [ i ][ j ] == 0 ) return 0 ; visited [ i ][ j ] = true ; return 1 + dfs ( grid , i + 1 , j , visited ) + dfs ( grid , i - 1 , j , visited ) + dfs ( grid , i , j + 1 , visited ) + dfs ( grid , i , j - 1 , visited ); } }; 696. Count Binary Substrings $\\star$ 697. Degree of an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findShortestSubArray ( vector < int >& nums ) { int ans = 0 ; int degree = 0 ; unordered_map < int , int > firstSeen ; unordered_map < int , int > numCounts ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! firstSeen . count ( nums [ i ])) firstSeen [ nums [ i ]] = i ; ++ numCounts [ nums [ i ]]; if ( numCounts [ nums [ i ]] > degree ) { degree = numCounts [ nums [ i ]]; ans = i - firstSeen [ nums [ i ]] + 1 ; } else if ( numCounts [ nums [ i ]] == degree ) ans = min ( ans , i - firstSeen [ nums [ i ]] + 1 ); } return ans ; } }; 698. Partition to K Equal Sum Subsets $\\star\\star$ 699. Falling Squares $\\star\\star\\star$ 700. Search in a Binary Search Tree $\\star$","title":"0691-0700"},{"location":"golang/0601-0700/0691-0700/#691-stickers-to-spell-word-starstarstar","text":"","title":"691. Stickers to Spell Word $\\star\\star\\star$"},{"location":"golang/0601-0700/0691-0700/#692-top-k-frequent-words-starstar","text":"","title":"692. Top K Frequent Words $\\star\\star$"},{"location":"golang/0601-0700/0691-0700/#693-binary-number-with-alternating-bits-star","text":"","title":"693. Binary Number with Alternating Bits $\\star$"},{"location":"golang/0601-0700/0691-0700/#694-number-of-distinct-islands-starstar","text":"","title":"694. Number of Distinct Islands $\\star\\star$"},{"location":"golang/0601-0700/0691-0700/#695-max-area-of-island-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> visited ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) ans = max ( ans , dfs ( grid , i , j , visited )); return ans ; } private : int dfs ( vector < vector < int >>& grid , int i , int j , vector < vector < bool >>& visited ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || visited [ i ][ j ] || grid [ i ][ j ] == 0 ) return 0 ; visited [ i ][ j ] = true ; return 1 + dfs ( grid , i + 1 , j , visited ) + dfs ( grid , i - 1 , j , visited ) + dfs ( grid , i , j + 1 , visited ) + dfs ( grid , i , j - 1 , visited ); } };","title":"695. Max Area of Island $\\star\\star$"},{"location":"golang/0601-0700/0691-0700/#696-count-binary-substrings-star","text":"","title":"696. Count Binary Substrings $\\star$"},{"location":"golang/0601-0700/0691-0700/#697-degree-of-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findShortestSubArray ( vector < int >& nums ) { int ans = 0 ; int degree = 0 ; unordered_map < int , int > firstSeen ; unordered_map < int , int > numCounts ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( ! firstSeen . count ( nums [ i ])) firstSeen [ nums [ i ]] = i ; ++ numCounts [ nums [ i ]]; if ( numCounts [ nums [ i ]] > degree ) { degree = numCounts [ nums [ i ]]; ans = i - firstSeen [ nums [ i ]] + 1 ; } else if ( numCounts [ nums [ i ]] == degree ) ans = min ( ans , i - firstSeen [ nums [ i ]] + 1 ); } return ans ; } };","title":"697. Degree of an Array $\\star$"},{"location":"golang/0601-0700/0691-0700/#698-partition-to-k-equal-sum-subsets-starstar","text":"","title":"698. Partition to K Equal Sum Subsets $\\star\\star$"},{"location":"golang/0601-0700/0691-0700/#699-falling-squares-starstarstar","text":"","title":"699. Falling Squares $\\star\\star\\star$"},{"location":"golang/0601-0700/0691-0700/#700-search-in-a-binary-search-tree-star","text":"","title":"700. Search in a Binary Search Tree $\\star$"},{"location":"golang/0701-0800/0701-0710/","text":"701. Insert into a Binary Search Tree $\\star\\star$ 702. Search in a Sorted Array of Unknown Size $\\star\\star$ 703. Kth Largest Element in a Stream $\\star$ 704. Binary Search $\\star$ 705. Design HashSet $\\star$ 706. Design HashMap $\\star$ 707. Design Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class MyLinkedList { public : MyLinkedList () : length ( 0 ) { head = new ListNode ( 0 ); } int get ( int index ) { if ( index < 0 || index >= length ) return - 1 ; ListNode * curr = head -> next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; return curr -> val ; } void addAtHead ( int val ) { ListNode * curr = head -> next ; head -> next = new ListNode ( val ); head -> next -> next = curr ; ++ length ; } void addAtTail ( int val ) { ListNode * curr = head ; while ( curr -> next ) curr = curr -> next ; curr -> next = new ListNode ( val ); ++ length ; } void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode * curr = head ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = new ListNode ( val ); curr -> next -> next = temp ; ++ length ; } void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode * curr = head ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = temp -> next ; -- length ; delete temp ; } private : struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( nullptr ) {} }; int length ; ListNode * head ; }; 708. Insert into a Sorted Circular Linked List $\\star\\star$ 709. To Lower Case $\\star$ 710. Random Pick with Blacklist $\\star\\star\\star$","title":"0701-0710"},{"location":"golang/0701-0800/0701-0710/#701-insert-into-a-binary-search-tree-starstar","text":"","title":"701. Insert into a Binary Search Tree $\\star\\star$"},{"location":"golang/0701-0800/0701-0710/#702-search-in-a-sorted-array-of-unknown-size-starstar","text":"","title":"702. Search in a Sorted Array of Unknown Size $\\star\\star$"},{"location":"golang/0701-0800/0701-0710/#703-kth-largest-element-in-a-stream-star","text":"","title":"703. Kth Largest Element in a Stream $\\star$"},{"location":"golang/0701-0800/0701-0710/#704-binary-search-star","text":"","title":"704. Binary Search $\\star$"},{"location":"golang/0701-0800/0701-0710/#705-design-hashset-star","text":"","title":"705. Design HashSet $\\star$"},{"location":"golang/0701-0800/0701-0710/#706-design-hashmap-star","text":"","title":"706. Design HashMap $\\star$"},{"location":"golang/0701-0800/0701-0710/#707-design-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class MyLinkedList { public : MyLinkedList () : length ( 0 ) { head = new ListNode ( 0 ); } int get ( int index ) { if ( index < 0 || index >= length ) return - 1 ; ListNode * curr = head -> next ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; return curr -> val ; } void addAtHead ( int val ) { ListNode * curr = head -> next ; head -> next = new ListNode ( val ); head -> next -> next = curr ; ++ length ; } void addAtTail ( int val ) { ListNode * curr = head ; while ( curr -> next ) curr = curr -> next ; curr -> next = new ListNode ( val ); ++ length ; } void addAtIndex ( int index , int val ) { if ( index > length ) return ; ListNode * curr = head ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = new ListNode ( val ); curr -> next -> next = temp ; ++ length ; } void deleteAtIndex ( int index ) { if ( index < 0 || index >= length ) return ; ListNode * curr = head ; for ( int i = 0 ; i < index ; ++ i ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = temp -> next ; -- length ; delete temp ; } private : struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( nullptr ) {} }; int length ; ListNode * head ; };","title":"707. Design Linked List $\\star\\star$"},{"location":"golang/0701-0800/0701-0710/#708-insert-into-a-sorted-circular-linked-list-starstar","text":"","title":"708. Insert into a Sorted Circular Linked List $\\star\\star$"},{"location":"golang/0701-0800/0701-0710/#709-to-lower-case-star","text":"","title":"709. To Lower Case $\\star$"},{"location":"golang/0701-0800/0701-0710/#710-random-pick-with-blacklist-starstarstar","text":"","title":"710. Random Pick with Blacklist $\\star\\star\\star$"},{"location":"golang/0701-0800/0711-0720/","text":"711. Number of Distinct Islands II $\\star\\star\\star$ 712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$ 713. Subarray Product Less Than K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { prod *= nums [ i ]; while ( prod >= k ) prod /= nums [ j ++ ]; ans += i - j + 1 ; } return ans ; } }; 714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices , int fee ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price - fee ); } return sell ; } }; 715. Range Module $\\star\\star\\star$ 716. Max Stack $\\star$ 717. 1-bit and 2-bit Characters $\\star$ 1 2 3 4 5 6 7 8 9 class Solution { public : bool isOneBitCharacter ( vector < int >& bits ) { int i = 0 ; while ( i < bits . size () - 1 ) i += bits [ i ] + 1 ; return i == bits . size () - 1 ; } }; 718. Maximum Length of Repeated Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findLength ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); int ans = 0 ; vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , 0 )); for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) if ( A [ i ] == B [ j ]) dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; for ( vector < int >& row : dp ) ans = max ( ans , * max_element ( row . begin (), row . end ())); return ans ; } }; 719. Find K-th Smallest Pair Distance $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { sort ( nums . begin (), nums . end ()); int l = 0 ; int r = nums . back () - nums . front (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { while ( j < nums . size () && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } }; 720. Longest Word in Dictionary $\\star$","title":"0711-0720"},{"location":"golang/0701-0800/0711-0720/#711-number-of-distinct-islands-ii-starstarstar","text":"","title":"711. Number of Distinct Islands II $\\star\\star\\star$"},{"location":"golang/0701-0800/0711-0720/#712-minimum-ascii-delete-sum-for-two-strings-starstar","text":"","title":"712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$"},{"location":"golang/0701-0800/0711-0720/#713-subarray-product-less-than-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { prod *= nums [ i ]; while ( prod >= k ) prod /= nums [ j ++ ]; ans += i - j + 1 ; } return ans ; } };","title":"713. Subarray Product Less Than K $\\star\\star$"},{"location":"golang/0701-0800/0711-0720/#714-best-time-to-buy-and-sell-stock-with-transaction-fee-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices , int fee ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price - fee ); } return sell ; } };","title":"714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$"},{"location":"golang/0701-0800/0711-0720/#715-range-module-starstarstar","text":"","title":"715. Range Module $\\star\\star\\star$"},{"location":"golang/0701-0800/0711-0720/#716-max-stack-star","text":"","title":"716. Max Stack $\\star$"},{"location":"golang/0701-0800/0711-0720/#717-1-bit-and-2-bit-characters-star","text":"1 2 3 4 5 6 7 8 9 class Solution { public : bool isOneBitCharacter ( vector < int >& bits ) { int i = 0 ; while ( i < bits . size () - 1 ) i += bits [ i ] + 1 ; return i == bits . size () - 1 ; } };","title":"717. 1-bit and 2-bit Characters $\\star$"},{"location":"golang/0701-0800/0711-0720/#718-maximum-length-of-repeated-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findLength ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); int ans = 0 ; vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , 0 )); for ( int i = m - 1 ; i >= 0 ; -- i ) for ( int j = n - 1 ; j >= 0 ; -- j ) if ( A [ i ] == B [ j ]) dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; for ( vector < int >& row : dp ) ans = max ( ans , * max_element ( row . begin (), row . end ())); return ans ; } };","title":"718. Maximum Length of Repeated Subarray $\\star\\star$"},{"location":"golang/0701-0800/0711-0720/#719-find-k-th-smallest-pair-distance-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { sort ( nums . begin (), nums . end ()); int l = 0 ; int r = nums . back () - nums . front (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); ++ i ) { while ( j < nums . size () && nums [ j ] <= nums [ i ] + m ) ++ j ; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } };","title":"719. Find K-th Smallest Pair Distance $\\star\\star\\star$"},{"location":"golang/0701-0800/0711-0720/#720-longest-word-in-dictionary-star","text":"","title":"720. Longest Word in Dictionary $\\star$"},{"location":"golang/0701-0800/0721-0730/","text":"721. Accounts Merge $\\star\\star$ 722. Remove Comments $\\star\\star$ 723. Candy Crush $\\star\\star$ 724. Find Pivot Index $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int pivotIndex ( vector < int >& nums ) { int sum = accumulate ( nums . begin (), nums . end (), 0 ); int presum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( presum == sum - presum - nums [ i ]) return i ; presum += nums [ i ]; } return - 1 ; } }; 725. Split Linked List in Parts $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < ListNode *> splitListToParts ( ListNode * root , int k ) { vector < ListNode *> ans ( k , NULL ); int length = 0 ; for ( auto curr = root ; curr ; curr = curr -> next ) ++ length ; int l = length / k ; int r = length % k ; ListNode * head = root ; ListNode * prev = NULL ; for ( int i = 0 ; i < k ; ++ i , -- r ) { ans [ i ] = head ; for ( int j = 0 ; j < l + ( r > 0 ); ++ j ) { prev = head ; head = head -> next ; } if ( prev ) prev -> next = NULL ; } return ans ; } }; 726. Number of Atoms $\\star\\star\\star$ 727. Minimum Window Subsequence $\\star\\star\\star$ 728. Self Dividing Numbers $\\star$ 729. My Calendar I $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class MyCalendar { public : bool book ( int start , int end ) { for ( pair < int , int >& book : books ) if ( max ( book . first , start ) < min ( book . second , end )) return false ; books . push_back ({ start , end }); return true ; } private : vector < pair < int , int >> books ; }; 730. Count Different Palindromic Subsequences $\\star\\star\\star$","title":"0721-0730"},{"location":"golang/0701-0800/0721-0730/#721-accounts-merge-starstar","text":"","title":"721. Accounts Merge $\\star\\star$"},{"location":"golang/0701-0800/0721-0730/#722-remove-comments-starstar","text":"","title":"722. Remove Comments $\\star\\star$"},{"location":"golang/0701-0800/0721-0730/#723-candy-crush-starstar","text":"","title":"723. Candy Crush $\\star\\star$"},{"location":"golang/0701-0800/0721-0730/#724-find-pivot-index-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int pivotIndex ( vector < int >& nums ) { int sum = accumulate ( nums . begin (), nums . end (), 0 ); int presum = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( presum == sum - presum - nums [ i ]) return i ; presum += nums [ i ]; } return - 1 ; } };","title":"724. Find Pivot Index $\\star$"},{"location":"golang/0701-0800/0721-0730/#725-split-linked-list-in-parts-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < ListNode *> splitListToParts ( ListNode * root , int k ) { vector < ListNode *> ans ( k , NULL ); int length = 0 ; for ( auto curr = root ; curr ; curr = curr -> next ) ++ length ; int l = length / k ; int r = length % k ; ListNode * head = root ; ListNode * prev = NULL ; for ( int i = 0 ; i < k ; ++ i , -- r ) { ans [ i ] = head ; for ( int j = 0 ; j < l + ( r > 0 ); ++ j ) { prev = head ; head = head -> next ; } if ( prev ) prev -> next = NULL ; } return ans ; } };","title":"725. Split Linked List in Parts $\\star\\star$"},{"location":"golang/0701-0800/0721-0730/#726-number-of-atoms-starstarstar","text":"","title":"726. Number of Atoms $\\star\\star\\star$"},{"location":"golang/0701-0800/0721-0730/#727-minimum-window-subsequence-starstarstar","text":"","title":"727. Minimum Window Subsequence $\\star\\star\\star$"},{"location":"golang/0701-0800/0721-0730/#728-self-dividing-numbers-star","text":"","title":"728. Self Dividing Numbers $\\star$"},{"location":"golang/0701-0800/0721-0730/#729-my-calendar-i-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class MyCalendar { public : bool book ( int start , int end ) { for ( pair < int , int >& book : books ) if ( max ( book . first , start ) < min ( book . second , end )) return false ; books . push_back ({ start , end }); return true ; } private : vector < pair < int , int >> books ; };","title":"729. My Calendar I $\\star\\star$"},{"location":"golang/0701-0800/0721-0730/#730-count-different-palindromic-subsequences-starstarstar","text":"","title":"730. Count Different Palindromic Subsequences $\\star\\star\\star$"},{"location":"golang/0701-0800/0731-0740/","text":"731. My Calendar II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyCalendarTwo { public : MyCalendarTwo () {} bool book ( int start , int end ) { for ( auto & [ first , second ] : overlaps ) if ( max ( start , first ) < min ( end , second )) return false ; for ( auto & [ first , second ] : booked ) { int s = max ( start , first ); int e = min ( end , second ); if ( s < e ) overlaps . emplace_back ( s , e ); } booked . emplace_back ( start , end ); return true ; } private : vector < pair < int , int >> booked ; vector < pair < int , int >> overlaps ; }; 732. My Calendar III $\\star\\star\\star$ 733. Flood Fill $\\star$ 734. Sentence Similarity $\\star$ 735. Asteroid Collision $\\star\\star$ 736. Parse Lisp Expression $\\star\\star\\star$ 737. Sentence Similarity II $\\star\\star$ 738. Monotone Increasing Digits $\\star\\star$ 739. Daily Temperatures $\\star\\star$ 740. Delete and Earn $\\star\\star$","title":"0731-0740"},{"location":"golang/0701-0800/0731-0740/#731-my-calendar-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyCalendarTwo { public : MyCalendarTwo () {} bool book ( int start , int end ) { for ( auto & [ first , second ] : overlaps ) if ( max ( start , first ) < min ( end , second )) return false ; for ( auto & [ first , second ] : booked ) { int s = max ( start , first ); int e = min ( end , second ); if ( s < e ) overlaps . emplace_back ( s , e ); } booked . emplace_back ( start , end ); return true ; } private : vector < pair < int , int >> booked ; vector < pair < int , int >> overlaps ; };","title":"731. My Calendar II $\\star\\star$"},{"location":"golang/0701-0800/0731-0740/#732-my-calendar-iii-starstarstar","text":"","title":"732. My Calendar III $\\star\\star\\star$"},{"location":"golang/0701-0800/0731-0740/#733-flood-fill-star","text":"","title":"733. Flood Fill $\\star$"},{"location":"golang/0701-0800/0731-0740/#734-sentence-similarity-star","text":"","title":"734. Sentence Similarity $\\star$"},{"location":"golang/0701-0800/0731-0740/#735-asteroid-collision-starstar","text":"","title":"735. Asteroid Collision $\\star\\star$"},{"location":"golang/0701-0800/0731-0740/#736-parse-lisp-expression-starstarstar","text":"","title":"736. Parse Lisp Expression $\\star\\star\\star$"},{"location":"golang/0701-0800/0731-0740/#737-sentence-similarity-ii-starstar","text":"","title":"737. Sentence Similarity II $\\star\\star$"},{"location":"golang/0701-0800/0731-0740/#738-monotone-increasing-digits-starstar","text":"","title":"738. Monotone Increasing Digits $\\star\\star$"},{"location":"golang/0701-0800/0731-0740/#739-daily-temperatures-starstar","text":"","title":"739. Daily Temperatures $\\star\\star$"},{"location":"golang/0701-0800/0731-0740/#740-delete-and-earn-starstar","text":"","title":"740. Delete and Earn $\\star\\star$"},{"location":"golang/0701-0800/0741-0750/","text":"741. Cherry Pickup $\\star\\star\\star$ 742. Closest Leaf in a Binary Tree $\\star\\star$ 743. Network Delay Time $\\star\\star$ 744. Find Smallest Letter Greater Than Target $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : char nextGreatestLetter ( vector < char >& letters , char target ) { int l = 0 ; int r = letters . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( letters [ m ] <= target ) l = m + 1 ; else r = m ; } return letters [ l % letters . size ()]; } }; 745. Prefix and Suffix Search $\\star\\star\\star$ 746. Min Cost Climbing Stairs $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int minCostClimbingStairs ( vector < int >& cost ) { const int n = cost . size (); for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]); return min ( cost [ n - 1 ], cost [ n - 2 ]); } }; 747. Largest Number At Least Twice of Others $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int dominantIndex ( vector < int >& nums ) { int ans ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ]; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ]; } return max >= 2 * secondMax ? ans : - 1 ; } }; 748. Shortest Completing Word $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string shortestCompletingWord ( string licensePlate , vector < string >& words ) { string ans ; vector < int > map ( 26 ); for ( char c : licensePlate ) if ( isalpha ( c )) ++ map [ tolower ( c ) - 'a' ]; int min = INT_MAX ; for ( string & word : words ) { if ( word . length () >= min ) continue ; if ( ! isMatch ( word , map )) continue ; min = word . length (); ans = word ; } return ans ; } private : bool isMatch ( string & word , vector < int >& map ) { vector < int > wordMap ( 26 ); for ( char c : word ) ++ wordMap [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) if ( wordMap [ i ] < map [ i ]) return false ; return true ; } }; 749. Contain Virus $\\star\\star\\star$ 750. Number Of Corner Rectangles $\\star\\star$","title":"0741-0750"},{"location":"golang/0701-0800/0741-0750/#741-cherry-pickup-starstarstar","text":"","title":"741. Cherry Pickup $\\star\\star\\star$"},{"location":"golang/0701-0800/0741-0750/#742-closest-leaf-in-a-binary-tree-starstar","text":"","title":"742. Closest Leaf in a Binary Tree $\\star\\star$"},{"location":"golang/0701-0800/0741-0750/#743-network-delay-time-starstar","text":"","title":"743. Network Delay Time $\\star\\star$"},{"location":"golang/0701-0800/0741-0750/#744-find-smallest-letter-greater-than-target-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : char nextGreatestLetter ( vector < char >& letters , char target ) { int l = 0 ; int r = letters . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( letters [ m ] <= target ) l = m + 1 ; else r = m ; } return letters [ l % letters . size ()]; } };","title":"744. Find Smallest Letter Greater Than Target $\\star$"},{"location":"golang/0701-0800/0741-0750/#745-prefix-and-suffix-search-starstarstar","text":"","title":"745. Prefix and Suffix Search $\\star\\star\\star$"},{"location":"golang/0701-0800/0741-0750/#746-min-cost-climbing-stairs-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int minCostClimbingStairs ( vector < int >& cost ) { const int n = cost . size (); for ( int i = 2 ; i < n ; ++ i ) cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]); return min ( cost [ n - 1 ], cost [ n - 2 ]); } };","title":"746. Min Cost Climbing Stairs $\\star$"},{"location":"golang/0701-0800/0741-0750/#747-largest-number-at-least-twice-of-others-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int dominantIndex ( vector < int >& nums ) { int ans ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . size (); ++ i ) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ]; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ]; } return max >= 2 * secondMax ? ans : - 1 ; } };","title":"747. Largest Number At Least Twice of Others $\\star$"},{"location":"golang/0701-0800/0741-0750/#748-shortest-completing-word-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string shortestCompletingWord ( string licensePlate , vector < string >& words ) { string ans ; vector < int > map ( 26 ); for ( char c : licensePlate ) if ( isalpha ( c )) ++ map [ tolower ( c ) - 'a' ]; int min = INT_MAX ; for ( string & word : words ) { if ( word . length () >= min ) continue ; if ( ! isMatch ( word , map )) continue ; min = word . length (); ans = word ; } return ans ; } private : bool isMatch ( string & word , vector < int >& map ) { vector < int > wordMap ( 26 ); for ( char c : word ) ++ wordMap [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) if ( wordMap [ i ] < map [ i ]) return false ; return true ; } };","title":"748. Shortest Completing Word $\\star$"},{"location":"golang/0701-0800/0741-0750/#749-contain-virus-starstarstar","text":"","title":"749. Contain Virus $\\star\\star\\star$"},{"location":"golang/0701-0800/0741-0750/#750-number-of-corner-rectangles-starstar","text":"","title":"750. Number Of Corner Rectangles $\\star\\star$"},{"location":"golang/0701-0800/0751-0760/","text":"751. IP to CIDR $\\star$ 752. Open the Lock $\\star\\star$ 753. Cracking the Safe $\\star\\star\\star$ 754. Reach a Number $\\star\\star$ 755. Pour Water $\\star\\star$ 756. Pyramid Transition Matrix $\\star\\star$ 757. Set Intersection Size At Least Two $\\star\\star\\star$ 758. Bold Words in String $\\star$ 759. Employee Free Time $\\star\\star\\star$ 760. Find Anagram Mappings $\\star$","title":"0751-0760"},{"location":"golang/0701-0800/0751-0760/#751-ip-to-cidr-star","text":"","title":"751. IP to CIDR $\\star$"},{"location":"golang/0701-0800/0751-0760/#752-open-the-lock-starstar","text":"","title":"752. Open the Lock $\\star\\star$"},{"location":"golang/0701-0800/0751-0760/#753-cracking-the-safe-starstarstar","text":"","title":"753. Cracking the Safe $\\star\\star\\star$"},{"location":"golang/0701-0800/0751-0760/#754-reach-a-number-starstar","text":"","title":"754. Reach a Number $\\star\\star$"},{"location":"golang/0701-0800/0751-0760/#755-pour-water-starstar","text":"","title":"755. Pour Water $\\star\\star$"},{"location":"golang/0701-0800/0751-0760/#756-pyramid-transition-matrix-starstar","text":"","title":"756. Pyramid Transition Matrix $\\star\\star$"},{"location":"golang/0701-0800/0751-0760/#757-set-intersection-size-at-least-two-starstarstar","text":"","title":"757. Set Intersection Size At Least Two $\\star\\star\\star$"},{"location":"golang/0701-0800/0751-0760/#758-bold-words-in-string-star","text":"","title":"758. Bold Words in String $\\star$"},{"location":"golang/0701-0800/0751-0760/#759-employee-free-time-starstarstar","text":"","title":"759. Employee Free Time $\\star\\star\\star$"},{"location":"golang/0701-0800/0751-0760/#760-find-anagram-mappings-star","text":"","title":"760. Find Anagram Mappings $\\star$"},{"location":"golang/0701-0800/0761-0770/","text":"761. Special Binary String $\\star\\star\\star$ 762. Prime Number of Set Bits in Binary Representation $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int countPrimeSetBits ( int L , int R ) { // (10100010100010101100)2 = (665772)10 constexpr int magic = 665772 ; int ans = 0 ; for ( int n = L ; n <= R ; ++ n ) if ( magic & ( 1 << __builtin_popcountll ( n ))) ++ ans ; return ans ; } }; 763. Partition Labels $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > partitionLabels ( string S ) { vector < int > ans ; vector < int > map ( 26 ); for ( int i = 0 ; i < S . length (); ++ i ) map [ S [ i ] - 'a' ] = i ; int start = 0 ; int end = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { end = max ( end , map [ S [ i ] - 'a' ]); if ( i == end ) { ans . push_back ( end - start + 1 ); start = end + 1 ; } } return ans ; } }; 764. Largest Plus Sign $\\star\\star$ 765. Couples Holding Hands $\\star\\star\\star$ 766. Toeplitz Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { for ( int i = 0 ; i + 1 < matrix . size (); ++ i ) for ( int j = 0 ; j + 1 < matrix [ 0 ]. size (); ++ j ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]) return false ; return true ; } }; 767. Reorganize String $\\star\\star$ 768. Max Chunks To Make Sorted II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { const int n = arr . size (); int ans = 0 ; int max = INT_MIN ; vector < int > min ( n , arr . back ()); for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], arr [ i ]); for ( int i = 0 ; i < n - 1 ; ++ i ) { max = std :: max ( max , arr [ i ]); if ( max <= min [ i + 1 ]) ++ ans ; } return ans + 1 ; } }; 769. Max Chunks To Make Sorted $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 0 ; int max = INT_MIN ; for ( int i = 0 ; i < arr . size (); ++ i ) { max = std :: max ( max , arr [ i ]); if ( max == i ) ++ ans ; } return ans ; } }; 770. Basic Calculator IV $\\star\\star\\star$","title":"0761-0770"},{"location":"golang/0701-0800/0761-0770/#761-special-binary-string-starstarstar","text":"","title":"761. Special Binary String $\\star\\star\\star$"},{"location":"golang/0701-0800/0761-0770/#762-prime-number-of-set-bits-in-binary-representation-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int countPrimeSetBits ( int L , int R ) { // (10100010100010101100)2 = (665772)10 constexpr int magic = 665772 ; int ans = 0 ; for ( int n = L ; n <= R ; ++ n ) if ( magic & ( 1 << __builtin_popcountll ( n ))) ++ ans ; return ans ; } };","title":"762. Prime Number of Set Bits in Binary Representation $\\star$"},{"location":"golang/0701-0800/0761-0770/#763-partition-labels-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > partitionLabels ( string S ) { vector < int > ans ; vector < int > map ( 26 ); for ( int i = 0 ; i < S . length (); ++ i ) map [ S [ i ] - 'a' ] = i ; int start = 0 ; int end = 0 ; for ( int i = 0 ; i < S . length (); ++ i ) { end = max ( end , map [ S [ i ] - 'a' ]); if ( i == end ) { ans . push_back ( end - start + 1 ); start = end + 1 ; } } return ans ; } };","title":"763. Partition Labels $\\star\\star$"},{"location":"golang/0701-0800/0761-0770/#764-largest-plus-sign-starstar","text":"","title":"764. Largest Plus Sign $\\star\\star$"},{"location":"golang/0701-0800/0761-0770/#765-couples-holding-hands-starstarstar","text":"","title":"765. Couples Holding Hands $\\star\\star\\star$"},{"location":"golang/0701-0800/0761-0770/#766-toeplitz-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { for ( int i = 0 ; i + 1 < matrix . size (); ++ i ) for ( int j = 0 ; j + 1 < matrix [ 0 ]. size (); ++ j ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]) return false ; return true ; } };","title":"766. Toeplitz Matrix $\\star$"},{"location":"golang/0701-0800/0761-0770/#767-reorganize-string-starstar","text":"","title":"767. Reorganize String $\\star\\star$"},{"location":"golang/0701-0800/0761-0770/#768-max-chunks-to-make-sorted-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { const int n = arr . size (); int ans = 0 ; int max = INT_MIN ; vector < int > min ( n , arr . back ()); for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], arr [ i ]); for ( int i = 0 ; i < n - 1 ; ++ i ) { max = std :: max ( max , arr [ i ]); if ( max <= min [ i + 1 ]) ++ ans ; } return ans + 1 ; } };","title":"768. Max Chunks To Make Sorted II $\\star\\star\\star$"},{"location":"golang/0701-0800/0761-0770/#769-max-chunks-to-make-sorted-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 0 ; int max = INT_MIN ; for ( int i = 0 ; i < arr . size (); ++ i ) { max = std :: max ( max , arr [ i ]); if ( max == i ) ++ ans ; } return ans ; } };","title":"769. Max Chunks To Make Sorted $\\star\\star$"},{"location":"golang/0701-0800/0761-0770/#770-basic-calculator-iv-starstarstar","text":"","title":"770. Basic Calculator IV $\\star\\star\\star$"},{"location":"golang/0701-0800/0771-0780/","text":"771. Jewels and Stones $\\star$ 772. Basic Calculator III $\\star\\star\\star$ 773. Sliding Puzzle $\\star\\star\\star$ 774. Minimize Max Distance to Gas Station $\\star\\star\\star$ 775. Global and Local Inversions $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution { public : bool isIdealPermutation ( vector < int >& A ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( abs ( A [ i ] - i ) > 1 ) return false ; return true ; } }; 776. Split BST $\\star\\star$ 777. Swap Adjacent in LR String $\\star\\star$ 778. Swim in Rising Water $\\star\\star\\star$ 779. K-th Symbol in Grammar $\\star\\star$ 780. Reaching Points $\\star\\star\\star$","title":"0771-0780"},{"location":"golang/0701-0800/0771-0780/#771-jewels-and-stones-star","text":"","title":"771. Jewels and Stones $\\star$"},{"location":"golang/0701-0800/0771-0780/#772-basic-calculator-iii-starstarstar","text":"","title":"772. Basic Calculator III $\\star\\star\\star$"},{"location":"golang/0701-0800/0771-0780/#773-sliding-puzzle-starstarstar","text":"","title":"773. Sliding Puzzle $\\star\\star\\star$"},{"location":"golang/0701-0800/0771-0780/#774-minimize-max-distance-to-gas-station-starstarstar","text":"","title":"774. Minimize Max Distance to Gas Station $\\star\\star\\star$"},{"location":"golang/0701-0800/0771-0780/#775-global-and-local-inversions-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution { public : bool isIdealPermutation ( vector < int >& A ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( abs ( A [ i ] - i ) > 1 ) return false ; return true ; } };","title":"775. Global and Local Inversions $\\star\\star$"},{"location":"golang/0701-0800/0771-0780/#776-split-bst-starstar","text":"","title":"776. Split BST $\\star\\star$"},{"location":"golang/0701-0800/0771-0780/#777-swap-adjacent-in-lr-string-starstar","text":"","title":"777. Swap Adjacent in LR String $\\star\\star$"},{"location":"golang/0701-0800/0771-0780/#778-swim-in-rising-water-starstarstar","text":"","title":"778. Swim in Rising Water $\\star\\star\\star$"},{"location":"golang/0701-0800/0771-0780/#779-k-th-symbol-in-grammar-starstar","text":"","title":"779. K-th Symbol in Grammar $\\star\\star$"},{"location":"golang/0701-0800/0771-0780/#780-reaching-points-starstarstar","text":"","title":"780. Reaching Points $\\star\\star\\star$"},{"location":"golang/0701-0800/0781-0790/","text":"781. Rabbits in Forest $\\star\\star$ 782. Transform to Chessboard $\\star\\star\\star$ 783. Minimum Distance Between BST Nodes $\\star$ 784. Letter Case Permutation $\\star$ 785. Is Graph Bipartite? $\\star\\star$ 786. K-th Smallest Prime Fraction $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < int > kthSmallestPrimeFraction ( vector < int >& A , int K ) { const int n = A . size (); vector < int > ans = { 0 , 1 }; double l = 0 ; double r = 1 ; while ( true ) { double m = ( l + r ) / 2 ; ans [ 0 ] = 0 ; int count = 0 ; int j = 1 ; for ( int i = 0 ; i < n ; ++ i ) { while ( j < n && A [ i ] > m * A [ j ]) ++ j ; count += n - j ; if ( j == n ) break ; if ( ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ]) { ans [ 0 ] = A [ i ]; ans [ 1 ] = A [ j ]; } } if ( count < K ) l = m ; else if ( count > K ) r = m ; else return ans ; } } }; 787. Cheapest Flights Within K Stops $\\star\\star$ 788. Rotated Digits $\\star$ 789. Escape The Ghosts $\\star\\star$ 790. Domino and Tromino Tiling $\\star\\star$","title":"0781-0790"},{"location":"golang/0701-0800/0781-0790/#781-rabbits-in-forest-starstar","text":"","title":"781. Rabbits in Forest $\\star\\star$"},{"location":"golang/0701-0800/0781-0790/#782-transform-to-chessboard-starstarstar","text":"","title":"782. Transform to Chessboard $\\star\\star\\star$"},{"location":"golang/0701-0800/0781-0790/#783-minimum-distance-between-bst-nodes-star","text":"","title":"783. Minimum Distance Between BST Nodes $\\star$"},{"location":"golang/0701-0800/0781-0790/#784-letter-case-permutation-star","text":"","title":"784. Letter Case Permutation $\\star$"},{"location":"golang/0701-0800/0781-0790/#785-is-graph-bipartite-starstar","text":"","title":"785. Is Graph Bipartite? $\\star\\star$"},{"location":"golang/0701-0800/0781-0790/#786-k-th-smallest-prime-fraction-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < int > kthSmallestPrimeFraction ( vector < int >& A , int K ) { const int n = A . size (); vector < int > ans = { 0 , 1 }; double l = 0 ; double r = 1 ; while ( true ) { double m = ( l + r ) / 2 ; ans [ 0 ] = 0 ; int count = 0 ; int j = 1 ; for ( int i = 0 ; i < n ; ++ i ) { while ( j < n && A [ i ] > m * A [ j ]) ++ j ; count += n - j ; if ( j == n ) break ; if ( ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ]) { ans [ 0 ] = A [ i ]; ans [ 1 ] = A [ j ]; } } if ( count < K ) l = m ; else if ( count > K ) r = m ; else return ans ; } } };","title":"786. K-th Smallest Prime Fraction $\\star\\star\\star$"},{"location":"golang/0701-0800/0781-0790/#787-cheapest-flights-within-k-stops-starstar","text":"","title":"787. Cheapest Flights Within K Stops $\\star\\star$"},{"location":"golang/0701-0800/0781-0790/#788-rotated-digits-star","text":"","title":"788. Rotated Digits $\\star$"},{"location":"golang/0701-0800/0781-0790/#789-escape-the-ghosts-starstar","text":"","title":"789. Escape The Ghosts $\\star\\star$"},{"location":"golang/0701-0800/0781-0790/#790-domino-and-tromino-tiling-starstar","text":"","title":"790. Domino and Tromino Tiling $\\star\\star$"},{"location":"golang/0701-0800/0791-0800/","text":"791. Custom Sort String $\\star\\star$ 792. Number of Matching Subsequences $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : int numMatchingSubseq ( string S , vector < string >& words ) { for ( const string & word : words ) insert ( word ); return dfs ( S , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), count ( 0 ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; int count ; }; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } ++ node -> count ; } int dfs ( const string & S , int s , TrieNode * node ) { int ans = node -> count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ]) { int index = indexOf ( S , i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node -> children [ i ]); } return ans ; } int indexOf ( const string & S , char c , int s ) { for ( int i = s ; i < S . length (); ++ i ) if ( S [ i ] == c ) return i ; return - 1 ; } TrieNode root ; }; 793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$ 794. Valid Tic-Tac-Toe State $\\star\\star$ 795. Number of Subarrays with Bounded Maximum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numSubarrayBoundedMax ( vector < int >& A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } }; 796. Rotate String $\\star$ 797. All Paths From Source to Target $\\star\\star$ 798. Smallest Rotation with Highest Score $\\star\\star\\star$ 799. Champagne Tower $\\star\\star$ 800. Similar RGB Color $\\star$","title":"0791-0800"},{"location":"golang/0701-0800/0791-0800/#791-custom-sort-string-starstar","text":"","title":"791. Custom Sort String $\\star\\star$"},{"location":"golang/0701-0800/0791-0800/#792-number-of-matching-subsequences-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : int numMatchingSubseq ( string S , vector < string >& words ) { for ( const string & word : words ) insert ( word ); return dfs ( S , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), count ( 0 ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; int count ; }; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } ++ node -> count ; } int dfs ( const string & S , int s , TrieNode * node ) { int ans = node -> count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; ++ i ) if ( node -> children [ i ]) { int index = indexOf ( S , i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node -> children [ i ]); } return ans ; } int indexOf ( const string & S , char c , int s ) { for ( int i = s ; i < S . length (); ++ i ) if ( S [ i ] == c ) return i ; return - 1 ; } TrieNode root ; };","title":"792. Number of Matching Subsequences $\\star\\star$"},{"location":"golang/0701-0800/0791-0800/#793-preimage-size-of-factorial-zeroes-function-starstarstar","text":"","title":"793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$"},{"location":"golang/0701-0800/0791-0800/#794-valid-tic-tac-toe-state-starstar","text":"","title":"794. Valid Tic-Tac-Toe State $\\star\\star$"},{"location":"golang/0701-0800/0791-0800/#795-number-of-subarrays-with-bounded-maximum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numSubarrayBoundedMax ( vector < int >& A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } };","title":"795. Number of Subarrays with Bounded Maximum $\\star\\star$"},{"location":"golang/0701-0800/0791-0800/#796-rotate-string-star","text":"","title":"796. Rotate String $\\star$"},{"location":"golang/0701-0800/0791-0800/#797-all-paths-from-source-to-target-starstar","text":"","title":"797. All Paths From Source to Target $\\star\\star$"},{"location":"golang/0701-0800/0791-0800/#798-smallest-rotation-with-highest-score-starstarstar","text":"","title":"798. Smallest Rotation with Highest Score $\\star\\star\\star$"},{"location":"golang/0701-0800/0791-0800/#799-champagne-tower-starstar","text":"","title":"799. Champagne Tower $\\star\\star$"},{"location":"golang/0701-0800/0791-0800/#800-similar-rgb-color-star","text":"","title":"800. Similar RGB Color $\\star$"},{"location":"golang/0801-0900/0801-0810/","text":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$ 802. Find Eventual Safe States $\\star\\star$ 803. Bricks Falling When Hit $\\star\\star\\star$ 804. Unique Morse Code Words $\\star$ 805. Split Array With Same Average $\\star\\star\\star$ 806. Number of Lines To Write String $\\star$ 807. Max Increase to Keep City Skyline $\\star\\star$ 808. Soup Servings $\\star\\star$ 809. Expressive Words $\\star\\star$ 810. Chalkboard XOR Game $\\star\\star\\star$","title":"0801-0810"},{"location":"golang/0801-0900/0801-0810/#801-minimum-swaps-to-make-sequences-increasing-starstar","text":"","title":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$"},{"location":"golang/0801-0900/0801-0810/#802-find-eventual-safe-states-starstar","text":"","title":"802. Find Eventual Safe States $\\star\\star$"},{"location":"golang/0801-0900/0801-0810/#803-bricks-falling-when-hit-starstarstar","text":"","title":"803. Bricks Falling When Hit $\\star\\star\\star$"},{"location":"golang/0801-0900/0801-0810/#804-unique-morse-code-words-star","text":"","title":"804. Unique Morse Code Words $\\star$"},{"location":"golang/0801-0900/0801-0810/#805-split-array-with-same-average-starstarstar","text":"","title":"805. Split Array With Same Average $\\star\\star\\star$"},{"location":"golang/0801-0900/0801-0810/#806-number-of-lines-to-write-string-star","text":"","title":"806. Number of Lines To Write String $\\star$"},{"location":"golang/0801-0900/0801-0810/#807-max-increase-to-keep-city-skyline-starstar","text":"","title":"807. Max Increase to Keep City Skyline $\\star\\star$"},{"location":"golang/0801-0900/0801-0810/#808-soup-servings-starstar","text":"","title":"808. Soup Servings $\\star\\star$"},{"location":"golang/0801-0900/0801-0810/#809-expressive-words-starstar","text":"","title":"809. Expressive Words $\\star\\star$"},{"location":"golang/0801-0900/0801-0810/#810-chalkboard-xor-game-starstarstar","text":"","title":"810. Chalkboard XOR Game $\\star\\star\\star$"},{"location":"golang/0801-0900/0811-0820/","text":"811. Subdomain Visit Count $\\star$ 812. Largest Triangle Area $\\star$ 813. Largest Sum of Averages $\\star\\star$ 814. Binary Tree Pruning $\\star\\star$ 815. Bus Routes $\\star\\star\\star$ 816. Ambiguous Coordinates $\\star\\star$ 817. Linked List Components $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numComponents ( ListNode * head , vector < int >& G ) { int ans = 0 ; unordered_set < int > g ( G . begin (), G . end ()); while ( head ) { if ( g . count ( head -> val ) && ( ! head -> next || ! g . count ( head -> next -> val ))) ++ ans ; head = head -> next ; } return ans ; } }; 818. Race Car $\\star\\star\\star$ 819. Most Common Word $\\star$ 820. Short Encoding of Words $\\star\\star$","title":"0811-0820"},{"location":"golang/0801-0900/0811-0820/#811-subdomain-visit-count-star","text":"","title":"811. Subdomain Visit Count $\\star$"},{"location":"golang/0801-0900/0811-0820/#812-largest-triangle-area-star","text":"","title":"812. Largest Triangle Area $\\star$"},{"location":"golang/0801-0900/0811-0820/#813-largest-sum-of-averages-starstar","text":"","title":"813. Largest Sum of Averages $\\star\\star$"},{"location":"golang/0801-0900/0811-0820/#814-binary-tree-pruning-starstar","text":"","title":"814. Binary Tree Pruning $\\star\\star$"},{"location":"golang/0801-0900/0811-0820/#815-bus-routes-starstarstar","text":"","title":"815. Bus Routes $\\star\\star\\star$"},{"location":"golang/0801-0900/0811-0820/#816-ambiguous-coordinates-starstar","text":"","title":"816. Ambiguous Coordinates $\\star\\star$"},{"location":"golang/0801-0900/0811-0820/#817-linked-list-components-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numComponents ( ListNode * head , vector < int >& G ) { int ans = 0 ; unordered_set < int > g ( G . begin (), G . end ()); while ( head ) { if ( g . count ( head -> val ) && ( ! head -> next || ! g . count ( head -> next -> val ))) ++ ans ; head = head -> next ; } return ans ; } };","title":"817. Linked List Components $\\star\\star$"},{"location":"golang/0801-0900/0811-0820/#818-race-car-starstarstar","text":"","title":"818. Race Car $\\star\\star\\star$"},{"location":"golang/0801-0900/0811-0820/#819-most-common-word-star","text":"","title":"819. Most Common Word $\\star$"},{"location":"golang/0801-0900/0811-0820/#820-short-encoding-of-words-starstar","text":"","title":"820. Short Encoding of Words $\\star\\star$"},{"location":"golang/0801-0900/0821-0830/","text":"821. Shortest Distance to a Character $\\star$ 822. Card Flipping Game $\\star\\star$ 823. Binary Trees With Factors $\\star\\star$ 824. Goat Latin $\\star$ 825. Friends Of Appropriate Ages $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numFriendRequests ( vector < int >& ages ) { int ans = 0 ; vector < int > count ( 121 ); for ( int age : ages ) ++ count [ age ]; for ( int i = 15 ; i <= 120 ; ++ i ) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; ++ i ) for ( int j = i / 2 + 8 ; j < i ; ++ j ) ans += count [ i ] * count [ j ]; return ans ; } }; 826. Most Profit Assigning Work $\\star\\star$ 827. Making A Large Island $\\star\\star\\star$ 828. Unique Letter String $\\star\\star\\star$ 829. Consecutive Numbers Sum $\\star\\star\\star$ 830. Positions of Large Groups $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> largeGroupPositions ( string S ) { const int n = S . length (); vector < vector < int >> ans ; for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S [ j ] == S [ i ]) ++ j ; if ( j - i >= 3 ) ans . push_back ({ i , j - 1 }); } return ans ; } };","title":"0821-0830"},{"location":"golang/0801-0900/0821-0830/#821-shortest-distance-to-a-character-star","text":"","title":"821. Shortest Distance to a Character $\\star$"},{"location":"golang/0801-0900/0821-0830/#822-card-flipping-game-starstar","text":"","title":"822. Card Flipping Game $\\star\\star$"},{"location":"golang/0801-0900/0821-0830/#823-binary-trees-with-factors-starstar","text":"","title":"823. Binary Trees With Factors $\\star\\star$"},{"location":"golang/0801-0900/0821-0830/#824-goat-latin-star","text":"","title":"824. Goat Latin $\\star$"},{"location":"golang/0801-0900/0821-0830/#825-friends-of-appropriate-ages-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numFriendRequests ( vector < int >& ages ) { int ans = 0 ; vector < int > count ( 121 ); for ( int age : ages ) ++ count [ age ]; for ( int i = 15 ; i <= 120 ; ++ i ) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; ++ i ) for ( int j = i / 2 + 8 ; j < i ; ++ j ) ans += count [ i ] * count [ j ]; return ans ; } };","title":"825. Friends Of Appropriate Ages $\\star\\star$"},{"location":"golang/0801-0900/0821-0830/#826-most-profit-assigning-work-starstar","text":"","title":"826. Most Profit Assigning Work $\\star\\star$"},{"location":"golang/0801-0900/0821-0830/#827-making-a-large-island-starstarstar","text":"","title":"827. Making A Large Island $\\star\\star\\star$"},{"location":"golang/0801-0900/0821-0830/#828-unique-letter-string-starstarstar","text":"","title":"828. Unique Letter String $\\star\\star\\star$"},{"location":"golang/0801-0900/0821-0830/#829-consecutive-numbers-sum-starstarstar","text":"","title":"829. Consecutive Numbers Sum $\\star\\star\\star$"},{"location":"golang/0801-0900/0821-0830/#830-positions-of-large-groups-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> largeGroupPositions ( string S ) { const int n = S . length (); vector < vector < int >> ans ; for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S [ j ] == S [ i ]) ++ j ; if ( j - i >= 3 ) ans . push_back ({ i , j - 1 }); } return ans ; } };","title":"830. Positions of Large Groups $\\star$"},{"location":"golang/0801-0900/0831-0840/","text":"831. Masking Personal Information $\\star\\star$ 832. Flipping an Image $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { int temp = A [ i ][ j ]; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } }; 833. Find And Replace in String $\\star\\star$ 834. Sum of Distances in Tree $\\star\\star\\star$ 835. Image Overlap $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int largestOverlap ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int n = A . size (); const int magic = 100 ; int ans = 0 ; vector < pair < int , int >> onesA ; vector < pair < int , int >> onesB ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ][ j ] == 1 ) onesA . push_back ({ i , j }); if ( B [ i ][ j ] == 1 ) onesB . push_back ({ i , j }); } for ( pair < int , int >& a : onesA ) for ( pair < int , int >& b : onesB ) ++ map [( a . first - b . first ) * magic + ( a . second - b . second )]; for ( auto & [ _ , value ] : map ) ans = max ( ans , value ); return ans ; } }; 836. Rectangle Overlap $\\star$ 837. New 21 Game $\\star\\star$ 838. Push Dominoes $\\star\\star$ 839. Similar String Groups $\\star\\star\\star$ 840. Magic Squares In Grid $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numMagicSquaresInside ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . size (); ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private : int isMagic ( vector < vector < int >>& grid , int i , int j ) { string s ; for ( int num : { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += to_string ( grid [ i + num / 3 ][ j + num % 3 ]); return string ( \"4381672943816729\" ). find ( s ) != string :: npos || string ( \"9276183492761834\" ). find ( s ) != string :: npos ; } };","title":"0831-0840"},{"location":"golang/0801-0900/0831-0840/#831-masking-personal-information-starstar","text":"","title":"831. Masking Personal Information $\\star\\star$"},{"location":"golang/0801-0900/0831-0840/#832-flipping-an-image-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; ++ j ) { int temp = A [ i ][ j ]; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } };","title":"832. Flipping an Image $\\star$"},{"location":"golang/0801-0900/0831-0840/#833-find-and-replace-in-string-starstar","text":"","title":"833. Find And Replace in String $\\star\\star$"},{"location":"golang/0801-0900/0831-0840/#834-sum-of-distances-in-tree-starstarstar","text":"","title":"834. Sum of Distances in Tree $\\star\\star\\star$"},{"location":"golang/0801-0900/0831-0840/#835-image-overlap-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int largestOverlap ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int n = A . size (); const int magic = 100 ; int ans = 0 ; vector < pair < int , int >> onesA ; vector < pair < int , int >> onesB ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( A [ i ][ j ] == 1 ) onesA . push_back ({ i , j }); if ( B [ i ][ j ] == 1 ) onesB . push_back ({ i , j }); } for ( pair < int , int >& a : onesA ) for ( pair < int , int >& b : onesB ) ++ map [( a . first - b . first ) * magic + ( a . second - b . second )]; for ( auto & [ _ , value ] : map ) ans = max ( ans , value ); return ans ; } };","title":"835. Image Overlap $\\star\\star$"},{"location":"golang/0801-0900/0831-0840/#836-rectangle-overlap-star","text":"","title":"836. Rectangle Overlap $\\star$"},{"location":"golang/0801-0900/0831-0840/#837-new-21-game-starstar","text":"","title":"837. New 21 Game $\\star\\star$"},{"location":"golang/0801-0900/0831-0840/#838-push-dominoes-starstar","text":"","title":"838. Push Dominoes $\\star\\star$"},{"location":"golang/0801-0900/0831-0840/#839-similar-string-groups-starstarstar","text":"","title":"839. Similar String Groups $\\star\\star\\star$"},{"location":"golang/0801-0900/0831-0840/#840-magic-squares-in-grid-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numMagicSquaresInside ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . size (); ++ i ) for ( int j = 0 ; j + 2 < grid [ 0 ]. size (); ++ j ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private : int isMagic ( vector < vector < int >>& grid , int i , int j ) { string s ; for ( int num : { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += to_string ( grid [ i + num / 3 ][ j + num % 3 ]); return string ( \"4381672943816729\" ). find ( s ) != string :: npos || string ( \"9276183492761834\" ). find ( s ) != string :: npos ; } };","title":"840. Magic Squares In Grid $\\star$"},{"location":"golang/0801-0900/0841-0850/","text":"841. Keys and Rooms $\\star\\star$ 842. Split Array into Fibonacci Sequence $\\star\\star$ 843. Guess the Word $\\star\\star\\star$ 844. Backspace String Compare $\\star$ 845. Longest Mountain in Array $\\star\\star$ 846. Hand of Straights $\\star\\star$ 847. Shortest Path Visiting All Nodes $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int shortestPathLength ( vector < vector < int >>& graph ) { const int n = graph . size (); const int goal = ( 1 << n ) - 1 ; int ans = 0 ; queue < pair < int , int >> q ; vector < vector < int >> visited ( n , vector < int > ( 1 << n )); for ( int i = 0 ; i < graph . size (); ++ i ) q . push ({ i , 1 << i }); while ( ! q . empty ()) { int s = q . size (); while ( s -- ) { auto p = q . front (); q . pop (); int node = p . first ; int state = p . second ; if ( state == goal ) return ans ; if ( visited [ node ][ state ]) continue ; visited [ node ][ state ] = 1 ; for ( int next : graph [ node ]) q . push ({ next , state | ( 1 << next )}); } ++ ans ; } return - 1 ; } }; 848. Shifting Letters $\\star\\star$ 849. Maximize Distance to Closest Person $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxDistToClosest ( vector < int >& seats ) { const int n = seats . size (); int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : max ( ans , ( i - j ) / 2 ); j = i ; } return max ( ans , n - j - 1 ); } }; 850. Rectangle Area II $\\star\\star\\star$","title":"0841-0850"},{"location":"golang/0801-0900/0841-0850/#841-keys-and-rooms-starstar","text":"","title":"841. Keys and Rooms $\\star\\star$"},{"location":"golang/0801-0900/0841-0850/#842-split-array-into-fibonacci-sequence-starstar","text":"","title":"842. Split Array into Fibonacci Sequence $\\star\\star$"},{"location":"golang/0801-0900/0841-0850/#843-guess-the-word-starstarstar","text":"","title":"843. Guess the Word $\\star\\star\\star$"},{"location":"golang/0801-0900/0841-0850/#844-backspace-string-compare-star","text":"","title":"844. Backspace String Compare $\\star$"},{"location":"golang/0801-0900/0841-0850/#845-longest-mountain-in-array-starstar","text":"","title":"845. Longest Mountain in Array $\\star\\star$"},{"location":"golang/0801-0900/0841-0850/#846-hand-of-straights-starstar","text":"","title":"846. Hand of Straights $\\star\\star$"},{"location":"golang/0801-0900/0841-0850/#847-shortest-path-visiting-all-nodes-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int shortestPathLength ( vector < vector < int >>& graph ) { const int n = graph . size (); const int goal = ( 1 << n ) - 1 ; int ans = 0 ; queue < pair < int , int >> q ; vector < vector < int >> visited ( n , vector < int > ( 1 << n )); for ( int i = 0 ; i < graph . size (); ++ i ) q . push ({ i , 1 << i }); while ( ! q . empty ()) { int s = q . size (); while ( s -- ) { auto p = q . front (); q . pop (); int node = p . first ; int state = p . second ; if ( state == goal ) return ans ; if ( visited [ node ][ state ]) continue ; visited [ node ][ state ] = 1 ; for ( int next : graph [ node ]) q . push ({ next , state | ( 1 << next )}); } ++ ans ; } return - 1 ; } };","title":"847. Shortest Path Visiting All Nodes $\\star\\star\\star$"},{"location":"golang/0801-0900/0841-0850/#848-shifting-letters-starstar","text":"","title":"848. Shifting Letters $\\star\\star$"},{"location":"golang/0801-0900/0841-0850/#849-maximize-distance-to-closest-person-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxDistToClosest ( vector < int >& seats ) { const int n = seats . size (); int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; ++ i ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : max ( ans , ( i - j ) / 2 ); j = i ; } return max ( ans , n - j - 1 ); } };","title":"849. Maximize Distance to Closest Person $\\star$"},{"location":"golang/0801-0900/0841-0850/#850-rectangle-area-ii-starstarstar","text":"","title":"850. Rectangle Area II $\\star\\star\\star$"},{"location":"golang/0801-0900/0851-0860/","text":"851. Loud and Rich $\\star\\star$ 852. Peak Index in a Mountain Array $\\star$ 853. Car Fleet $\\star\\star$ 854. K-Similar Strings $\\star\\star\\star$ 855. Exam Room $\\star\\star$ 856. Score of Parentheses $\\star\\star$ 857. Minimum Cost to Hire K Workers $\\star\\star\\star$ 858. Mirror Reflection $\\star\\star$ 859. Buddy Strings $\\star$ 860. Lemonade Change $\\star$","title":"0851-0860"},{"location":"golang/0801-0900/0851-0860/#851-loud-and-rich-starstar","text":"","title":"851. Loud and Rich $\\star\\star$"},{"location":"golang/0801-0900/0851-0860/#852-peak-index-in-a-mountain-array-star","text":"","title":"852. Peak Index in a Mountain Array $\\star$"},{"location":"golang/0801-0900/0851-0860/#853-car-fleet-starstar","text":"","title":"853. Car Fleet $\\star\\star$"},{"location":"golang/0801-0900/0851-0860/#854-k-similar-strings-starstarstar","text":"","title":"854. K-Similar Strings $\\star\\star\\star$"},{"location":"golang/0801-0900/0851-0860/#855-exam-room-starstar","text":"","title":"855. Exam Room $\\star\\star$"},{"location":"golang/0801-0900/0851-0860/#856-score-of-parentheses-starstar","text":"","title":"856. Score of Parentheses $\\star\\star$"},{"location":"golang/0801-0900/0851-0860/#857-minimum-cost-to-hire-k-workers-starstarstar","text":"","title":"857. Minimum Cost to Hire K Workers $\\star\\star\\star$"},{"location":"golang/0801-0900/0851-0860/#858-mirror-reflection-starstar","text":"","title":"858. Mirror Reflection $\\star\\star$"},{"location":"golang/0801-0900/0851-0860/#859-buddy-strings-star","text":"","title":"859. Buddy Strings $\\star$"},{"location":"golang/0801-0900/0851-0860/#860-lemonade-change-star","text":"","title":"860. Lemonade Change $\\star$"},{"location":"golang/0801-0900/0861-0870/","text":"861. Score After Flipping Matrix $\\star\\star$ 862. Shortest Subarray with Sum at Least K $\\star\\star\\star$ 863. All Nodes Distance K in Binary Tree $\\star\\star$ 864. Shortest Path to Get All Keys $\\star\\star\\star$ 865. Smallest Subtree with all the Deepest Nodes $\\star\\star$ 866. Prime Palindrome $\\star\\star$ 867. Transpose Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < vector < int >> transpose ( vector < vector < int >>& A ) { vector < vector < int >> ans ( A [ 0 ]. size (), vector < int > ( A . size ())); for ( int i = 0 ; i < A . size (); ++ i ) for ( int j = 0 ; j < A [ 0 ]. size (); ++ j ) ans [ j ][ i ] = A [ i ][ j ]; return ans ; } }; 868. Binary Gap $\\star$ 869. Reordered Power of 2 $\\star\\star$ 870. Advantage Shuffle $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > advantageCount ( vector < int >& A , vector < int >& B ) { multiset < int > set ( A . begin (), A . end ()); for ( int i = 0 ; i < B . size (); ++ i ) { auto p = * set . rbegin () <= B [ i ] ? set . begin () : set . upper_bound ( B [ i ]); A [ i ] = * p ; set . erase ( p ); } return A ; } };","title":"0861-0870"},{"location":"golang/0801-0900/0861-0870/#861-score-after-flipping-matrix-starstar","text":"","title":"861. Score After Flipping Matrix $\\star\\star$"},{"location":"golang/0801-0900/0861-0870/#862-shortest-subarray-with-sum-at-least-k-starstarstar","text":"","title":"862. Shortest Subarray with Sum at Least K $\\star\\star\\star$"},{"location":"golang/0801-0900/0861-0870/#863-all-nodes-distance-k-in-binary-tree-starstar","text":"","title":"863. All Nodes Distance K in Binary Tree $\\star\\star$"},{"location":"golang/0801-0900/0861-0870/#864-shortest-path-to-get-all-keys-starstarstar","text":"","title":"864. Shortest Path to Get All Keys $\\star\\star\\star$"},{"location":"golang/0801-0900/0861-0870/#865-smallest-subtree-with-all-the-deepest-nodes-starstar","text":"","title":"865. Smallest Subtree with all the Deepest Nodes $\\star\\star$"},{"location":"golang/0801-0900/0861-0870/#866-prime-palindrome-starstar","text":"","title":"866. Prime Palindrome $\\star\\star$"},{"location":"golang/0801-0900/0861-0870/#867-transpose-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < vector < int >> transpose ( vector < vector < int >>& A ) { vector < vector < int >> ans ( A [ 0 ]. size (), vector < int > ( A . size ())); for ( int i = 0 ; i < A . size (); ++ i ) for ( int j = 0 ; j < A [ 0 ]. size (); ++ j ) ans [ j ][ i ] = A [ i ][ j ]; return ans ; } };","title":"867. Transpose Matrix $\\star$"},{"location":"golang/0801-0900/0861-0870/#868-binary-gap-star","text":"","title":"868. Binary Gap $\\star$"},{"location":"golang/0801-0900/0861-0870/#869-reordered-power-of-2-starstar","text":"","title":"869. Reordered Power of 2 $\\star\\star$"},{"location":"golang/0801-0900/0861-0870/#870-advantage-shuffle-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > advantageCount ( vector < int >& A , vector < int >& B ) { multiset < int > set ( A . begin (), A . end ()); for ( int i = 0 ; i < B . size (); ++ i ) { auto p = * set . rbegin () <= B [ i ] ? set . begin () : set . upper_bound ( B [ i ]); A [ i ] = * p ; set . erase ( p ); } return A ; } };","title":"870. Advantage Shuffle $\\star\\star$"},{"location":"golang/0801-0900/0871-0880/","text":"871. Minimum Number of Refueling Stops $\\star\\star\\star$ 872. Leaf-Similar Trees $\\star$ 873. Length of Longest Fibonacci Subsequence $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) map [ A [ i ]] = i ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && map . count ( ai )) { int i = map [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; 874. Walking Robot Simulation $\\star$ 875. Koko Eating Bananas $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int minEatingSpeed ( vector < int >& piles , int H ) { int l = 1 ; int r = * max_element ( piles . begin (), piles . end ()) + 1 ; while ( l < r ) { int m = ( l + r ) >> 1 ; int hour = 0 ; for ( int pile : piles ) hour += ( pile - 1 ) / m + 1 ; if ( hour <= H ) r = m ; else l = m + 1 ; } return l ; } }; 876. Middle of the Linked List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * middleNode ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; auto slow = head ; auto fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; 877. Stone Game $\\star\\star$ 878. Nth Magical Number $\\star\\star\\star$ 879. Profitable Schemes $\\star\\star\\star$ 880. Decoded String at Index $\\star\\star$","title":"0871-0880"},{"location":"golang/0801-0900/0871-0880/#871-minimum-number-of-refueling-stops-starstarstar","text":"","title":"871. Minimum Number of Refueling Stops $\\star\\star\\star$"},{"location":"golang/0801-0900/0871-0880/#872-leaf-similar-trees-star","text":"","title":"872. Leaf-Similar Trees $\\star$"},{"location":"golang/0801-0900/0871-0880/#873-length-of-longest-fibonacci-subsequence-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) map [ A [ i ]] = i ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; ++ j ) for ( int k = j + 1 ; k < n ; ++ k ) { int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && map . count ( ai )) { int i = map [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } };","title":"873. Length of Longest Fibonacci Subsequence $\\star\\star$"},{"location":"golang/0801-0900/0871-0880/#874-walking-robot-simulation-star","text":"","title":"874. Walking Robot Simulation $\\star$"},{"location":"golang/0801-0900/0871-0880/#875-koko-eating-bananas-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int minEatingSpeed ( vector < int >& piles , int H ) { int l = 1 ; int r = * max_element ( piles . begin (), piles . end ()) + 1 ; while ( l < r ) { int m = ( l + r ) >> 1 ; int hour = 0 ; for ( int pile : piles ) hour += ( pile - 1 ) / m + 1 ; if ( hour <= H ) r = m ; else l = m + 1 ; } return l ; } };","title":"875. Koko Eating Bananas $\\star\\star$"},{"location":"golang/0801-0900/0871-0880/#876-middle-of-the-linked-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * middleNode ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; auto slow = head ; auto fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } };","title":"876. Middle of the Linked List $\\star$"},{"location":"golang/0801-0900/0871-0880/#877-stone-game-starstar","text":"","title":"877. Stone Game $\\star\\star$"},{"location":"golang/0801-0900/0871-0880/#878-nth-magical-number-starstarstar","text":"","title":"878. Nth Magical Number $\\star\\star\\star$"},{"location":"golang/0801-0900/0871-0880/#879-profitable-schemes-starstarstar","text":"","title":"879. Profitable Schemes $\\star\\star\\star$"},{"location":"golang/0801-0900/0871-0880/#880-decoded-string-at-index-starstar","text":"","title":"880. Decoded String at Index $\\star\\star$"},{"location":"golang/0801-0900/0881-0890/","text":"881. Boats to Save People $\\star\\star$ 882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$ 883. Projection Area of 3D Shapes $\\star$ 884. Uncommon Words from Two Sentences $\\star$ 885. Spiral Matrix III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> spiralMatrixIII ( int R , int C , int r0 , int c0 ) { vector < vector < int >> ans = {{ r0 , c0 }}; int x = 0 ; int y = 1 ; for ( int i = 0 ; ans . size () < R * C ; ++ i ) { for ( int j = 0 ; j < i / 2 + 1 ; ++ j ) { r0 += x ; c0 += y ; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . push_back ({ r0 , c0 }); } swap ( x , y ); y *= - 1 ; } return ans ; } }; 886. Possible Bipartition $\\star\\star$ 887. Super Egg Drop $\\star\\star\\star$ 888. Fair Candy Swap $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > fairCandySwap ( vector < int >& A , vector < int >& B ) { int diff = ( accumulate ( A . begin (), A . end (), 0 ) - accumulate ( B . begin (), B . end (), 0 )) / 2 ; unordered_set < int > set ( B . begin (), B . end ()); for ( int a : A ) if ( set . count ( a - diff )) return { a , a - diff }; throw ; } }; 889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : TreeNode * constructFromPrePost ( vector < int >& pre , vector < int >& post ) { return helper ( 0 , 0 , pre . size (), pre , post ); } private : TreeNode * helper ( int i , int j , int n , vector < int >& pre , vector < int >& post ) { if ( n == 0 ) return NULL ; TreeNode * root = new TreeNode ( pre [ i ]); if ( n == 1 ) return root ; int k = j ; while ( post [ k ] != pre [ i + 1 ]) ++ k ; int l = k - j + 1 ; root -> left = helper ( i + 1 , j , l , pre , post ); root -> right = helper ( i + l + 1 , j + l , n - l - 1 , pre , post ); return root ; } }; 890. Find and Replace Pattern $\\star\\star$","title":"0881-0890"},{"location":"golang/0801-0900/0881-0890/#881-boats-to-save-people-starstar","text":"","title":"881. Boats to Save People $\\star\\star$"},{"location":"golang/0801-0900/0881-0890/#882-reachable-nodes-in-subdivided-graph-starstarstar","text":"","title":"882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$"},{"location":"golang/0801-0900/0881-0890/#883-projection-area-of-3d-shapes-star","text":"","title":"883. Projection Area of 3D Shapes $\\star$"},{"location":"golang/0801-0900/0881-0890/#884-uncommon-words-from-two-sentences-star","text":"","title":"884. Uncommon Words from Two Sentences $\\star$"},{"location":"golang/0801-0900/0881-0890/#885-spiral-matrix-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> spiralMatrixIII ( int R , int C , int r0 , int c0 ) { vector < vector < int >> ans = {{ r0 , c0 }}; int x = 0 ; int y = 1 ; for ( int i = 0 ; ans . size () < R * C ; ++ i ) { for ( int j = 0 ; j < i / 2 + 1 ; ++ j ) { r0 += x ; c0 += y ; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . push_back ({ r0 , c0 }); } swap ( x , y ); y *= - 1 ; } return ans ; } };","title":"885. Spiral Matrix III $\\star\\star$"},{"location":"golang/0801-0900/0881-0890/#886-possible-bipartition-starstar","text":"","title":"886. Possible Bipartition $\\star\\star$"},{"location":"golang/0801-0900/0881-0890/#887-super-egg-drop-starstarstar","text":"","title":"887. Super Egg Drop $\\star\\star\\star$"},{"location":"golang/0801-0900/0881-0890/#888-fair-candy-swap-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > fairCandySwap ( vector < int >& A , vector < int >& B ) { int diff = ( accumulate ( A . begin (), A . end (), 0 ) - accumulate ( B . begin (), B . end (), 0 )) / 2 ; unordered_set < int > set ( B . begin (), B . end ()); for ( int a : A ) if ( set . count ( a - diff )) return { a , a - diff }; throw ; } };","title":"888. Fair Candy Swap $\\star$"},{"location":"golang/0801-0900/0881-0890/#889-construct-binary-tree-from-preorder-and-postorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : TreeNode * constructFromPrePost ( vector < int >& pre , vector < int >& post ) { return helper ( 0 , 0 , pre . size (), pre , post ); } private : TreeNode * helper ( int i , int j , int n , vector < int >& pre , vector < int >& post ) { if ( n == 0 ) return NULL ; TreeNode * root = new TreeNode ( pre [ i ]); if ( n == 1 ) return root ; int k = j ; while ( post [ k ] != pre [ i + 1 ]) ++ k ; int l = k - j + 1 ; root -> left = helper ( i + 1 , j , l , pre , post ); root -> right = helper ( i + l + 1 , j + l , n - l - 1 , pre , post ); return root ; } };","title":"889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$"},{"location":"golang/0801-0900/0881-0890/#890-find-and-replace-pattern-starstar","text":"","title":"890. Find and Replace Pattern $\\star\\star$"},{"location":"golang/0801-0900/0891-0900/","text":"891. Sum of Subsequence Widths $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int sumSubseqWidths ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; long exp = 1 ; sort ( A . begin (), A . end ()); for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ans ; } }; 892. Surface Area of 3D Shapes $\\star$ 893. Groups of Special-Equivalent Strings $\\star$ 894. All Possible Full Binary Trees $\\star\\star$ 895. Maximum Frequency Stack $\\star\\star\\star$ 896. Monotonic Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isMonotonic ( vector < int >& A ) { bool increasing = true ; bool decreasing = true ; for ( int i = 1 ; i < A . size (); ++ i ) { increasing &= A [ i - 1 ] <= A [ i ]; decreasing &= A [ i - 1 ] >= A [ i ]; } return increasing || decreasing ; } }; 897. Increasing Order Search Tree $\\star$ 898. Bitwise ORs of Subarrays $\\star\\star$ 899. Orderly Queue $\\star\\star\\star$ 900. RLE Iterator $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class RLEIterator { public : RLEIterator ( vector < int >& A ) { this -> A = A ; } int next ( int n ) { while ( index < A . size () && A [ index ] < n ) { n -= A [ index ]; index += 2 ; } if ( index == A . size ()) return - 1 ; A [ index ] -= n ; return A [ index + 1 ]; } private : int index = 0 ; vector < int > A ; };","title":"0891-0900"},{"location":"golang/0801-0900/0891-0900/#891-sum-of-subsequence-widths-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int sumSubseqWidths ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; long exp = 1 ; sort ( A . begin (), A . end ()); for ( int i = 0 ; i < n ; ++ i , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ans ; } };","title":"891. Sum of Subsequence Widths $\\star\\star\\star$"},{"location":"golang/0801-0900/0891-0900/#892-surface-area-of-3d-shapes-star","text":"","title":"892. Surface Area of 3D Shapes $\\star$"},{"location":"golang/0801-0900/0891-0900/#893-groups-of-special-equivalent-strings-star","text":"","title":"893. Groups of Special-Equivalent Strings $\\star$"},{"location":"golang/0801-0900/0891-0900/#894-all-possible-full-binary-trees-starstar","text":"","title":"894. All Possible Full Binary Trees $\\star\\star$"},{"location":"golang/0801-0900/0891-0900/#895-maximum-frequency-stack-starstarstar","text":"","title":"895. Maximum Frequency Stack $\\star\\star\\star$"},{"location":"golang/0801-0900/0891-0900/#896-monotonic-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isMonotonic ( vector < int >& A ) { bool increasing = true ; bool decreasing = true ; for ( int i = 1 ; i < A . size (); ++ i ) { increasing &= A [ i - 1 ] <= A [ i ]; decreasing &= A [ i - 1 ] >= A [ i ]; } return increasing || decreasing ; } };","title":"896. Monotonic Array $\\star$"},{"location":"golang/0801-0900/0891-0900/#897-increasing-order-search-tree-star","text":"","title":"897. Increasing Order Search Tree $\\star$"},{"location":"golang/0801-0900/0891-0900/#898-bitwise-ors-of-subarrays-starstar","text":"","title":"898. Bitwise ORs of Subarrays $\\star\\star$"},{"location":"golang/0801-0900/0891-0900/#899-orderly-queue-starstarstar","text":"","title":"899. Orderly Queue $\\star\\star\\star$"},{"location":"golang/0801-0900/0891-0900/#900-rle-iterator-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class RLEIterator { public : RLEIterator ( vector < int >& A ) { this -> A = A ; } int next ( int n ) { while ( index < A . size () && A [ index ] < n ) { n -= A [ index ]; index += 2 ; } if ( index == A . size ()) return - 1 ; A [ index ] -= n ; return A [ index + 1 ]; } private : int index = 0 ; vector < int > A ; };","title":"900. RLE Iterator $\\star\\star$"},{"location":"golang/0901-1000/0901-0910/","text":"901. Online Stock Span $\\star\\star$ 902. Numbers At Most N Given Digit Set $\\star\\star\\star$ 903. Valid Permutations for DI Sequence $\\star\\star\\star$ 904. Fruit Into Baskets $\\star\\star$ 905. Sort Array By Parity $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > sortArrayByParity ( vector < int >& A ) { int l = 0 ; int r = A . size () - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) swap ( A [ l ], A [ r ]); if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } }; 906. Super Palindromes $\\star\\star\\star$ 907. Sum of Subarray Minimums $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int sumSubarrayMins ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; vector < int > prev ( n , - 1 ); vector < int > next ( n , n ); stack < int > stack1 ; stack < int > stack2 ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! stack1 . empty () && A [ stack1 . top ()] > A [ i ]) stack1 . pop (); prev [ i ] = stack1 . empty () ? - 1 : stack1 . top (); stack1 . push ( i ); while ( ! stack2 . empty () && A [ stack2 . top ()] > A [ i ]) { int index = stack2 . top (); stack2 . pop (); next [ index ] = i ; } stack2 . push ( i ); } for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + A [ i ] * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod ; return ans ; } }; 908. Smallest Range I $\\star$ 909. Snakes and Ladders $\\star\\star$ 910. Smallest Range II $\\star\\star$","title":"0901-0910"},{"location":"golang/0901-1000/0901-0910/#901-online-stock-span-starstar","text":"","title":"901. Online Stock Span $\\star\\star$"},{"location":"golang/0901-1000/0901-0910/#902-numbers-at-most-n-given-digit-set-starstarstar","text":"","title":"902. Numbers At Most N Given Digit Set $\\star\\star\\star$"},{"location":"golang/0901-1000/0901-0910/#903-valid-permutations-for-di-sequence-starstarstar","text":"","title":"903. Valid Permutations for DI Sequence $\\star\\star\\star$"},{"location":"golang/0901-1000/0901-0910/#904-fruit-into-baskets-starstar","text":"","title":"904. Fruit Into Baskets $\\star\\star$"},{"location":"golang/0901-1000/0901-0910/#905-sort-array-by-parity-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > sortArrayByParity ( vector < int >& A ) { int l = 0 ; int r = A . size () - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) swap ( A [ l ], A [ r ]); if ( A [ l ] % 2 == 0 ) ++ l ; if ( A [ r ] % 2 == 1 ) -- r ; } return A ; } };","title":"905. Sort Array By Parity $\\star$"},{"location":"golang/0901-1000/0901-0910/#906-super-palindromes-starstarstar","text":"","title":"906. Super Palindromes $\\star\\star\\star$"},{"location":"golang/0901-1000/0901-0910/#907-sum-of-subarray-minimums-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int sumSubarrayMins ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; vector < int > prev ( n , - 1 ); vector < int > next ( n , n ); stack < int > stack1 ; stack < int > stack2 ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! stack1 . empty () && A [ stack1 . top ()] > A [ i ]) stack1 . pop (); prev [ i ] = stack1 . empty () ? - 1 : stack1 . top (); stack1 . push ( i ); while ( ! stack2 . empty () && A [ stack2 . top ()] > A [ i ]) { int index = stack2 . top (); stack2 . pop (); next [ index ] = i ; } stack2 . push ( i ); } for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + A [ i ] * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod ; return ans ; } };","title":"907. Sum of Subarray Minimums $\\star\\star$"},{"location":"golang/0901-1000/0901-0910/#908-smallest-range-i-star","text":"","title":"908. Smallest Range I $\\star$"},{"location":"golang/0901-1000/0901-0910/#909-snakes-and-ladders-starstar","text":"","title":"909. Snakes and Ladders $\\star\\star$"},{"location":"golang/0901-1000/0901-0910/#910-smallest-range-ii-starstar","text":"","title":"910. Smallest Range II $\\star\\star$"},{"location":"golang/0901-1000/0911-0920/","text":"911. Online Election $\\star\\star$ 912. Sort an Array $\\star\\star$ 913. Cat and Mouse $\\star\\star\\star$ 914. X of a Kind in a Deck of Cards $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool hasGroupsSizeX ( vector < int >& deck ) { unordered_map < int , int > numCounts ; for ( int d : deck ) ++ numCounts [ d ]; int gcd = 0 ; for ( auto & [ _ , value ] : numCounts ) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } }; 915. Partition Array into Disjoint Intervals $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int partitionDisjoint ( vector < int >& A ) { const int n = A . size (); vector < int > min ( n ); min [ n - 1 ] = A [ n - 1 ]; int max = INT_MIN ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], A [ i ]); for ( int i = 0 ; i < n ; ++ i ) { max = std :: max ( max , A [ i ]); if ( max <= min [ i + 1 ]) return i + 1 ; } throw ; } }; 916. Word Subsets $\\star\\star$ 917. Reverse Only Letters $\\star$ 918. Maximum Sum Circular Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int maxSubarraySumCircular ( vector < int >& A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = INT_MIN ; int minSum = INT_MAX ; for ( int a : A ) { totalSum += a ; currMaxSum = max ( currMaxSum + a , a ); currMinSum = min ( currMinSum + a , a ); maxSum = max ( maxSum , currMaxSum ); minSum = min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : max ( maxSum , totalSum - minSum ); } }; 919. Complete Binary Tree Inserter $\\star\\star$ 920. Number of Music Playlists $\\star\\star\\star$","title":"0911-0920"},{"location":"golang/0901-1000/0911-0920/#911-online-election-starstar","text":"","title":"911. Online Election $\\star\\star$"},{"location":"golang/0901-1000/0911-0920/#912-sort-an-array-starstar","text":"","title":"912. Sort an Array $\\star\\star$"},{"location":"golang/0901-1000/0911-0920/#913-cat-and-mouse-starstarstar","text":"","title":"913. Cat and Mouse $\\star\\star\\star$"},{"location":"golang/0901-1000/0911-0920/#914-x-of-a-kind-in-a-deck-of-cards-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool hasGroupsSizeX ( vector < int >& deck ) { unordered_map < int , int > numCounts ; for ( int d : deck ) ++ numCounts [ d ]; int gcd = 0 ; for ( auto & [ _ , value ] : numCounts ) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } };","title":"914. X of a Kind in a Deck of Cards $\\star$"},{"location":"golang/0901-1000/0911-0920/#915-partition-array-into-disjoint-intervals-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int partitionDisjoint ( vector < int >& A ) { const int n = A . size (); vector < int > min ( n ); min [ n - 1 ] = A [ n - 1 ]; int max = INT_MIN ; for ( int i = n - 2 ; i >= 0 ; -- i ) min [ i ] = std :: min ( min [ i + 1 ], A [ i ]); for ( int i = 0 ; i < n ; ++ i ) { max = std :: max ( max , A [ i ]); if ( max <= min [ i + 1 ]) return i + 1 ; } throw ; } };","title":"915. Partition Array into Disjoint Intervals $\\star\\star$"},{"location":"golang/0901-1000/0911-0920/#916-word-subsets-starstar","text":"","title":"916. Word Subsets $\\star\\star$"},{"location":"golang/0901-1000/0911-0920/#917-reverse-only-letters-star","text":"","title":"917. Reverse Only Letters $\\star$"},{"location":"golang/0901-1000/0911-0920/#918-maximum-sum-circular-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int maxSubarraySumCircular ( vector < int >& A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = INT_MIN ; int minSum = INT_MAX ; for ( int a : A ) { totalSum += a ; currMaxSum = max ( currMaxSum + a , a ); currMinSum = min ( currMinSum + a , a ); maxSum = max ( maxSum , currMaxSum ); minSum = min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : max ( maxSum , totalSum - minSum ); } };","title":"918. Maximum Sum Circular Subarray $\\star\\star$"},{"location":"golang/0901-1000/0911-0920/#919-complete-binary-tree-inserter-starstar","text":"","title":"919. Complete Binary Tree Inserter $\\star\\star$"},{"location":"golang/0901-1000/0911-0920/#920-number-of-music-playlists-starstarstar","text":"","title":"920. Number of Music Playlists $\\star\\star\\star$"},{"location":"golang/0901-1000/0921-0930/","text":"921. Minimum Add to Make Parentheses Valid $\\star\\star$ 922. Sort Array By Parity II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortArrayByParityII ( vector < int >& A ) { const int n = A . size (); for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) swap ( A [ i ], A [ j ]); } return A ; } }; 923. 3Sum With Multiplicity $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int threeSumMulti ( vector < int >& A , int target ) { long ans = 0 ; unordered_map < int , long > map ; for ( int a : A ) ++ map [ a ]; for ( auto & [ i , x ] : map ) for ( auto & [ j , y ] : map ) { int k = target - i - j ; if ( ! map . count ( k )) continue ; if ( i == j && j == k ) ans += x * ( x - 1 ) * ( x - 2 ) / 6 ; else if ( i == j && j != k ) ans += x * ( x - 1 ) / 2 * map [ k ]; else if ( i < j && j < k ) ans += x * y * map [ k ]; } return ans % int ( 1e9 + 7 ); } }; 924. Minimize Malware Spread $\\star\\star\\star$ 925. Long Pressed Name $\\star$ 926. Flip String to Monotone Increasing $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int minFlipsMonoIncr ( string S ) { vector < int > dp ( 2 ); for ( int i = 0 ; i < S . length (); ++ i ) { int temp = dp [ 0 ] + ( S [ i ] == '1' ); dp [ 1 ] = min ( dp [ 0 ], dp [ 1 ]) + ( S [ i ] == '0' ); dp [ 0 ] = temp ; } return min ( dp [ 0 ], dp [ 1 ]); } }; 927. Three Equal Parts $\\star\\star\\star$ 928. Minimize Malware Spread II $\\star\\star\\star$ 929. Unique Email Addresses $\\star$ 930. Binary Subarrays With Sum $\\star\\star$","title":"0921-0930"},{"location":"golang/0901-1000/0921-0930/#921-minimum-add-to-make-parentheses-valid-starstar","text":"","title":"921. Minimum Add to Make Parentheses Valid $\\star\\star$"},{"location":"golang/0901-1000/0921-0930/#922-sort-array-by-parity-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortArrayByParityII ( vector < int >& A ) { const int n = A . size (); for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) swap ( A [ i ], A [ j ]); } return A ; } };","title":"922. Sort Array By Parity II $\\star$"},{"location":"golang/0901-1000/0921-0930/#923-3sum-with-multiplicity-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int threeSumMulti ( vector < int >& A , int target ) { long ans = 0 ; unordered_map < int , long > map ; for ( int a : A ) ++ map [ a ]; for ( auto & [ i , x ] : map ) for ( auto & [ j , y ] : map ) { int k = target - i - j ; if ( ! map . count ( k )) continue ; if ( i == j && j == k ) ans += x * ( x - 1 ) * ( x - 2 ) / 6 ; else if ( i == j && j != k ) ans += x * ( x - 1 ) / 2 * map [ k ]; else if ( i < j && j < k ) ans += x * y * map [ k ]; } return ans % int ( 1e9 + 7 ); } };","title":"923. 3Sum With Multiplicity $\\star\\star$"},{"location":"golang/0901-1000/0921-0930/#924-minimize-malware-spread-starstarstar","text":"","title":"924. Minimize Malware Spread $\\star\\star\\star$"},{"location":"golang/0901-1000/0921-0930/#925-long-pressed-name-star","text":"","title":"925. Long Pressed Name $\\star$"},{"location":"golang/0901-1000/0921-0930/#926-flip-string-to-monotone-increasing-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int minFlipsMonoIncr ( string S ) { vector < int > dp ( 2 ); for ( int i = 0 ; i < S . length (); ++ i ) { int temp = dp [ 0 ] + ( S [ i ] == '1' ); dp [ 1 ] = min ( dp [ 0 ], dp [ 1 ]) + ( S [ i ] == '0' ); dp [ 0 ] = temp ; } return min ( dp [ 0 ], dp [ 1 ]); } };","title":"926. Flip String to Monotone Increasing $\\star\\star$"},{"location":"golang/0901-1000/0921-0930/#927-three-equal-parts-starstarstar","text":"","title":"927. Three Equal Parts $\\star\\star\\star$"},{"location":"golang/0901-1000/0921-0930/#928-minimize-malware-spread-ii-starstarstar","text":"","title":"928. Minimize Malware Spread II $\\star\\star\\star$"},{"location":"golang/0901-1000/0921-0930/#929-unique-email-addresses-star","text":"","title":"929. Unique Email Addresses $\\star$"},{"location":"golang/0901-1000/0921-0930/#930-binary-subarrays-with-sum-starstar","text":"","title":"930. Binary Subarrays With Sum $\\star\\star$"},{"location":"golang/0901-1000/0931-0940/","text":"931. Minimum Falling Path Sum $\\star\\star$ 932. Beautiful Array $\\star\\star$ 933. Number of Recent Calls $\\star$ 934. Shortest Bridge $\\star\\star$ 935. Knight Dialer $\\star\\star$ 936. Stamping The Sequence $\\star\\star\\star$ 937. Reorder Data in Log Files $\\star$ 938. Range Sum of BST $\\star$ 939. Minimum Area Rectangle $\\star\\star$ 940. Distinct Subsequences II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int distinctSubseqII ( string S ) { vector < long > map ( 26 ); for ( char c : S ) map [ c - 'a' ] = accumulate ( map . begin (), map . end (), 1L ) % int ( 1e9 + 7 ); return accumulate ( map . begin (), map . end (), 0L ) % int ( 1e9 + 7 ); } };","title":"0931-0940"},{"location":"golang/0901-1000/0931-0940/#931-minimum-falling-path-sum-starstar","text":"","title":"931. Minimum Falling Path Sum $\\star\\star$"},{"location":"golang/0901-1000/0931-0940/#932-beautiful-array-starstar","text":"","title":"932. Beautiful Array $\\star\\star$"},{"location":"golang/0901-1000/0931-0940/#933-number-of-recent-calls-star","text":"","title":"933. Number of Recent Calls $\\star$"},{"location":"golang/0901-1000/0931-0940/#934-shortest-bridge-starstar","text":"","title":"934. Shortest Bridge $\\star\\star$"},{"location":"golang/0901-1000/0931-0940/#935-knight-dialer-starstar","text":"","title":"935. Knight Dialer $\\star\\star$"},{"location":"golang/0901-1000/0931-0940/#936-stamping-the-sequence-starstarstar","text":"","title":"936. Stamping The Sequence $\\star\\star\\star$"},{"location":"golang/0901-1000/0931-0940/#937-reorder-data-in-log-files-star","text":"","title":"937. Reorder Data in Log Files $\\star$"},{"location":"golang/0901-1000/0931-0940/#938-range-sum-of-bst-star","text":"","title":"938. Range Sum of BST $\\star$"},{"location":"golang/0901-1000/0931-0940/#939-minimum-area-rectangle-starstar","text":"","title":"939. Minimum Area Rectangle $\\star\\star$"},{"location":"golang/0901-1000/0931-0940/#940-distinct-subsequences-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int distinctSubseqII ( string S ) { vector < long > map ( 26 ); for ( char c : S ) map [ c - 'a' ] = accumulate ( map . begin (), map . end (), 1L ) % int ( 1e9 + 7 ); return accumulate ( map . begin (), map . end (), 0L ) % int ( 1e9 + 7 ); } };","title":"940. Distinct Subsequences II $\\star\\star\\star$"},{"location":"golang/0901-1000/0941-0950/","text":"941. Valid Mountain Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool validMountainArray ( vector < int >& A ) { if ( A . size () < 3 ) return false ; int l = 0 ; int r = A . size () - 1 ; while ( l + 1 < A . size () && A [ l ] < A [ l + 1 ]) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ]) -- r ; return l > 0 && r < A . size () - 1 && l == r ; } }; 942. DI String Match $\\star$ 943. Find the Shortest Superstring $\\star\\star\\star$ 944. Delete Columns to Make Sorted $\\star$ 945. Minimum Increment to Make Array Unique $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int minIncrementForUnique ( vector < int >& A ) { int ans = 0 ; int minAvailable = 0 ; sort ( A . begin (), A . end ()); for ( int a : A ) { ans += max ( minAvailable - a , 0 ); minAvailable = max ( minAvailable , a ) + 1 ; } return ans ; } }; 946. Validate Stack Sequences $\\star\\star$ 947. Most Stones Removed with Same Row or Column $\\star\\star$ 948. Bag of Tokens $\\star\\star$ 949. Largest Time for Given Digits $\\star$ 950. Reveal Cards In Increasing Order $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > deckRevealedIncreasing ( vector < int >& deck ) { sort ( deck . begin (), deck . end (), greater < int > ()); deque < int > deque = { deck [ 0 ]}; for ( int i = 1 ; i < deck . size (); ++ i ) { deque . push_front ( deque . back ()); deque . pop_back (); deque . push_front ( deck [ i ]); } return vector < int > ( deque . begin (), deque . end ()); } };","title":"0941-0950"},{"location":"golang/0901-1000/0941-0950/#941-valid-mountain-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool validMountainArray ( vector < int >& A ) { if ( A . size () < 3 ) return false ; int l = 0 ; int r = A . size () - 1 ; while ( l + 1 < A . size () && A [ l ] < A [ l + 1 ]) ++ l ; while ( r > 0 && A [ r ] < A [ r - 1 ]) -- r ; return l > 0 && r < A . size () - 1 && l == r ; } };","title":"941. Valid Mountain Array $\\star$"},{"location":"golang/0901-1000/0941-0950/#942-di-string-match-star","text":"","title":"942. DI String Match $\\star$"},{"location":"golang/0901-1000/0941-0950/#943-find-the-shortest-superstring-starstarstar","text":"","title":"943. Find the Shortest Superstring $\\star\\star\\star$"},{"location":"golang/0901-1000/0941-0950/#944-delete-columns-to-make-sorted-star","text":"","title":"944. Delete Columns to Make Sorted $\\star$"},{"location":"golang/0901-1000/0941-0950/#945-minimum-increment-to-make-array-unique-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int minIncrementForUnique ( vector < int >& A ) { int ans = 0 ; int minAvailable = 0 ; sort ( A . begin (), A . end ()); for ( int a : A ) { ans += max ( minAvailable - a , 0 ); minAvailable = max ( minAvailable , a ) + 1 ; } return ans ; } };","title":"945. Minimum Increment to Make Array Unique $\\star\\star$"},{"location":"golang/0901-1000/0941-0950/#946-validate-stack-sequences-starstar","text":"","title":"946. Validate Stack Sequences $\\star\\star$"},{"location":"golang/0901-1000/0941-0950/#947-most-stones-removed-with-same-row-or-column-starstar","text":"","title":"947. Most Stones Removed with Same Row or Column $\\star\\star$"},{"location":"golang/0901-1000/0941-0950/#948-bag-of-tokens-starstar","text":"","title":"948. Bag of Tokens $\\star\\star$"},{"location":"golang/0901-1000/0941-0950/#949-largest-time-for-given-digits-star","text":"","title":"949. Largest Time for Given Digits $\\star$"},{"location":"golang/0901-1000/0941-0950/#950-reveal-cards-in-increasing-order-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > deckRevealedIncreasing ( vector < int >& deck ) { sort ( deck . begin (), deck . end (), greater < int > ()); deque < int > deque = { deck [ 0 ]}; for ( int i = 1 ; i < deck . size (); ++ i ) { deque . push_front ( deque . back ()); deque . pop_back (); deque . push_front ( deck [ i ]); } return vector < int > ( deque . begin (), deque . end ()); } };","title":"950. Reveal Cards In Increasing Order $\\star\\star$"},{"location":"golang/0901-1000/0951-0960/","text":"951. Flip Equivalent Binary Trees $\\star\\star$ 952. Largest Component Size by Common Factor $\\star\\star\\star$ 953. Verifying an Alien Dictionary $\\star$ 954. Array of Doubled Pairs $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool canReorderDoubled ( vector < int >& A ) { unordered_map < int , int > count ; for ( int a : A ) ++ count [ a ]; sort ( A . begin (), A . end (), []( int a , int b ) { return abs ( a ) < abs ( b ); }); for ( int a : A ) { if ( count [ a ] == 0 ) continue ; if ( count [ 2 * a ] == 0 ) return false ; -- count [ a ]; -- count [ 2 * a ]; } return true ; } }; 955. Delete Columns to Make Sorted II $\\star\\star$ 956. Tallest Billboard $\\star\\star\\star$ 957. Prison Cells After N Days $\\star\\star$ 958. Check Completeness of a Binary Tree $\\star\\star$ 959. Regions Cut By Slashes $\\star\\star$ 960. Delete Columns to Make Sorted III $\\star\\star\\star$","title":"0951-0960"},{"location":"golang/0901-1000/0951-0960/#951-flip-equivalent-binary-trees-starstar","text":"","title":"951. Flip Equivalent Binary Trees $\\star\\star$"},{"location":"golang/0901-1000/0951-0960/#952-largest-component-size-by-common-factor-starstarstar","text":"","title":"952. Largest Component Size by Common Factor $\\star\\star\\star$"},{"location":"golang/0901-1000/0951-0960/#953-verifying-an-alien-dictionary-star","text":"","title":"953. Verifying an Alien Dictionary $\\star$"},{"location":"golang/0901-1000/0951-0960/#954-array-of-doubled-pairs-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool canReorderDoubled ( vector < int >& A ) { unordered_map < int , int > count ; for ( int a : A ) ++ count [ a ]; sort ( A . begin (), A . end (), []( int a , int b ) { return abs ( a ) < abs ( b ); }); for ( int a : A ) { if ( count [ a ] == 0 ) continue ; if ( count [ 2 * a ] == 0 ) return false ; -- count [ a ]; -- count [ 2 * a ]; } return true ; } };","title":"954. Array of Doubled Pairs $\\star\\star$"},{"location":"golang/0901-1000/0951-0960/#955-delete-columns-to-make-sorted-ii-starstar","text":"","title":"955. Delete Columns to Make Sorted II $\\star\\star$"},{"location":"golang/0901-1000/0951-0960/#956-tallest-billboard-starstarstar","text":"","title":"956. Tallest Billboard $\\star\\star\\star$"},{"location":"golang/0901-1000/0951-0960/#957-prison-cells-after-n-days-starstar","text":"","title":"957. Prison Cells After N Days $\\star\\star$"},{"location":"golang/0901-1000/0951-0960/#958-check-completeness-of-a-binary-tree-starstar","text":"","title":"958. Check Completeness of a Binary Tree $\\star\\star$"},{"location":"golang/0901-1000/0951-0960/#959-regions-cut-by-slashes-starstar","text":"","title":"959. Regions Cut By Slashes $\\star\\star$"},{"location":"golang/0901-1000/0951-0960/#960-delete-columns-to-make-sorted-iii-starstarstar","text":"","title":"960. Delete Columns to Make Sorted III $\\star\\star\\star$"},{"location":"golang/0901-1000/0961-0970/","text":"961. N-Repeated Element in Size 2N Array $\\star$ 962. Maximum Width Ramp $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxWidthRamp ( vector < int >& A ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i < A . size (); ++ i ) if ( stack . empty () || A [ i ] < A [ stack . top ()]) stack . push ( i ); for ( int i = A . size () - 1 ; i > ans ; -- i ) while ( ! stack . empty () && A [ i ] >= A [ stack . top ()]) ans = max ( ans , i - stack . top ()), stack . pop (); return ans ; } }; 963. Minimum Area Rectangle II $\\star\\star$ 964. Least Operators to Express Number $\\star\\star\\star$ 965. Univalued Binary Tree $\\star$ 966. Vowel Spellchecker $\\star\\star$ 967. Numbers With Same Consecutive Differences $\\star\\star$ 968. Binary Tree Cameras $\\star\\star\\star$ 969. Pancake Sorting $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > pancakeSort ( vector < int >& A ) { vector < int > ans ; for ( int target = A . size (); target >= 1 ; -- target ) { int index = find ( A , target ); reverse ( A . begin (), A . begin () + index + 1 ); reverse ( A . begin (), A . begin () + target ); ans . push_back ( index + 1 ); ans . push_back ( target ); } return ans ; } private : int find ( vector < int >& A , int target ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( A [ i ] == target ) return i ; throw ; } }; 970. Powerful Integers $\\star$","title":"0961-0970"},{"location":"golang/0901-1000/0961-0970/#961-n-repeated-element-in-size-2n-array-star","text":"","title":"961. N-Repeated Element in Size 2N Array $\\star$"},{"location":"golang/0901-1000/0961-0970/#962-maximum-width-ramp-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxWidthRamp ( vector < int >& A ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i < A . size (); ++ i ) if ( stack . empty () || A [ i ] < A [ stack . top ()]) stack . push ( i ); for ( int i = A . size () - 1 ; i > ans ; -- i ) while ( ! stack . empty () && A [ i ] >= A [ stack . top ()]) ans = max ( ans , i - stack . top ()), stack . pop (); return ans ; } };","title":"962. Maximum Width Ramp $\\star\\star$"},{"location":"golang/0901-1000/0961-0970/#963-minimum-area-rectangle-ii-starstar","text":"","title":"963. Minimum Area Rectangle II $\\star\\star$"},{"location":"golang/0901-1000/0961-0970/#964-least-operators-to-express-number-starstarstar","text":"","title":"964. Least Operators to Express Number $\\star\\star\\star$"},{"location":"golang/0901-1000/0961-0970/#965-univalued-binary-tree-star","text":"","title":"965. Univalued Binary Tree $\\star$"},{"location":"golang/0901-1000/0961-0970/#966-vowel-spellchecker-starstar","text":"","title":"966. Vowel Spellchecker $\\star\\star$"},{"location":"golang/0901-1000/0961-0970/#967-numbers-with-same-consecutive-differences-starstar","text":"","title":"967. Numbers With Same Consecutive Differences $\\star\\star$"},{"location":"golang/0901-1000/0961-0970/#968-binary-tree-cameras-starstarstar","text":"","title":"968. Binary Tree Cameras $\\star\\star\\star$"},{"location":"golang/0901-1000/0961-0970/#969-pancake-sorting-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > pancakeSort ( vector < int >& A ) { vector < int > ans ; for ( int target = A . size (); target >= 1 ; -- target ) { int index = find ( A , target ); reverse ( A . begin (), A . begin () + index + 1 ); reverse ( A . begin (), A . begin () + target ); ans . push_back ( index + 1 ); ans . push_back ( target ); } return ans ; } private : int find ( vector < int >& A , int target ) { for ( int i = 0 ; i < A . size (); ++ i ) if ( A [ i ] == target ) return i ; throw ; } };","title":"969. Pancake Sorting $\\star\\star$"},{"location":"golang/0901-1000/0961-0970/#970-powerful-integers-star","text":"","title":"970. Powerful Integers $\\star$"},{"location":"golang/0901-1000/0971-0980/","text":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$ 972. Equal Rational Numbers $\\star\\star\\star$ 973. K Closest Points to Origin $\\star\\star$ 974. Subarray Sums Divisible by K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraysDivByK ( vector < int >& A , int K ) { int ans = 0 ; int presum = 0 ; vector < int > count ( K ); count [ 0 ] = 1 ; for ( int a : A ) { presum = ( presum + a % K + K ) % K ; ans += count [ presum ]; ++ count [ presum ]; } return ans ; } }; 975. Odd Even Jump $\\star\\star\\star$ 976. Largest Perimeter Triangle $\\star$ 977. Squares of a Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortedSquares ( vector < int >& A ) { int n = A . size (); int l = 0 ; int r = n - 1 ; vector < int > ans ( n ); while ( l <= r ) ans [ -- n ] = abs ( A [ l ]) > abs ( A [ r ]) ? A [ l ] * A [ l ++ ] : A [ r ] * A [ r -- ]; return ans ; } }; 978. Longest Turbulent Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxTurbulenceSize ( vector < int >& A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . size (); ++ i ) { if ( A [ i ] > A [ i - 1 ]) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ]) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = max ( ans , max ( increasing , decreasing )); } return ans ; } }; 979. Distribute Coins in Binary Tree $\\star\\star$ 980. Unique Paths III $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int uniquePathsIII ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; int empty = 1 ; int sx ; int sy ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 0 ) { ++ empty ; } else if ( grid [ i ][ j ] == 1 ) { sx = i ; sy = j ; } else if ( grid [ i ][ j ] == 2 ) { ex = i ; ey = j ; } } dfs ( grid , empty , sx , sy , ans ); return ans ; } private : int ex ; int ey ; void dfs ( vector < vector < int >>& grid , int empty , int i , int j , int & ans ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] < 0 ) return ; if ( i == ex && j == ey ) { if ( empty == 0 ) ++ ans ; return ; } grid [ i ][ j ] = - 2 ; dfs ( grid , empty - 1 , i + 1 , j , ans ); dfs ( grid , empty - 1 , i - 1 , j , ans ); dfs ( grid , empty - 1 , i , j + 1 , ans ); dfs ( grid , empty - 1 , i , j - 1 , ans ); grid [ i ][ j ] = 0 ; } };","title":"0971-0980"},{"location":"golang/0901-1000/0971-0980/#971-flip-binary-tree-to-match-preorder-traversal-starstar","text":"","title":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$"},{"location":"golang/0901-1000/0971-0980/#972-equal-rational-numbers-starstarstar","text":"","title":"972. Equal Rational Numbers $\\star\\star\\star$"},{"location":"golang/0901-1000/0971-0980/#973-k-closest-points-to-origin-starstar","text":"","title":"973. K Closest Points to Origin $\\star\\star$"},{"location":"golang/0901-1000/0971-0980/#974-subarray-sums-divisible-by-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraysDivByK ( vector < int >& A , int K ) { int ans = 0 ; int presum = 0 ; vector < int > count ( K ); count [ 0 ] = 1 ; for ( int a : A ) { presum = ( presum + a % K + K ) % K ; ans += count [ presum ]; ++ count [ presum ]; } return ans ; } };","title":"974. Subarray Sums Divisible by K $\\star\\star$"},{"location":"golang/0901-1000/0971-0980/#975-odd-even-jump-starstarstar","text":"","title":"975. Odd Even Jump $\\star\\star\\star$"},{"location":"golang/0901-1000/0971-0980/#976-largest-perimeter-triangle-star","text":"","title":"976. Largest Perimeter Triangle $\\star$"},{"location":"golang/0901-1000/0971-0980/#977-squares-of-a-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortedSquares ( vector < int >& A ) { int n = A . size (); int l = 0 ; int r = n - 1 ; vector < int > ans ( n ); while ( l <= r ) ans [ -- n ] = abs ( A [ l ]) > abs ( A [ r ]) ? A [ l ] * A [ l ++ ] : A [ r ] * A [ r -- ]; return ans ; } };","title":"977. Squares of a Sorted Array $\\star$"},{"location":"golang/0901-1000/0971-0980/#978-longest-turbulent-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxTurbulenceSize ( vector < int >& A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . size (); ++ i ) { if ( A [ i ] > A [ i - 1 ]) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ]) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = max ( ans , max ( increasing , decreasing )); } return ans ; } };","title":"978. Longest Turbulent Subarray $\\star\\star$"},{"location":"golang/0901-1000/0971-0980/#979-distribute-coins-in-binary-tree-starstar","text":"","title":"979. Distribute Coins in Binary Tree $\\star\\star$"},{"location":"golang/0901-1000/0971-0980/#980-unique-paths-iii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int uniquePathsIII ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; int empty = 1 ; int sx ; int sy ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { if ( grid [ i ][ j ] == 0 ) { ++ empty ; } else if ( grid [ i ][ j ] == 1 ) { sx = i ; sy = j ; } else if ( grid [ i ][ j ] == 2 ) { ex = i ; ey = j ; } } dfs ( grid , empty , sx , sy , ans ); return ans ; } private : int ex ; int ey ; void dfs ( vector < vector < int >>& grid , int empty , int i , int j , int & ans ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] < 0 ) return ; if ( i == ex && j == ey ) { if ( empty == 0 ) ++ ans ; return ; } grid [ i ][ j ] = - 2 ; dfs ( grid , empty - 1 , i + 1 , j , ans ); dfs ( grid , empty - 1 , i - 1 , j , ans ); dfs ( grid , empty - 1 , i , j + 1 , ans ); dfs ( grid , empty - 1 , i , j - 1 , ans ); grid [ i ][ j ] = 0 ; } };","title":"980. Unique Paths III $\\star\\star\\star$"},{"location":"golang/0901-1000/0981-0990/","text":"981. Time Based Key-Value Store $\\star\\star$ 982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$ 983. Minimum Cost For Tickets $\\star\\star$ 984. String Without AAA or BBB $\\star\\star$ 985. Sum of Even Numbers After Queries $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > sumEvenAfterQueries ( vector < int >& A , vector < vector < int >>& queries ) { vector < int > ans ; int sum = accumulate ( A . begin (), A . end (), 0 , []( int a , int b ) { return a + ( b % 2 == 0 ? b : 0 ); }); for ( vector < int >& query : queries ) { if ( A [ query [ 1 ]] % 2 == 0 ) sum -= A [ query [ 1 ]]; A [ query [ 1 ]] += query [ 0 ]; if ( A [ query [ 1 ]] % 2 == 0 ) sum += A [ query [ 1 ]]; ans . push_back ( sum ); } return ans ; } }; 986. Interval List Intersections $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> intervalIntersection ( vector < vector < int >>& A , vector < vector < int >>& B ) { vector < vector < int >> ans ; short i = 0 ; short j = 0 ; while ( i < A . size () && j < B . size ()) { int start = max ( A [ i ][ 0 ], B [ j ][ 0 ]); int end = min ( A [ i ][ 1 ], B [ j ][ 1 ]); if ( end >= start ) ans . push_back ({ start , end }); if ( A [ i ][ 1 ] > B [ j ][ 1 ]) ++ j ; else ++ i ; } return ans ; } }; 987. Vertical Order Traversal of a Binary Tree $\\star\\star$ 988. Smallest String Starting From Leaf $\\star\\star$ 989. Add to Array-Form of Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > addToArrayForm ( vector < int >& A , int K ) { for ( int i = A . size () - 1 ; i >= 0 ; -- i ) { A [ i ] += K ; K = A [ i ] / 10 ; A [ i ] %= 10 ; } while ( K > 0 ) { A . insert ( A . begin (), K % 10 ); K /= 10 ; } return A ; } }; 990. Satisfiability of Equality Equations $\\star\\star$","title":"0981-0990"},{"location":"golang/0901-1000/0981-0990/#981-time-based-key-value-store-starstar","text":"","title":"981. Time Based Key-Value Store $\\star\\star$"},{"location":"golang/0901-1000/0981-0990/#982-triples-with-bitwise-and-equal-to-zero-starstarstar","text":"","title":"982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$"},{"location":"golang/0901-1000/0981-0990/#983-minimum-cost-for-tickets-starstar","text":"","title":"983. Minimum Cost For Tickets $\\star\\star$"},{"location":"golang/0901-1000/0981-0990/#984-string-without-aaa-or-bbb-starstar","text":"","title":"984. String Without AAA or BBB $\\star\\star$"},{"location":"golang/0901-1000/0981-0990/#985-sum-of-even-numbers-after-queries-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > sumEvenAfterQueries ( vector < int >& A , vector < vector < int >>& queries ) { vector < int > ans ; int sum = accumulate ( A . begin (), A . end (), 0 , []( int a , int b ) { return a + ( b % 2 == 0 ? b : 0 ); }); for ( vector < int >& query : queries ) { if ( A [ query [ 1 ]] % 2 == 0 ) sum -= A [ query [ 1 ]]; A [ query [ 1 ]] += query [ 0 ]; if ( A [ query [ 1 ]] % 2 == 0 ) sum += A [ query [ 1 ]]; ans . push_back ( sum ); } return ans ; } };","title":"985. Sum of Even Numbers After Queries $\\star$"},{"location":"golang/0901-1000/0981-0990/#986-interval-list-intersections-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> intervalIntersection ( vector < vector < int >>& A , vector < vector < int >>& B ) { vector < vector < int >> ans ; short i = 0 ; short j = 0 ; while ( i < A . size () && j < B . size ()) { int start = max ( A [ i ][ 0 ], B [ j ][ 0 ]); int end = min ( A [ i ][ 1 ], B [ j ][ 1 ]); if ( end >= start ) ans . push_back ({ start , end }); if ( A [ i ][ 1 ] > B [ j ][ 1 ]) ++ j ; else ++ i ; } return ans ; } };","title":"986. Interval List Intersections $\\star\\star$"},{"location":"golang/0901-1000/0981-0990/#987-vertical-order-traversal-of-a-binary-tree-starstar","text":"","title":"987. Vertical Order Traversal of a Binary Tree $\\star\\star$"},{"location":"golang/0901-1000/0981-0990/#988-smallest-string-starting-from-leaf-starstar","text":"","title":"988. Smallest String Starting From Leaf $\\star\\star$"},{"location":"golang/0901-1000/0981-0990/#989-add-to-array-form-of-integer-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > addToArrayForm ( vector < int >& A , int K ) { for ( int i = A . size () - 1 ; i >= 0 ; -- i ) { A [ i ] += K ; K = A [ i ] / 10 ; A [ i ] %= 10 ; } while ( K > 0 ) { A . insert ( A . begin (), K % 10 ); K /= 10 ; } return A ; } };","title":"989. Add to Array-Form of Integer $\\star$"},{"location":"golang/0901-1000/0981-0990/#990-satisfiability-of-equality-equations-starstar","text":"","title":"990. Satisfiability of Equality Equations $\\star\\star$"},{"location":"golang/0901-1000/0991-1000/","text":"991. Broken Calculator $\\star\\star$ 992. Subarrays with K Different Integers $\\star\\star\\star$ 993. Cousins in Binary Tree $\\star$ 994. Rotting Oranges $\\star$ 995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$ 996. Number of Squareful Arrays $\\star\\star\\star$ 997. Find the Town Judge $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int findJudge ( int N , vector < vector < int >>& trust ) { vector < int > count ( N ); for ( vector < int >& t : trust ) { -- count [ t [ 0 ] - 1 ]; ++ count [ t [ 1 ] - 1 ]; } for ( int i = 0 ; i < N ; ++ i ) if ( count [ i ] == N - 1 ) return i + 1 ; return - 1 ; } }; 998. Maximum Binary Tree II $\\star\\star$ 999. Available Captures for Rook $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numRookCaptures ( vector < vector < char >>& board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( auto d : vector < vector < int >> ({{ 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 }})) for ( int i = i0 + d [ 0 ], j = j0 + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) { if ( board [ i ][ j ] == 'p' ) ++ ans ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } }; 1000. Minimum Cost to Merge Stones $\\star\\star\\star$","title":"0991-1000"},{"location":"golang/0901-1000/0991-1000/#991-broken-calculator-starstar","text":"","title":"991. Broken Calculator $\\star\\star$"},{"location":"golang/0901-1000/0991-1000/#992-subarrays-with-k-different-integers-starstarstar","text":"","title":"992. Subarrays with K Different Integers $\\star\\star\\star$"},{"location":"golang/0901-1000/0991-1000/#993-cousins-in-binary-tree-star","text":"","title":"993. Cousins in Binary Tree $\\star$"},{"location":"golang/0901-1000/0991-1000/#994-rotting-oranges-star","text":"","title":"994. Rotting Oranges $\\star$"},{"location":"golang/0901-1000/0991-1000/#995-minimum-number-of-k-consecutive-bit-flips-starstarstar","text":"","title":"995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$"},{"location":"golang/0901-1000/0991-1000/#996-number-of-squareful-arrays-starstarstar","text":"","title":"996. Number of Squareful Arrays $\\star\\star\\star$"},{"location":"golang/0901-1000/0991-1000/#997-find-the-town-judge-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int findJudge ( int N , vector < vector < int >>& trust ) { vector < int > count ( N ); for ( vector < int >& t : trust ) { -- count [ t [ 0 ] - 1 ]; ++ count [ t [ 1 ] - 1 ]; } for ( int i = 0 ; i < N ; ++ i ) if ( count [ i ] == N - 1 ) return i + 1 ; return - 1 ; } };","title":"997. Find the Town Judge $\\star$"},{"location":"golang/0901-1000/0991-1000/#998-maximum-binary-tree-ii-starstar","text":"","title":"998. Maximum Binary Tree II $\\star\\star$"},{"location":"golang/0901-1000/0991-1000/#999-available-captures-for-rook-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numRookCaptures ( vector < vector < char >>& board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; ++ i ) for ( int j = 0 ; j < 8 ; ++ j ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( auto d : vector < vector < int >> ({{ 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 }})) for ( int i = i0 + d [ 0 ], j = j0 + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) { if ( board [ i ][ j ] == 'p' ) ++ ans ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } };","title":"999. Available Captures for Rook $\\star$"},{"location":"golang/0901-1000/0991-1000/#1000-minimum-cost-to-merge-stones-starstarstar","text":"","title":"1000. Minimum Cost to Merge Stones $\\star\\star\\star$"},{"location":"golang/1001-1100/1001-1010/","text":"1001. Grid Illumination $\\star\\star\\star$ 1002. Find Common Characters $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > commonChars ( vector < string >& A ) { vector < string > ans ; vector < int > commonCount ( 26 , INT_MAX ); for ( string & a : A ) { vector < int > count ( 26 ); for ( char c : a ) ++ count [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = min ( commonCount [ i ], count [ i ]); } for ( char c = 'a' ; c <= 'z' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - 'a' ]; ++ i ) ans . push_back ( string ( 1 , c )); return ans ; } }; 1003. Check If Word Is Valid After Substitutions $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool isValid ( string S ) { vector < char > stack ; for ( char c : S ) { if ( c == 'c' ) { int n = stack . size (); if ( n < 2 || stack [ n - 2 ] != 'a' || stack [ n - 1 ] != 'b' ) return false ; stack . pop_back (); stack . pop_back (); } else { stack . push_back ( c ); } } return stack . empty (); } }; 1004. Max Consecutive Ones III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int longestOnes ( vector < int >& A , int K ) { int i = 0 ; for ( int a : A ) { if ( a == 0 ) -- K ; if ( K < 0 ) { if ( A [ i ] == 0 ) ++ K ; ++ i ; } } return A . size () - i ; } }; 1005. Maximize Sum Of Array After K Negations $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int largestSumAfterKNegations ( vector < int >& A , int K ) { sort ( A . begin (), A . end ()); for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > 0 || K == 0 ) break ; A [ i ] = - A [ i ]; -- K ; } return accumulate ( A . begin (), A . end (), 0 ) - ( K % 2 ) * * min_element ( A . begin (), A . end ()) * 2 ; } }; 1006. Clumsy Factorial $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int clumsy ( int N ) { if ( N <= 2 ) return N ; if ( N <= 4 ) return N + 3 ; if (( N - 4 ) % 4 == 0 ) return N + 1 ; if (( N - 4 ) % 4 <= 2 ) return N + 2 ; return N - 1 ; } }; 1007. Minimum Domino Rotations For Equal Row $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minDominoRotations ( vector < int >& A , vector < int >& B ) { const int n = A . size (); vector < int > countA ( 7 ); vector < int > countB ( 7 ); vector < int > countBoth ( 7 ); for ( int i = 0 ; i < n ; ++ i ) { ++ countA [ A [ i ]]; ++ countB [ B [ i ]]; if ( A [ i ] == B [ i ]) ++ countBoth [ A [ i ]]; } for ( int i = 1 ; i <= 6 ; ++ i ) if ( countA [ i ] + countB [ i ] - countBoth [ i ] == n ) return n - max ( countA [ i ], countB [ i ]); return - 1 ; } }; 1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$ 1009. Complement of Base 10 Integer $\\star$ 1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numPairsDivisibleBy60 ( vector < int >& time ) { int ans = 0 ; vector < int > count ( 60 ); for ( int t : time ) { t %= 60 ; ans += t == 0 ? count [ 0 ] : count [ 60 - t ]; ++ count [ t ]; } return ans ; } };","title":"1001-1010"},{"location":"golang/1001-1100/1001-1010/#1001-grid-illumination-starstarstar","text":"","title":"1001. Grid Illumination $\\star\\star\\star$"},{"location":"golang/1001-1100/1001-1010/#1002-find-common-characters-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > commonChars ( vector < string >& A ) { vector < string > ans ; vector < int > commonCount ( 26 , INT_MAX ); for ( string & a : A ) { vector < int > count ( 26 ); for ( char c : a ) ++ count [ c - 'a' ]; for ( int i = 0 ; i < 26 ; ++ i ) commonCount [ i ] = min ( commonCount [ i ], count [ i ]); } for ( char c = 'a' ; c <= 'z' ; ++ c ) for ( int i = 0 ; i < commonCount [ c - 'a' ]; ++ i ) ans . push_back ( string ( 1 , c )); return ans ; } };","title":"1002. Find Common Characters $\\star$"},{"location":"golang/1001-1100/1001-1010/#1003-check-if-word-is-valid-after-substitutions-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool isValid ( string S ) { vector < char > stack ; for ( char c : S ) { if ( c == 'c' ) { int n = stack . size (); if ( n < 2 || stack [ n - 2 ] != 'a' || stack [ n - 1 ] != 'b' ) return false ; stack . pop_back (); stack . pop_back (); } else { stack . push_back ( c ); } } return stack . empty (); } };","title":"1003. Check If Word Is Valid After Substitutions $\\star\\star$"},{"location":"golang/1001-1100/1001-1010/#1004-max-consecutive-ones-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int longestOnes ( vector < int >& A , int K ) { int i = 0 ; for ( int a : A ) { if ( a == 0 ) -- K ; if ( K < 0 ) { if ( A [ i ] == 0 ) ++ K ; ++ i ; } } return A . size () - i ; } };","title":"1004. Max Consecutive Ones III $\\star\\star$"},{"location":"golang/1001-1100/1001-1010/#1005-maximize-sum-of-array-after-k-negations-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int largestSumAfterKNegations ( vector < int >& A , int K ) { sort ( A . begin (), A . end ()); for ( int i = 0 ; i < A . size (); ++ i ) { if ( A [ i ] > 0 || K == 0 ) break ; A [ i ] = - A [ i ]; -- K ; } return accumulate ( A . begin (), A . end (), 0 ) - ( K % 2 ) * * min_element ( A . begin (), A . end ()) * 2 ; } };","title":"1005. Maximize Sum Of Array After K Negations $\\star$"},{"location":"golang/1001-1100/1001-1010/#1006-clumsy-factorial-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int clumsy ( int N ) { if ( N <= 2 ) return N ; if ( N <= 4 ) return N + 3 ; if (( N - 4 ) % 4 == 0 ) return N + 1 ; if (( N - 4 ) % 4 <= 2 ) return N + 2 ; return N - 1 ; } };","title":"1006. Clumsy Factorial $\\star\\star$"},{"location":"golang/1001-1100/1001-1010/#1007-minimum-domino-rotations-for-equal-row-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minDominoRotations ( vector < int >& A , vector < int >& B ) { const int n = A . size (); vector < int > countA ( 7 ); vector < int > countB ( 7 ); vector < int > countBoth ( 7 ); for ( int i = 0 ; i < n ; ++ i ) { ++ countA [ A [ i ]]; ++ countB [ B [ i ]]; if ( A [ i ] == B [ i ]) ++ countBoth [ A [ i ]]; } for ( int i = 1 ; i <= 6 ; ++ i ) if ( countA [ i ] + countB [ i ] - countBoth [ i ] == n ) return n - max ( countA [ i ], countB [ i ]); return - 1 ; } };","title":"1007. Minimum Domino Rotations For Equal Row $\\star\\star$"},{"location":"golang/1001-1100/1001-1010/#1008-construct-binary-search-tree-from-preorder-traversal-starstar","text":"","title":"1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$"},{"location":"golang/1001-1100/1001-1010/#1009-complement-of-base-10-integer-star","text":"","title":"1009. Complement of Base 10 Integer $\\star$"},{"location":"golang/1001-1100/1001-1010/#1010-pairs-of-songs-with-total-durations-divisible-by-60-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numPairsDivisibleBy60 ( vector < int >& time ) { int ans = 0 ; vector < int > count ( 60 ); for ( int t : time ) { t %= 60 ; ans += t == 0 ? count [ 0 ] : count [ 60 - t ]; ++ count [ t ]; } return ans ; } };","title":"1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$"},{"location":"golang/1001-1100/1011-1020/","text":"1011. Capacity To Ship Packages Within D Days $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int shipWithinDays ( vector < int >& weights , int D ) { int l = * max_element ( weights . begin (), weights . end ()); int r = accumulate ( weights . begin (), weights . end (), 0 ); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { ++ day ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } }; 1012. Numbers With Repeated Digits $\\star\\star\\star$ 1013. Partition Array Into Three Parts With Equal Sum $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canThreePartsEqualSum ( vector < int >& A ) { int sum = accumulate ( A . begin (), A . end (), 0 ); int presum = 0 ; int parts = 1 ; for ( int a : A ) { presum += a ; if ( presum == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } }; 1014. Best Sightseeing Pair $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxScoreSightseeingPair ( vector < int >& A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = max ( ans , a + bestPrev ); bestPrev = max ( bestPrev , a ) - 1 ; } return ans ; } }; 1015. Smallest Integer Divisible by K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; unordered_set < int > set ; int mod = 0 ; for ( int N = 1 ; N <= K ; ++ N ) { mod = ( mod * 10 + 1 ) % K ; if ( mod == 0 ) return N ; if ( set . count ( mod )) return - 1 ; set . insert ( mod ); } return - 1 ; } }; 1016. Binary String With Substrings Representing 1 To N $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool queryString ( string S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) { string binary = bitset < 32 > ( i ). to_string (); binary = binary . substr ( binary . find ( \"1\" )); if ( S . find ( binary ) == string :: npos ) return false ; } return true ; } }; 1017. Convert to Base -2 $\\star\\star$ 1018. Binary Prefix Divisible By 5 $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < bool > prefixesDivBy5 ( vector < int >& A ) { vector < bool > ans ; int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . push_back ( num % 5 == 0 ); } return ans ; } }; 1019. Next Greater Node In Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > nextLargerNodes ( ListNode * head ) { vector < int > ans ; vector < int > stack ; for ( auto curr = head ; curr ; curr = curr -> next ) { while ( stack . size () && ans [ stack . back ()] < curr -> val ) { ans [ stack . back ()] = curr -> val ; stack . pop_back (); } stack . push_back ( ans . size ()); ans . push_back ( curr -> val ); } for ( int i : stack ) ans [ i ] = 0 ; return ans ; } }; 1020. Number of Enclaves $\\star\\star$","title":"1011-1020"},{"location":"golang/1001-1100/1011-1020/#1011-capacity-to-ship-packages-within-d-days-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int shipWithinDays ( vector < int >& weights , int D ) { int l = * max_element ( weights . begin (), weights . end ()); int r = accumulate ( weights . begin (), weights . end (), 0 ); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { ++ day ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } };","title":"1011. Capacity To Ship Packages Within D Days $\\star\\star$"},{"location":"golang/1001-1100/1011-1020/#1012-numbers-with-repeated-digits-starstarstar","text":"","title":"1012. Numbers With Repeated Digits $\\star\\star\\star$"},{"location":"golang/1001-1100/1011-1020/#1013-partition-array-into-three-parts-with-equal-sum-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canThreePartsEqualSum ( vector < int >& A ) { int sum = accumulate ( A . begin (), A . end (), 0 ); int presum = 0 ; int parts = 1 ; for ( int a : A ) { presum += a ; if ( presum == sum * parts / 3 ) ++ parts ; } return sum % 3 == 0 && parts >= 3 ; } };","title":"1013. Partition Array Into Three Parts With Equal Sum $\\star$"},{"location":"golang/1001-1100/1011-1020/#1014-best-sightseeing-pair-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxScoreSightseeingPair ( vector < int >& A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = max ( ans , a + bestPrev ); bestPrev = max ( bestPrev , a ) - 1 ; } return ans ; } };","title":"1014. Best Sightseeing Pair $\\star\\star$"},{"location":"golang/1001-1100/1011-1020/#1015-smallest-integer-divisible-by-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; unordered_set < int > set ; int mod = 0 ; for ( int N = 1 ; N <= K ; ++ N ) { mod = ( mod * 10 + 1 ) % K ; if ( mod == 0 ) return N ; if ( set . count ( mod )) return - 1 ; set . insert ( mod ); } return - 1 ; } };","title":"1015. Smallest Integer Divisible by K $\\star\\star$"},{"location":"golang/1001-1100/1011-1020/#1016-binary-string-with-substrings-representing-1-to-n-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool queryString ( string S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; -- i ) { string binary = bitset < 32 > ( i ). to_string (); binary = binary . substr ( binary . find ( \"1\" )); if ( S . find ( binary ) == string :: npos ) return false ; } return true ; } };","title":"1016. Binary String With Substrings Representing 1 To N $\\star\\star$"},{"location":"golang/1001-1100/1011-1020/#1017-convert-to-base-2-starstar","text":"","title":"1017. Convert to Base -2 $\\star\\star$"},{"location":"golang/1001-1100/1011-1020/#1018-binary-prefix-divisible-by-5-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < bool > prefixesDivBy5 ( vector < int >& A ) { vector < bool > ans ; int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . push_back ( num % 5 == 0 ); } return ans ; } };","title":"1018. Binary Prefix Divisible By 5 $\\star$"},{"location":"golang/1001-1100/1011-1020/#1019-next-greater-node-in-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > nextLargerNodes ( ListNode * head ) { vector < int > ans ; vector < int > stack ; for ( auto curr = head ; curr ; curr = curr -> next ) { while ( stack . size () && ans [ stack . back ()] < curr -> val ) { ans [ stack . back ()] = curr -> val ; stack . pop_back (); } stack . push_back ( ans . size ()); ans . push_back ( curr -> val ); } for ( int i : stack ) ans [ i ] = 0 ; return ans ; } };","title":"1019. Next Greater Node In Linked List $\\star\\star$"},{"location":"golang/1001-1100/1011-1020/#1020-number-of-enclaves-starstar","text":"","title":"1020. Number of Enclaves $\\star\\star$"},{"location":"golang/1001-1100/1021-1030/","text":"1021. Remove Outermost Parentheses $\\star$ 1022. Sum of Root To Leaf Binary Numbers $\\star$ 1023. Camelcase Matching $\\star\\star$ 1024. Video Stitching $\\star\\star$ 1025. Divisor Game $\\star$ 1026. Maximum Difference Between Node and Ancestor $\\star\\star$ 1027. Longest Arithmetic Sequence $\\star\\star$ 1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$ 1029. Two City Scheduling $\\star$ 1030. Matrix Cells in Distance Order $\\star$","title":"1021-1030"},{"location":"golang/1001-1100/1021-1030/#1021-remove-outermost-parentheses-star","text":"","title":"1021. Remove Outermost Parentheses $\\star$"},{"location":"golang/1001-1100/1021-1030/#1022-sum-of-root-to-leaf-binary-numbers-star","text":"","title":"1022. Sum of Root To Leaf Binary Numbers $\\star$"},{"location":"golang/1001-1100/1021-1030/#1023-camelcase-matching-starstar","text":"","title":"1023. Camelcase Matching $\\star\\star$"},{"location":"golang/1001-1100/1021-1030/#1024-video-stitching-starstar","text":"","title":"1024. Video Stitching $\\star\\star$"},{"location":"golang/1001-1100/1021-1030/#1025-divisor-game-star","text":"","title":"1025. Divisor Game $\\star$"},{"location":"golang/1001-1100/1021-1030/#1026-maximum-difference-between-node-and-ancestor-starstar","text":"","title":"1026. Maximum Difference Between Node and Ancestor $\\star\\star$"},{"location":"golang/1001-1100/1021-1030/#1027-longest-arithmetic-sequence-starstar","text":"","title":"1027. Longest Arithmetic Sequence $\\star\\star$"},{"location":"golang/1001-1100/1021-1030/#1028-recover-a-tree-from-preorder-traversal-starstarstar","text":"","title":"1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$"},{"location":"golang/1001-1100/1021-1030/#1029-two-city-scheduling-star","text":"","title":"1029. Two City Scheduling $\\star$"},{"location":"golang/1001-1100/1021-1030/#1030-matrix-cells-in-distance-order-star","text":"","title":"1030. Matrix Cells in Distance Order $\\star$"},{"location":"golang/1001-1100/1031-1040/","text":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int maxSumTwoNoOverlap ( vector < int >& A , int L , int M ) { return max ( helper ( A , L , M ), helper ( A , M , L )); } private : int helper ( vector < int >& A , int l , int r ) { const int n = A . size (); vector < int > left ( n ); int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ]; if ( i >= l ) sum -= A [ i - l ]; if ( i >= l - 1 ) left [ i ] = i > 0 ? max ( left [ i - 1 ], sum ) : sum ; } vector < int > right ( n ); sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ]; if ( i <= n - r - 1 ) sum -= A [ i + r ]; if ( i <= n - r ) right [ i ] = i < n - 1 ? max ( right [ i + 1 ], sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = max ( ans , left [ i ] + right [ i + 1 ]); return ans ; } }; 1032. Stream of Characters $\\star\\star\\star$ 1033. Moving Stones Until Consecutive $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < int > numMovesStones ( int a , int b , int c ) { vector < int > nums = { a , b , c }; sort ( nums . begin (), nums . end ()); if ( nums [ 2 ] - nums [ 0 ] == 2 ) return { 0 , 0 }; return { min ( nums [ 1 ] - nums [ 0 ], nums [ 2 ] - nums [ 1 ]) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 }; } }; 1034. Coloring A Border $\\star\\star$ 1035. Uncrossed Lines $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxUncrossedLines ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] + 1 : max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); return dp [ m ][ n ]; } }; 1036. Escape a Large Maze $\\star\\star\\star$ 1037. Valid Boomerang $\\star$ 1038. Binary Search Tree to Greater Sum Tree $\\star\\star$ 1039. Minimum Score Triangulation of Polygon $\\star\\star$ 1040. Moving Stones Until Consecutive II $\\star\\star$","title":"1031-1040"},{"location":"golang/1001-1100/1031-1040/#1031-maximum-sum-of-two-non-overlapping-subarrays-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int maxSumTwoNoOverlap ( vector < int >& A , int L , int M ) { return max ( helper ( A , L , M ), helper ( A , M , L )); } private : int helper ( vector < int >& A , int l , int r ) { const int n = A . size (); vector < int > left ( n ); int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sum += A [ i ]; if ( i >= l ) sum -= A [ i - l ]; if ( i >= l - 1 ) left [ i ] = i > 0 ? max ( left [ i - 1 ], sum ) : sum ; } vector < int > right ( n ); sum = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { sum += A [ i ]; if ( i <= n - r - 1 ) sum -= A [ i + r ]; if ( i <= n - r ) right [ i ] = i < n - 1 ? max ( right [ i + 1 ], sum ) : sum ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) ans = max ( ans , left [ i ] + right [ i + 1 ]); return ans ; } };","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$"},{"location":"golang/1001-1100/1031-1040/#1032-stream-of-characters-starstarstar","text":"","title":"1032. Stream of Characters $\\star\\star\\star$"},{"location":"golang/1001-1100/1031-1040/#1033-moving-stones-until-consecutive-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : vector < int > numMovesStones ( int a , int b , int c ) { vector < int > nums = { a , b , c }; sort ( nums . begin (), nums . end ()); if ( nums [ 2 ] - nums [ 0 ] == 2 ) return { 0 , 0 }; return { min ( nums [ 1 ] - nums [ 0 ], nums [ 2 ] - nums [ 1 ]) <= 2 ? 1 : 2 , nums [ 2 ] - nums [ 0 ] - 2 }; } };","title":"1033. Moving Stones Until Consecutive $\\star$"},{"location":"golang/1001-1100/1031-1040/#1034-coloring-a-border-starstar","text":"","title":"1034. Coloring A Border $\\star\\star$"},{"location":"golang/1001-1100/1031-1040/#1035-uncrossed-lines-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxUncrossedLines ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 1 ; i <= m ; ++ i ) for ( int j = 1 ; j <= n ; ++ j ) dp [ i ][ j ] = A [ i - 1 ] == B [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] + 1 : max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); return dp [ m ][ n ]; } };","title":"1035. Uncrossed Lines $\\star\\star$"},{"location":"golang/1001-1100/1031-1040/#1036-escape-a-large-maze-starstarstar","text":"","title":"1036. Escape a Large Maze $\\star\\star\\star$"},{"location":"golang/1001-1100/1031-1040/#1037-valid-boomerang-star","text":"","title":"1037. Valid Boomerang $\\star$"},{"location":"golang/1001-1100/1031-1040/#1038-binary-search-tree-to-greater-sum-tree-starstar","text":"","title":"1038. Binary Search Tree to Greater Sum Tree $\\star\\star$"},{"location":"golang/1001-1100/1031-1040/#1039-minimum-score-triangulation-of-polygon-starstar","text":"","title":"1039. Minimum Score Triangulation of Polygon $\\star\\star$"},{"location":"golang/1001-1100/1031-1040/#1040-moving-stones-until-consecutive-ii-starstar","text":"","title":"1040. Moving Stones Until Consecutive II $\\star\\star$"},{"location":"golang/1001-1100/1041-1050/","text":"1041. Robot Bounded In Circle $\\star\\star$ 1042. Flower Planting With No Adjacent $\\star$ 1043. Partition Array for Maximum Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxSumAfterPartitioning ( vector < int >& A , int K ) { const int n = A . size (); vector < int > dp ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { int min = INT_MIN ; for ( int j = 1 ; j <= std :: min ( i , K ); ++ j ) { min = max ( min , A [ i - j ]); dp [ i ] = max ( dp [ i ], dp [ i - j ] + min * j ); } } return dp [ n ]; } }; 1044. Longest Duplicate Substring $\\star\\star\\star$ 1045. Customers Who Bought All Products $\\star\\star$ 1046. Last Stone Weight $\\star$ 1047. Remove All Adjacent Duplicates In String $\\star$ 1048. Longest String Chain $\\star\\star$ 1049. Last Stone Weight II $\\star\\star$ 1050. Actors and Directors Who Cooperated At Least Three Times $\\star$","title":"1041-1050"},{"location":"golang/1001-1100/1041-1050/#1041-robot-bounded-in-circle-starstar","text":"","title":"1041. Robot Bounded In Circle $\\star\\star$"},{"location":"golang/1001-1100/1041-1050/#1042-flower-planting-with-no-adjacent-star","text":"","title":"1042. Flower Planting With No Adjacent $\\star$"},{"location":"golang/1001-1100/1041-1050/#1043-partition-array-for-maximum-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxSumAfterPartitioning ( vector < int >& A , int K ) { const int n = A . size (); vector < int > dp ( n + 1 ); for ( int i = 1 ; i <= n ; ++ i ) { int min = INT_MIN ; for ( int j = 1 ; j <= std :: min ( i , K ); ++ j ) { min = max ( min , A [ i - j ]); dp [ i ] = max ( dp [ i ], dp [ i - j ] + min * j ); } } return dp [ n ]; } };","title":"1043. Partition Array for Maximum Sum $\\star\\star$"},{"location":"golang/1001-1100/1041-1050/#1044-longest-duplicate-substring-starstarstar","text":"","title":"1044. Longest Duplicate Substring $\\star\\star\\star$"},{"location":"golang/1001-1100/1041-1050/#1045-customers-who-bought-all-products-starstar","text":"","title":"1045. Customers Who Bought All Products $\\star\\star$"},{"location":"golang/1001-1100/1041-1050/#1046-last-stone-weight-star","text":"","title":"1046. Last Stone Weight $\\star$"},{"location":"golang/1001-1100/1041-1050/#1047-remove-all-adjacent-duplicates-in-string-star","text":"","title":"1047. Remove All Adjacent Duplicates In String $\\star$"},{"location":"golang/1001-1100/1041-1050/#1048-longest-string-chain-starstar","text":"","title":"1048. Longest String Chain $\\star\\star$"},{"location":"golang/1001-1100/1041-1050/#1049-last-stone-weight-ii-starstar","text":"","title":"1049. Last Stone Weight II $\\star\\star$"},{"location":"golang/1001-1100/1041-1050/#1050-actors-and-directors-who-cooperated-at-least-three-times-star","text":"","title":"1050. Actors and Directors Who Cooperated At Least Three Times $\\star$"},{"location":"golang/1001-1100/1051-1060/","text":"1051. Height Checker $\\star$ 1052. Grumpy Bookstore Owner $\\star\\star$ 1053. Previous Permutation With One Swap $\\star\\star$ 1054. Distant Barcodes $\\star\\star$ 1055. Shortest Way to Form String $\\star\\star$ 1056. Confusing Number $\\star$ 1057. Campus Bikes $\\star\\star$ 1058. Minimize Rounding Error to Meet Target $\\star\\star$ 1059. All Paths from Source Lead to Destination $\\star\\star$ 1060. Missing Element in Sorted Array $\\star\\star$","title":"1051-1060"},{"location":"golang/1001-1100/1051-1060/#1051-height-checker-star","text":"","title":"1051. Height Checker $\\star$"},{"location":"golang/1001-1100/1051-1060/#1052-grumpy-bookstore-owner-starstar","text":"","title":"1052. Grumpy Bookstore Owner $\\star\\star$"},{"location":"golang/1001-1100/1051-1060/#1053-previous-permutation-with-one-swap-starstar","text":"","title":"1053. Previous Permutation With One Swap $\\star\\star$"},{"location":"golang/1001-1100/1051-1060/#1054-distant-barcodes-starstar","text":"","title":"1054. Distant Barcodes $\\star\\star$"},{"location":"golang/1001-1100/1051-1060/#1055-shortest-way-to-form-string-starstar","text":"","title":"1055. Shortest Way to Form String $\\star\\star$"},{"location":"golang/1001-1100/1051-1060/#1056-confusing-number-star","text":"","title":"1056. Confusing Number $\\star$"},{"location":"golang/1001-1100/1051-1060/#1057-campus-bikes-starstar","text":"","title":"1057. Campus Bikes $\\star\\star$"},{"location":"golang/1001-1100/1051-1060/#1058-minimize-rounding-error-to-meet-target-starstar","text":"","title":"1058. Minimize Rounding Error to Meet Target $\\star\\star$"},{"location":"golang/1001-1100/1051-1060/#1059-all-paths-from-source-lead-to-destination-starstar","text":"","title":"1059. All Paths from Source Lead to Destination $\\star\\star$"},{"location":"golang/1001-1100/1051-1060/#1060-missing-element-in-sorted-array-starstar","text":"","title":"1060. Missing Element in Sorted Array $\\star\\star$"},{"location":"golang/1001-1100/1061-1070/","text":"1061. Lexicographically Smallest Equivalent String $\\star\\star$ 1062. Longest Repeating Substring $\\star\\star$ 1063. Number of Valid Subarrays $\\star\\star\\star$ 1064. Fixed Point $\\star$ 1065. Index Pairs of a String $\\star$ 1066. Campus Bikes II $\\star\\star$ 1067. Digit Count in Range $\\star\\star\\star$ 1068. Product Sales Analysis I $\\star$ 1069. Product Sales Analysis II $\\star$ 1070. Product Sales Analysis III $\\star\\star$","title":"1061-1070"},{"location":"golang/1001-1100/1061-1070/#1061-lexicographically-smallest-equivalent-string-starstar","text":"","title":"1061. Lexicographically Smallest Equivalent String $\\star\\star$"},{"location":"golang/1001-1100/1061-1070/#1062-longest-repeating-substring-starstar","text":"","title":"1062. Longest Repeating Substring $\\star\\star$"},{"location":"golang/1001-1100/1061-1070/#1063-number-of-valid-subarrays-starstarstar","text":"","title":"1063. Number of Valid Subarrays $\\star\\star\\star$"},{"location":"golang/1001-1100/1061-1070/#1064-fixed-point-star","text":"","title":"1064. Fixed Point $\\star$"},{"location":"golang/1001-1100/1061-1070/#1065-index-pairs-of-a-string-star","text":"","title":"1065. Index Pairs of a String $\\star$"},{"location":"golang/1001-1100/1061-1070/#1066-campus-bikes-ii-starstar","text":"","title":"1066. Campus Bikes II $\\star\\star$"},{"location":"golang/1001-1100/1061-1070/#1067-digit-count-in-range-starstarstar","text":"","title":"1067. Digit Count in Range $\\star\\star\\star$"},{"location":"golang/1001-1100/1061-1070/#1068-product-sales-analysis-i-star","text":"","title":"1068. Product Sales Analysis I $\\star$"},{"location":"golang/1001-1100/1061-1070/#1069-product-sales-analysis-ii-star","text":"","title":"1069. Product Sales Analysis II $\\star$"},{"location":"golang/1001-1100/1061-1070/#1070-product-sales-analysis-iii-starstar","text":"","title":"1070. Product Sales Analysis III $\\star\\star$"},{"location":"golang/1001-1100/1071-1080/","text":"1071. Greatest Common Divisor of Strings $\\star$ 1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$ 1073. Adding Two Negabinary Numbers $\\star\\star$ 1074. Number of Submatrices That Sum to Target $\\star\\star\\star$ 1075. Project Employees I $\\star$ 1076. Project Employees II $\\star$ 1077. Project Employees III $\\star\\star$ 1078. Occurrences After Bigram $\\star$ 1079. Letter Tile Possibilities $\\star\\star$ 1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$","title":"1071-1080"},{"location":"golang/1001-1100/1071-1080/#1071-greatest-common-divisor-of-strings-star","text":"","title":"1071. Greatest Common Divisor of Strings $\\star$"},{"location":"golang/1001-1100/1071-1080/#1072-flip-columns-for-maximum-number-of-equal-rows-starstar","text":"","title":"1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$"},{"location":"golang/1001-1100/1071-1080/#1073-adding-two-negabinary-numbers-starstar","text":"","title":"1073. Adding Two Negabinary Numbers $\\star\\star$"},{"location":"golang/1001-1100/1071-1080/#1074-number-of-submatrices-that-sum-to-target-starstarstar","text":"","title":"1074. Number of Submatrices That Sum to Target $\\star\\star\\star$"},{"location":"golang/1001-1100/1071-1080/#1075-project-employees-i-star","text":"","title":"1075. Project Employees I $\\star$"},{"location":"golang/1001-1100/1071-1080/#1076-project-employees-ii-star","text":"","title":"1076. Project Employees II $\\star$"},{"location":"golang/1001-1100/1071-1080/#1077-project-employees-iii-starstar","text":"","title":"1077. Project Employees III $\\star\\star$"},{"location":"golang/1001-1100/1071-1080/#1078-occurrences-after-bigram-star","text":"","title":"1078. Occurrences After Bigram $\\star$"},{"location":"golang/1001-1100/1071-1080/#1079-letter-tile-possibilities-starstar","text":"","title":"1079. Letter Tile Possibilities $\\star\\star$"},{"location":"golang/1001-1100/1071-1080/#1080-insufficient-nodes-in-root-to-leaf-paths-starstar","text":"","title":"1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$"},{"location":"golang/1001-1100/1081-1090/","text":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$ 1082. Sales Analysis I $\\star$ 1083. Sales Analysis II $\\star$ 1084. Sales Analysis III $\\star$ 1085. Sum of Digits in the Minimum Number $\\star$ 1086. High Five $\\star$ 1087. Brace Expansion $\\star\\star$ 1088. Confusing Number II $\\star\\star\\star$ 1089. Duplicate Zeros $\\star$ 1090. Largest Values From Labels $\\star\\star$","title":"1081-1090"},{"location":"golang/1001-1100/1081-1090/#1081-smallest-subsequence-of-distinct-characters-starstar","text":"","title":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$"},{"location":"golang/1001-1100/1081-1090/#1082-sales-analysis-i-star","text":"","title":"1082. Sales Analysis I $\\star$"},{"location":"golang/1001-1100/1081-1090/#1083-sales-analysis-ii-star","text":"","title":"1083. Sales Analysis II $\\star$"},{"location":"golang/1001-1100/1081-1090/#1084-sales-analysis-iii-star","text":"","title":"1084. Sales Analysis III $\\star$"},{"location":"golang/1001-1100/1081-1090/#1085-sum-of-digits-in-the-minimum-number-star","text":"","title":"1085. Sum of Digits in the Minimum Number $\\star$"},{"location":"golang/1001-1100/1081-1090/#1086-high-five-star","text":"","title":"1086. High Five $\\star$"},{"location":"golang/1001-1100/1081-1090/#1087-brace-expansion-starstar","text":"","title":"1087. Brace Expansion $\\star\\star$"},{"location":"golang/1001-1100/1081-1090/#1088-confusing-number-ii-starstarstar","text":"","title":"1088. Confusing Number II $\\star\\star\\star$"},{"location":"golang/1001-1100/1081-1090/#1089-duplicate-zeros-star","text":"","title":"1089. Duplicate Zeros $\\star$"},{"location":"golang/1001-1100/1081-1090/#1090-largest-values-from-labels-starstar","text":"","title":"1090. Largest Values From Labels $\\star\\star$"},{"location":"golang/1001-1100/1091-1100/","text":"1091. Shortest Path in Binary Matrix $\\star\\star$ 1092. Shortest Common Supersequence $\\star\\star\\star$ 1093. Statistics from a Large Sample $\\star\\star$ 1094. Car Pooling $\\star\\star$ 1095. Find in Mountain Array $\\star\\star\\star$ 1096. Brace Expansion II $\\star\\star\\star$ 1097. Game Play Analysis V $\\star\\star\\star$ 1098. Unpopular Books $\\star\\star$ 1099. Two Sum Less Than K $\\star$ 1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$","title":"1091-1100"},{"location":"golang/1001-1100/1091-1100/#1091-shortest-path-in-binary-matrix-starstar","text":"","title":"1091. Shortest Path in Binary Matrix $\\star\\star$"},{"location":"golang/1001-1100/1091-1100/#1092-shortest-common-supersequence-starstarstar","text":"","title":"1092. Shortest Common Supersequence  $\\star\\star\\star$"},{"location":"golang/1001-1100/1091-1100/#1093-statistics-from-a-large-sample-starstar","text":"","title":"1093. Statistics from a Large Sample $\\star\\star$"},{"location":"golang/1001-1100/1091-1100/#1094-car-pooling-starstar","text":"","title":"1094. Car Pooling $\\star\\star$"},{"location":"golang/1001-1100/1091-1100/#1095-find-in-mountain-array-starstarstar","text":"","title":"1095. Find in Mountain Array $\\star\\star\\star$"},{"location":"golang/1001-1100/1091-1100/#1096-brace-expansion-ii-starstarstar","text":"","title":"1096. Brace Expansion II $\\star\\star\\star$"},{"location":"golang/1001-1100/1091-1100/#1097-game-play-analysis-v-starstarstar","text":"","title":"1097. Game Play Analysis V $\\star\\star\\star$"},{"location":"golang/1001-1100/1091-1100/#1098-unpopular-books-starstar","text":"","title":"1098. Unpopular Books $\\star\\star$"},{"location":"golang/1001-1100/1091-1100/#1099-two-sum-less-than-k-star","text":"","title":"1099. Two Sum Less Than K $\\star$"},{"location":"golang/1001-1100/1091-1100/#1100-find-k-length-substrings-with-no-repeated-characters-starstar","text":"","title":"1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$"},{"location":"golang/1101-1200/1101-1110/","text":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$ 1102. Path With Maximum Minimum Value $\\star\\star$ 1103. Distribute Candies to People $\\star$ 1104. Path In Zigzag Labelled Binary Tree $\\star\\star$ 1105. Filling Bookcase Shelves $\\star\\star$ 1106. Parsing A Boolean Expression $\\star\\star\\star$ 1107. New Users Daily Count $\\star\\star$ 1108. Defanging an IP Address $\\star$ 1109. Corporate Flight Bookings $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > corpFlightBookings ( vector < vector < int >>& bookings , int n ) { vector < int > ans ( n ); for ( vector < int >& booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ]; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ]; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ]; return ans ; } }; 1110. Delete Nodes And Return Forest $\\star\\star$","title":"1101-1110"},{"location":"golang/1101-1200/1101-1110/#1101-the-earliest-moment-when-everyone-become-friends-starstar","text":"","title":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$"},{"location":"golang/1101-1200/1101-1110/#1102-path-with-maximum-minimum-value-starstar","text":"","title":"1102. Path With Maximum Minimum Value $\\star\\star$"},{"location":"golang/1101-1200/1101-1110/#1103-distribute-candies-to-people-star","text":"","title":"1103. Distribute Candies to People $\\star$"},{"location":"golang/1101-1200/1101-1110/#1104-path-in-zigzag-labelled-binary-tree-starstar","text":"","title":"1104. Path In Zigzag Labelled Binary Tree $\\star\\star$"},{"location":"golang/1101-1200/1101-1110/#1105-filling-bookcase-shelves-starstar","text":"","title":"1105. Filling Bookcase Shelves $\\star\\star$"},{"location":"golang/1101-1200/1101-1110/#1106-parsing-a-boolean-expression-starstarstar","text":"","title":"1106. Parsing A Boolean Expression $\\star\\star\\star$"},{"location":"golang/1101-1200/1101-1110/#1107-new-users-daily-count-starstar","text":"","title":"1107. New Users Daily Count $\\star\\star$"},{"location":"golang/1101-1200/1101-1110/#1108-defanging-an-ip-address-star","text":"","title":"1108. Defanging an IP Address $\\star$"},{"location":"golang/1101-1200/1101-1110/#1109-corporate-flight-bookings-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > corpFlightBookings ( vector < vector < int >>& bookings , int n ) { vector < int > ans ( n ); for ( vector < int >& booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ]; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ]; } for ( int i = 1 ; i < n ; ++ i ) ans [ i ] += ans [ i - 1 ]; return ans ; } };","title":"1109. Corporate Flight Bookings $\\star\\star$"},{"location":"golang/1101-1200/1101-1110/#1110-delete-nodes-and-return-forest-starstar","text":"","title":"1110. Delete Nodes And Return Forest $\\star\\star$"},{"location":"golang/1101-1200/1111-1120/","text":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$ 1112. Highest Grade For Each Student $\\star\\star$ 1113. Reported Posts $\\star$ 1114. Print in Order $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Foo { public : Foo () { mutex2 . lock (); mutex3 . lock (); } void first ( function < void () > printFirst ) { printFirst (); mutex2 . unlock (); } void second ( function < void () > printSecond ) { mutex2 . lock (); printSecond (); mutex3 . unlock (); } void third ( function < void () > printThird ) { mutex3 . lock (); printThird (); } private : mutex mutex2 ; mutex mutex3 ; }; 1115. Print FooBar Alternately $\\star\\star$ 1116. Print Zero Even Odd $\\star\\star$ 1117. Building H2O $\\star\\star$ 1118. Number of Days in a Month $\\star$ 1119. Remove Vowels from a String $\\star$ 1120. Maximum Average Subtree $\\star\\star$","title":"1111-1120"},{"location":"golang/1101-1200/1111-1120/#1111-maximum-nesting-depth-of-two-valid-parentheses-strings-starstar","text":"","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$"},{"location":"golang/1101-1200/1111-1120/#1112-highest-grade-for-each-student-starstar","text":"","title":"1112. Highest Grade For Each Student $\\star\\star$"},{"location":"golang/1101-1200/1111-1120/#1113-reported-posts-star","text":"","title":"1113. Reported Posts $\\star$"},{"location":"golang/1101-1200/1111-1120/#1114-print-in-order-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Foo { public : Foo () { mutex2 . lock (); mutex3 . lock (); } void first ( function < void () > printFirst ) { printFirst (); mutex2 . unlock (); } void second ( function < void () > printSecond ) { mutex2 . lock (); printSecond (); mutex3 . unlock (); } void third ( function < void () > printThird ) { mutex3 . lock (); printThird (); } private : mutex mutex2 ; mutex mutex3 ; };","title":"1114. Print in Order $\\star$"},{"location":"golang/1101-1200/1111-1120/#1115-print-foobar-alternately-starstar","text":"","title":"1115. Print FooBar Alternately $\\star\\star$"},{"location":"golang/1101-1200/1111-1120/#1116-print-zero-even-odd-starstar","text":"","title":"1116. Print Zero Even Odd $\\star\\star$"},{"location":"golang/1101-1200/1111-1120/#1117-building-h2o-starstar","text":"","title":"1117. Building H2O $\\star\\star$"},{"location":"golang/1101-1200/1111-1120/#1118-number-of-days-in-a-month-star","text":"","title":"1118. Number of Days in a Month $\\star$"},{"location":"golang/1101-1200/1111-1120/#1119-remove-vowels-from-a-string-star","text":"","title":"1119. Remove Vowels from a String $\\star$"},{"location":"golang/1101-1200/1111-1120/#1120-maximum-average-subtree-starstar","text":"","title":"1120. Maximum Average Subtree $\\star\\star$"},{"location":"golang/1101-1200/1121-1130/","text":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$ 1122. Relative Sort Array $\\star$ 1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$ 1124. Longest Well-Performing Interval $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int longestWPI ( vector < int >& hours ) { int ans = 0 ; int presum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < hours . size (); ++ i ) { presum += hours [ i ] > 8 ? 1 : - 1 ; if ( presum > 0 ) { ans = i + 1 ; } else { if ( ! map . count ( presum )) map [ presum ] = i ; if ( map . count ( presum - 1 )) ans = max ( ans , i - map [ presum - 1 ]); } } return ans ; } }; 1125. Smallest Sufficient Team $\\star\\star\\star$ 1126. Active Businesses $\\star\\star$ 1127. User Purchase Platform $\\star\\star\\star$ 1128. Number of Equivalent Domino Pairs $\\star$ 1129. Shortest Path with Alternating Colors $\\star\\star$ 1130. Minimum Cost Tree From Leaf Values $\\star\\star$","title":"1121-1130"},{"location":"golang/1101-1200/1121-1130/#1121-divide-array-into-increasing-sequences-starstarstar","text":"","title":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$"},{"location":"golang/1101-1200/1121-1130/#1122-relative-sort-array-star","text":"","title":"1122. Relative Sort Array $\\star$"},{"location":"golang/1101-1200/1121-1130/#1123-lowest-common-ancestor-of-deepest-leaves-starstar","text":"","title":"1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$"},{"location":"golang/1101-1200/1121-1130/#1124-longest-well-performing-interval-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int longestWPI ( vector < int >& hours ) { int ans = 0 ; int presum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < hours . size (); ++ i ) { presum += hours [ i ] > 8 ? 1 : - 1 ; if ( presum > 0 ) { ans = i + 1 ; } else { if ( ! map . count ( presum )) map [ presum ] = i ; if ( map . count ( presum - 1 )) ans = max ( ans , i - map [ presum - 1 ]); } } return ans ; } };","title":"1124. Longest Well-Performing Interval $\\star\\star$"},{"location":"golang/1101-1200/1121-1130/#1125-smallest-sufficient-team-starstarstar","text":"","title":"1125. Smallest Sufficient Team $\\star\\star\\star$"},{"location":"golang/1101-1200/1121-1130/#1126-active-businesses-starstar","text":"","title":"1126. Active Businesses $\\star\\star$"},{"location":"golang/1101-1200/1121-1130/#1127-user-purchase-platform-starstarstar","text":"","title":"1127. User Purchase Platform $\\star\\star\\star$"},{"location":"golang/1101-1200/1121-1130/#1128-number-of-equivalent-domino-pairs-star","text":"","title":"1128. Number of Equivalent Domino Pairs $\\star$"},{"location":"golang/1101-1200/1121-1130/#1129-shortest-path-with-alternating-colors-starstar","text":"","title":"1129. Shortest Path with Alternating Colors $\\star\\star$"},{"location":"golang/1101-1200/1121-1130/#1130-minimum-cost-tree-from-leaf-values-starstar","text":"","title":"1130. Minimum Cost Tree From Leaf Values $\\star\\star$"},{"location":"golang/1101-1200/1131-1140/","text":"1131. Maximum of Absolute Value Expression $\\star\\star$ 1132. Reported Posts II $\\star\\star$ 1133. Largest Unique Number $\\star$ 1134. Armstrong Number $\\star$ 1135. Connecting Cities With Minimum Cost $\\star\\star$ 1136. Parallel Courses $\\star\\star\\star$ 1137. N-th Tribonacci Number $\\star$ 1138. Alphabet Board Path $\\star\\star$ 1139. Largest 1-Bordered Square $\\star\\star$ 1140. Stone Game II $\\star\\star$","title":"1131-1140"},{"location":"golang/1101-1200/1131-1140/#1131-maximum-of-absolute-value-expression-starstar","text":"","title":"1131. Maximum of Absolute Value Expression $\\star\\star$"},{"location":"golang/1101-1200/1131-1140/#1132-reported-posts-ii-starstar","text":"","title":"1132. Reported Posts II $\\star\\star$"},{"location":"golang/1101-1200/1131-1140/#1133-largest-unique-number-star","text":"","title":"1133. Largest Unique Number $\\star$"},{"location":"golang/1101-1200/1131-1140/#1134-armstrong-number-star","text":"","title":"1134. Armstrong Number $\\star$"},{"location":"golang/1101-1200/1131-1140/#1135-connecting-cities-with-minimum-cost-starstar","text":"","title":"1135. Connecting Cities With Minimum Cost $\\star\\star$"},{"location":"golang/1101-1200/1131-1140/#1136-parallel-courses-starstarstar","text":"","title":"1136. Parallel Courses $\\star\\star\\star$"},{"location":"golang/1101-1200/1131-1140/#1137-n-th-tribonacci-number-star","text":"","title":"1137. N-th Tribonacci Number $\\star$"},{"location":"golang/1101-1200/1131-1140/#1138-alphabet-board-path-starstar","text":"","title":"1138. Alphabet Board Path $\\star\\star$"},{"location":"golang/1101-1200/1131-1140/#1139-largest-1-bordered-square-starstar","text":"","title":"1139. Largest 1-Bordered Square $\\star\\star$"},{"location":"golang/1101-1200/1131-1140/#1140-stone-game-ii-starstar","text":"","title":"1140. Stone Game II $\\star\\star$"},{"location":"golang/1101-1200/1141-1150/","text":"1141. User Activity for the Past 30 Days I $\\star$ 1142. User Activity for the Past 30 Days II $\\star$ 1143. Longest Common Subsequence $\\star\\star$ 1144. Decrease Elements To Make Array Zigzag $\\star\\star$ 1145. Binary Tree Coloring Game $\\star\\star$ 1146. Snapshot Array $\\star\\star$ 1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$ 1148. Article Views I $\\star$ 1149. Article Views II $\\star\\star$ 1150. Check If a Number Is Majority Element in a Sorted Array $\\star$","title":"1141-1150"},{"location":"golang/1101-1200/1141-1150/#1141-user-activity-for-the-past-30-days-i-star","text":"","title":"1141. User Activity for the Past 30 Days I $\\star$"},{"location":"golang/1101-1200/1141-1150/#1142-user-activity-for-the-past-30-days-ii-star","text":"","title":"1142. User Activity for the Past 30 Days II $\\star$"},{"location":"golang/1101-1200/1141-1150/#1143-longest-common-subsequence-starstar","text":"","title":"1143. Longest Common Subsequence $\\star\\star$"},{"location":"golang/1101-1200/1141-1150/#1144-decrease-elements-to-make-array-zigzag-starstar","text":"","title":"1144. Decrease Elements To Make Array Zigzag $\\star\\star$"},{"location":"golang/1101-1200/1141-1150/#1145-binary-tree-coloring-game-starstar","text":"","title":"1145. Binary Tree Coloring Game $\\star\\star$"},{"location":"golang/1101-1200/1141-1150/#1146-snapshot-array-starstar","text":"","title":"1146. Snapshot Array $\\star\\star$"},{"location":"golang/1101-1200/1141-1150/#1147-longest-chunked-palindrome-decomposition-starstarstar","text":"","title":"1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$"},{"location":"golang/1101-1200/1141-1150/#1148-article-views-i-star","text":"","title":"1148. Article Views I $\\star$"},{"location":"golang/1101-1200/1141-1150/#1149-article-views-ii-starstar","text":"","title":"1149. Article Views II $\\star\\star$"},{"location":"golang/1101-1200/1141-1150/#1150-check-if-a-number-is-majority-element-in-a-sorted-array-star","text":"","title":"1150. Check If a Number Is Majority Element in a Sorted Array $\\star$"},{"location":"golang/1101-1200/1151-1160/","text":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$ 1152. Analyze User Website Visit Pattern $\\star\\star$ 1153. String Transforms Into Another String $\\star\\star\\star$ 1154. Day of the Year $\\star$ 1155. Number of Dice Rolls With Target Sum $\\star\\star$ 1156. Swap For Longest Repeated Character Substring $\\star\\star$ 1157. Online Majority Element In Subarray $\\star\\star\\star$ 1158. Market Analysis I $\\star\\star$ 1159. Market Analysis II $\\star\\star\\star$ 1160. Find Words That Can Be Formed by Characters $\\star$","title":"1151-1160"},{"location":"golang/1101-1200/1151-1160/#1151-minimum-swaps-to-group-all-1s-together-starstar","text":"","title":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$"},{"location":"golang/1101-1200/1151-1160/#1152-analyze-user-website-visit-pattern-starstar","text":"","title":"1152. Analyze User Website Visit Pattern $\\star\\star$"},{"location":"golang/1101-1200/1151-1160/#1153-string-transforms-into-another-string-starstarstar","text":"","title":"1153. String Transforms Into Another String $\\star\\star\\star$"},{"location":"golang/1101-1200/1151-1160/#1154-day-of-the-year-star","text":"","title":"1154. Day of the Year $\\star$"},{"location":"golang/1101-1200/1151-1160/#1155-number-of-dice-rolls-with-target-sum-starstar","text":"","title":"1155. Number of Dice Rolls With Target Sum $\\star\\star$"},{"location":"golang/1101-1200/1151-1160/#1156-swap-for-longest-repeated-character-substring-starstar","text":"","title":"1156. Swap For Longest Repeated Character Substring $\\star\\star$"},{"location":"golang/1101-1200/1151-1160/#1157-online-majority-element-in-subarray-starstarstar","text":"","title":"1157. Online Majority Element In Subarray $\\star\\star\\star$"},{"location":"golang/1101-1200/1151-1160/#1158-market-analysis-i-starstar","text":"","title":"1158. Market Analysis I $\\star\\star$"},{"location":"golang/1101-1200/1151-1160/#1159-market-analysis-ii-starstarstar","text":"","title":"1159. Market Analysis II $\\star\\star\\star$"},{"location":"golang/1101-1200/1151-1160/#1160-find-words-that-can-be-formed-by-characters-star","text":"","title":"1160. Find Words That Can Be Formed by Characters $\\star$"},{"location":"golang/1101-1200/1161-1170/","text":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$ 1162. As Far from Land as Possible $\\star\\star$ 1163. Last Substring in Lexicographical Order $\\star\\star\\star$ 1164. Product Price at a Given Date $\\star\\star$ 1165. Single-Row Keyboard $\\star$ 1166. Design File System $\\star\\star$ 1167. Minimum Cost to Connect Sticks $\\star\\star$ 1168. Optimize Water Distribution in a Village $\\star\\star\\star$ 1169. Invalid Transactions $\\star\\star$ 1170. Compare Strings by Frequency of the Smallest Character $\\star$","title":"1161-1170"},{"location":"golang/1101-1200/1161-1170/#1161-maximum-level-sum-of-a-binary-tree-starstar","text":"","title":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$"},{"location":"golang/1101-1200/1161-1170/#1162-as-far-from-land-as-possible-starstar","text":"","title":"1162. As Far from Land as Possible $\\star\\star$"},{"location":"golang/1101-1200/1161-1170/#1163-last-substring-in-lexicographical-order-starstarstar","text":"","title":"1163. Last Substring in Lexicographical Order $\\star\\star\\star$"},{"location":"golang/1101-1200/1161-1170/#1164-product-price-at-a-given-date-starstar","text":"","title":"1164. Product Price at a Given Date $\\star\\star$"},{"location":"golang/1101-1200/1161-1170/#1165-single-row-keyboard-star","text":"","title":"1165. Single-Row Keyboard $\\star$"},{"location":"golang/1101-1200/1161-1170/#1166-design-file-system-starstar","text":"","title":"1166. Design File System $\\star\\star$"},{"location":"golang/1101-1200/1161-1170/#1167-minimum-cost-to-connect-sticks-starstar","text":"","title":"1167. Minimum Cost to Connect Sticks $\\star\\star$"},{"location":"golang/1101-1200/1161-1170/#1168-optimize-water-distribution-in-a-village-starstarstar","text":"","title":"1168. Optimize Water Distribution in a Village $\\star\\star\\star$"},{"location":"golang/1101-1200/1161-1170/#1169-invalid-transactions-starstar","text":"","title":"1169. Invalid Transactions $\\star\\star$"},{"location":"golang/1101-1200/1161-1170/#1170-compare-strings-by-frequency-of-the-smallest-character-star","text":"","title":"1170. Compare Strings by Frequency of the Smallest Character $\\star$"},{"location":"golang/1101-1200/1171-1180/","text":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$ 1172. Dinner Plate Stacks $\\star\\star\\star$ 1173. Immediate Food Delivery I $\\star$ 1174. Immediate Food Delivery II $\\star\\star$ 1175. Prime Arrangements $\\star$ 1176. Diet Plan Performance $\\star$ 1177. Can Make Palindrome from Substring $\\star\\star$ 1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$ 1179. Reformat Department Table $\\star$ 1180. Count Substrings with Only One Distinct Letter $\\star$","title":"1171-1180"},{"location":"golang/1101-1200/1171-1180/#1171-remove-zero-sum-consecutive-nodes-from-linked-list-starstar","text":"","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$"},{"location":"golang/1101-1200/1171-1180/#1172-dinner-plate-stacks-starstarstar","text":"","title":"1172. Dinner Plate Stacks $\\star\\star\\star$"},{"location":"golang/1101-1200/1171-1180/#1173-immediate-food-delivery-i-star","text":"","title":"1173. Immediate Food Delivery I $\\star$"},{"location":"golang/1101-1200/1171-1180/#1174-immediate-food-delivery-ii-starstar","text":"","title":"1174. Immediate Food Delivery II $\\star\\star$"},{"location":"golang/1101-1200/1171-1180/#1175-prime-arrangements-star","text":"","title":"1175. Prime Arrangements $\\star$"},{"location":"golang/1101-1200/1171-1180/#1176-diet-plan-performance-star","text":"","title":"1176. Diet Plan Performance $\\star$"},{"location":"golang/1101-1200/1171-1180/#1177-can-make-palindrome-from-substring-starstar","text":"","title":"1177. Can Make Palindrome from Substring $\\star\\star$"},{"location":"golang/1101-1200/1171-1180/#1178-number-of-valid-words-for-each-puzzle-starstarstar","text":"","title":"1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$"},{"location":"golang/1101-1200/1171-1180/#1179-reformat-department-table-star","text":"","title":"1179. Reformat Department Table $\\star$"},{"location":"golang/1101-1200/1171-1180/#1180-count-substrings-with-only-one-distinct-letter-star","text":"","title":"1180. Count Substrings with Only One Distinct Letter $\\star$"},{"location":"golang/1101-1200/1181-1190/","text":"1181. Before and After Puzzle $\\star\\star$ 1182. Shortest Distance to Target Color $\\star\\star$ 1183. Maximum Number of Ones $\\star\\star\\star$ 1184. Distance Between Bus Stops $\\star$ 1185. Day of the Week $\\star$ 1186. Maximum Subarray Sum with One Deletion $\\star\\star$ 1187. Make Array Strictly Increasing $\\star\\star\\star$ 1188. Design Bounded Blocking Queue $\\star\\star$ 1189. Maximum Number of Balloons $\\star$ 1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$","title":"1181-1190"},{"location":"golang/1101-1200/1181-1190/#1181-before-and-after-puzzle-starstar","text":"","title":"1181. Before and After Puzzle $\\star\\star$"},{"location":"golang/1101-1200/1181-1190/#1182-shortest-distance-to-target-color-starstar","text":"","title":"1182. Shortest Distance to Target Color $\\star\\star$"},{"location":"golang/1101-1200/1181-1190/#1183-maximum-number-of-ones-starstarstar","text":"","title":"1183. Maximum Number of Ones $\\star\\star\\star$"},{"location":"golang/1101-1200/1181-1190/#1184-distance-between-bus-stops-star","text":"","title":"1184. Distance Between Bus Stops $\\star$"},{"location":"golang/1101-1200/1181-1190/#1185-day-of-the-week-star","text":"","title":"1185. Day of the Week $\\star$"},{"location":"golang/1101-1200/1181-1190/#1186-maximum-subarray-sum-with-one-deletion-starstar","text":"","title":"1186. Maximum Subarray Sum with One Deletion $\\star\\star$"},{"location":"golang/1101-1200/1181-1190/#1187-make-array-strictly-increasing-starstarstar","text":"","title":"1187. Make Array Strictly Increasing $\\star\\star\\star$"},{"location":"golang/1101-1200/1181-1190/#1188-design-bounded-blocking-queue-starstar","text":"","title":"1188. Design Bounded Blocking Queue $\\star\\star$"},{"location":"golang/1101-1200/1181-1190/#1189-maximum-number-of-balloons-star","text":"","title":"1189. Maximum Number of Balloons $\\star$"},{"location":"golang/1101-1200/1181-1190/#1190-reverse-substrings-between-each-pair-of-parentheses-starstar","text":"","title":"1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$"},{"location":"golang/1101-1200/1191-1200/","text":"1191. K-Concatenation Maximum Sum $\\star\\star$ 1192. Critical Connections in a Network $\\star\\star\\star$ 1193. Monthly Transactions I $\\star\\star$ 1194. Tournament Winners $\\star\\star\\star$ 1195. Fizz Buzz Multithreaded $\\star\\star$ 1196. How Many Apples Can You Put into the Basket $\\star$ 1197. Minimum Knight Moves $\\star\\star$ 1198. Find Smallest Common Element in All Rows $\\star\\star$ 1199. Minimum Time to Build Blocks $\\star\\star\\star$ 1200. Minimum Absolute Difference $\\star$","title":"1191-1200"},{"location":"golang/1101-1200/1191-1200/#1191-k-concatenation-maximum-sum-starstar","text":"","title":"1191. K-Concatenation Maximum Sum $\\star\\star$"},{"location":"golang/1101-1200/1191-1200/#1192-critical-connections-in-a-network-starstarstar","text":"","title":"1192. Critical Connections in a Network $\\star\\star\\star$"},{"location":"golang/1101-1200/1191-1200/#1193-monthly-transactions-i-starstar","text":"","title":"1193. Monthly Transactions I $\\star\\star$"},{"location":"golang/1101-1200/1191-1200/#1194-tournament-winners-starstarstar","text":"","title":"1194. Tournament Winners $\\star\\star\\star$"},{"location":"golang/1101-1200/1191-1200/#1195-fizz-buzz-multithreaded-starstar","text":"","title":"1195. Fizz Buzz Multithreaded $\\star\\star$"},{"location":"golang/1101-1200/1191-1200/#1196-how-many-apples-can-you-put-into-the-basket-star","text":"","title":"1196. How Many Apples Can You Put into the Basket $\\star$"},{"location":"golang/1101-1200/1191-1200/#1197-minimum-knight-moves-starstar","text":"","title":"1197. Minimum Knight Moves $\\star\\star$"},{"location":"golang/1101-1200/1191-1200/#1198-find-smallest-common-element-in-all-rows-starstar","text":"","title":"1198. Find Smallest Common Element in All Rows $\\star\\star$"},{"location":"golang/1101-1200/1191-1200/#1199-minimum-time-to-build-blocks-starstarstar","text":"","title":"1199. Minimum Time to Build Blocks $\\star\\star\\star$"},{"location":"golang/1101-1200/1191-1200/#1200-minimum-absolute-difference-star","text":"","title":"1200. Minimum Absolute Difference $\\star$"},{"location":"golang/1201-1300/1201-1210/","text":"1201. Ugly Number III $\\star\\star$ 1202. Smallest String With Swaps $\\star\\star$ 1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$ 1204. Last Person to Fit in the Elevator $\\star\\star$ 1205. Monthly Transactions II $\\star\\star$ 1206. Design Skiplist $\\star\\star\\star$ 1207. Unique Number of Occurrences $\\star$ 1208. Get Equal Substrings Within Budget $\\star\\star$ 1209. Remove All Adjacent Duplicates in String II $\\star\\star$ 1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$","title":"1201-1210"},{"location":"golang/1201-1300/1201-1210/#1201-ugly-number-iii-starstar","text":"","title":"1201. Ugly Number III $\\star\\star$"},{"location":"golang/1201-1300/1201-1210/#1202-smallest-string-with-swaps-starstar","text":"","title":"1202. Smallest String With Swaps $\\star\\star$"},{"location":"golang/1201-1300/1201-1210/#1203-sort-items-by-groups-respecting-dependencies-starstarstar","text":"","title":"1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$"},{"location":"golang/1201-1300/1201-1210/#1204-last-person-to-fit-in-the-elevator-starstar","text":"","title":"1204. Last Person to Fit in the Elevator $\\star\\star$"},{"location":"golang/1201-1300/1201-1210/#1205-monthly-transactions-ii-starstar","text":"","title":"1205. Monthly Transactions II $\\star\\star$"},{"location":"golang/1201-1300/1201-1210/#1206-design-skiplist-starstarstar","text":"","title":"1206. Design Skiplist $\\star\\star\\star$"},{"location":"golang/1201-1300/1201-1210/#1207-unique-number-of-occurrences-star","text":"","title":"1207. Unique Number of Occurrences $\\star$"},{"location":"golang/1201-1300/1201-1210/#1208-get-equal-substrings-within-budget-starstar","text":"","title":"1208. Get Equal Substrings Within Budget $\\star\\star$"},{"location":"golang/1201-1300/1201-1210/#1209-remove-all-adjacent-duplicates-in-string-ii-starstar","text":"","title":"1209. Remove All Adjacent Duplicates in String II $\\star\\star$"},{"location":"golang/1201-1300/1201-1210/#1210-minimum-moves-to-reach-target-with-rotations-starstarstar","text":"","title":"1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$"},{"location":"golang/1201-1300/1211-1220/","text":"1211. Queries Quality and Percentage $\\star$ 1212. Team Scores in Football Tournament $\\star\\star$ 1213. Intersection of Three Sorted Arrays $\\star$ 1214. Two Sum BSTs $\\star\\star$ 1215. Stepping Numbers $\\star\\star$ 1216. Valid Palindrome III $\\star\\star\\star$ 1217. Play with Chips $\\star$ 1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$ 1219. Path with Maximum Gold $\\star\\star$ 1220. Count Vowels Permutation $\\star\\star\\star$","title":"1211-1220"},{"location":"golang/1201-1300/1211-1220/#1211-queries-quality-and-percentage-star","text":"","title":"1211. Queries Quality and Percentage $\\star$"},{"location":"golang/1201-1300/1211-1220/#1212-team-scores-in-football-tournament-starstar","text":"","title":"1212. Team Scores in Football Tournament $\\star\\star$"},{"location":"golang/1201-1300/1211-1220/#1213-intersection-of-three-sorted-arrays-star","text":"","title":"1213. Intersection of Three Sorted Arrays $\\star$"},{"location":"golang/1201-1300/1211-1220/#1214-two-sum-bsts-starstar","text":"","title":"1214. Two Sum BSTs $\\star\\star$"},{"location":"golang/1201-1300/1211-1220/#1215-stepping-numbers-starstar","text":"","title":"1215. Stepping Numbers $\\star\\star$"},{"location":"golang/1201-1300/1211-1220/#1216-valid-palindrome-iii-starstarstar","text":"","title":"1216. Valid Palindrome III $\\star\\star\\star$"},{"location":"golang/1201-1300/1211-1220/#1217-play-with-chips-star","text":"","title":"1217. Play with Chips $\\star$"},{"location":"golang/1201-1300/1211-1220/#1218-longest-arithmetic-subsequence-of-given-difference-starstar","text":"","title":"1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$"},{"location":"golang/1201-1300/1211-1220/#1219-path-with-maximum-gold-starstar","text":"","title":"1219. Path with Maximum Gold $\\star\\star$"},{"location":"golang/1201-1300/1211-1220/#1220-count-vowels-permutation-starstarstar","text":"","title":"1220. Count Vowels Permutation $\\star\\star\\star$"},{"location":"golang/1201-1300/1221-1230/","text":"1221. Split a String in Balanced Strings $\\star$ 1222. Queens That Can Attack the King $\\star\\star$ 1223. Dice Roll Simulation $\\star\\star$ 1224. Maximum Equal Frequency $\\star\\star\\star$ 1225. Report Contiguous Dates $\\star\\star\\star$ 1226. The Dining Philosophers $\\star\\star$ 1227. Airplane Seat Assignment Probability $\\star\\star$ 1228. Missing Number In Arithmetic Progression $\\star$ 1229. Meeting Scheduler $\\star\\star$ 1230. Toss Strange Coins $\\star\\star$","title":"1221-1230"},{"location":"golang/1201-1300/1221-1230/#1221-split-a-string-in-balanced-strings-star","text":"","title":"1221. Split a String in Balanced Strings $\\star$"},{"location":"golang/1201-1300/1221-1230/#1222-queens-that-can-attack-the-king-starstar","text":"","title":"1222. Queens That Can Attack the King $\\star\\star$"},{"location":"golang/1201-1300/1221-1230/#1223-dice-roll-simulation-starstar","text":"","title":"1223. Dice Roll Simulation $\\star\\star$"},{"location":"golang/1201-1300/1221-1230/#1224-maximum-equal-frequency-starstarstar","text":"","title":"1224. Maximum Equal Frequency $\\star\\star\\star$"},{"location":"golang/1201-1300/1221-1230/#1225-report-contiguous-dates-starstarstar","text":"","title":"1225. Report Contiguous Dates $\\star\\star\\star$"},{"location":"golang/1201-1300/1221-1230/#1226-the-dining-philosophers-starstar","text":"","title":"1226. The Dining Philosophers $\\star\\star$"},{"location":"golang/1201-1300/1221-1230/#1227-airplane-seat-assignment-probability-starstar","text":"","title":"1227. Airplane Seat Assignment Probability $\\star\\star$"},{"location":"golang/1201-1300/1221-1230/#1228-missing-number-in-arithmetic-progression-star","text":"","title":"1228. Missing Number In Arithmetic Progression $\\star$"},{"location":"golang/1201-1300/1221-1230/#1229-meeting-scheduler-starstar","text":"","title":"1229. Meeting Scheduler $\\star\\star$"},{"location":"golang/1201-1300/1221-1230/#1230-toss-strange-coins-starstar","text":"","title":"1230. Toss Strange Coins $\\star\\star$"},{"location":"golang/1201-1300/1231-1240/","text":"1231. Divide Chocolate $\\star\\star\\star$ 1232. Check If It Is a Straight Line $\\star$ 1233. Remove Sub-Folders from the Filesystem $\\star\\star$ 1234. Replace the Substring for Balanced String $\\star\\star$ 1235. Maximum Profit in Job Scheduling $\\star\\star\\star$ 1236. Web Crawler $\\star\\star$ 1237. Find Positive Integer Solution for a Given Equation $\\star$ 1238. Circular Permutation in Binary Representation $\\star\\star$ 1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$ 1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$","title":"1231-1240"},{"location":"golang/1201-1300/1231-1240/#1231-divide-chocolate-starstarstar","text":"","title":"1231. Divide Chocolate $\\star\\star\\star$"},{"location":"golang/1201-1300/1231-1240/#1232-check-if-it-is-a-straight-line-star","text":"","title":"1232. Check If It Is a Straight Line $\\star$"},{"location":"golang/1201-1300/1231-1240/#1233-remove-sub-folders-from-the-filesystem-starstar","text":"","title":"1233. Remove Sub-Folders from the Filesystem $\\star\\star$"},{"location":"golang/1201-1300/1231-1240/#1234-replace-the-substring-for-balanced-string-starstar","text":"","title":"1234. Replace the Substring for Balanced String $\\star\\star$"},{"location":"golang/1201-1300/1231-1240/#1235-maximum-profit-in-job-scheduling-starstarstar","text":"","title":"1235. Maximum Profit in Job Scheduling $\\star\\star\\star$"},{"location":"golang/1201-1300/1231-1240/#1236-web-crawler-starstar","text":"","title":"1236. Web Crawler $\\star\\star$"},{"location":"golang/1201-1300/1231-1240/#1237-find-positive-integer-solution-for-a-given-equation-star","text":"","title":"1237. Find Positive Integer Solution for a Given Equation $\\star$"},{"location":"golang/1201-1300/1231-1240/#1238-circular-permutation-in-binary-representation-starstar","text":"","title":"1238. Circular Permutation in Binary Representation $\\star\\star$"},{"location":"golang/1201-1300/1231-1240/#1239-maximum-length-of-a-concatenated-string-with-unique-characters-starstar","text":"","title":"1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$"},{"location":"golang/1201-1300/1231-1240/#1240-tiling-a-rectangle-with-the-fewest-squares-starstarstar","text":"","title":"1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$"},{"location":"golang/1201-1300/1241-1250/","text":"1241. Number of Comments per Post $\\star$ 1242. Web Crawler Multithreaded $\\star\\star$ 1243. Array Transformation $\\star$ 1244. Design A Leaderboard $\\star\\star$ 1245. Tree Diameter $\\star\\star$ 1246. Palindrome Removal $\\star\\star\\star$ 1247. Minimum Swaps to Make Strings Equal $\\star\\star$ 1248. Count Number of Nice Subarrays $\\star\\star$ 1249. Minimum Remove to Make Valid Parentheses $\\star\\star$ 1250. Check If It Is a Good Array $\\star\\star\\star$","title":"1241-1250"},{"location":"golang/1201-1300/1241-1250/#1241-number-of-comments-per-post-star","text":"","title":"1241. Number of Comments per Post $\\star$"},{"location":"golang/1201-1300/1241-1250/#1242-web-crawler-multithreaded-starstar","text":"","title":"1242. Web Crawler Multithreaded $\\star\\star$"},{"location":"golang/1201-1300/1241-1250/#1243-array-transformation-star","text":"","title":"1243. Array Transformation $\\star$"},{"location":"golang/1201-1300/1241-1250/#1244-design-a-leaderboard-starstar","text":"","title":"1244. Design A Leaderboard $\\star\\star$"},{"location":"golang/1201-1300/1241-1250/#1245-tree-diameter-starstar","text":"","title":"1245. Tree Diameter $\\star\\star$"},{"location":"golang/1201-1300/1241-1250/#1246-palindrome-removal-starstarstar","text":"","title":"1246. Palindrome Removal $\\star\\star\\star$"},{"location":"golang/1201-1300/1241-1250/#1247-minimum-swaps-to-make-strings-equal-starstar","text":"","title":"1247. Minimum Swaps to Make Strings Equal $\\star\\star$"},{"location":"golang/1201-1300/1241-1250/#1248-count-number-of-nice-subarrays-starstar","text":"","title":"1248. Count Number of Nice Subarrays $\\star\\star$"},{"location":"golang/1201-1300/1241-1250/#1249-minimum-remove-to-make-valid-parentheses-starstar","text":"","title":"1249. Minimum Remove to Make Valid Parentheses $\\star\\star$"},{"location":"golang/1201-1300/1241-1250/#1250-check-if-it-is-a-good-array-starstarstar","text":"","title":"1250. Check If It Is a Good Array $\\star\\star\\star$"},{"location":"golang/1201-1300/1251-1260/","text":"1251. Average Selling Price $\\star$ 1252. Cells with Odd Values in a Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int oddCells ( int n , int m , vector < vector < int >>& indices ) { int ans = 0 ; vector < int > rows ( n ); vector < int > cols ( m ); for ( vector < int >& indice : indices ) { rows [ indice [ 0 ]] ^= 1 ; cols [ indice [ 1 ]] ^= 1 ; } for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) ans += rows [ i ] ^ cols [ j ]; return ans ; } }; 1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$ 1254. Number of Closed Islands $\\star\\star$ 1255. Maximum Score Words Formed by Letters $\\star\\star\\star$ 1256. Encode Number $\\star\\star$ 1257. Smallest Common Region $\\star\\star$ 1258. Synonymous Sentences $\\star\\star$ 1259. Handshakes That Don't Cross $\\star\\star\\star$ 1260. Shift 2D Grid $\\star$","title":"1251-1260"},{"location":"golang/1201-1300/1251-1260/#1251-average-selling-price-star","text":"","title":"1251. Average Selling Price $\\star$"},{"location":"golang/1201-1300/1251-1260/#1252-cells-with-odd-values-in-a-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int oddCells ( int n , int m , vector < vector < int >>& indices ) { int ans = 0 ; vector < int > rows ( n ); vector < int > cols ( m ); for ( vector < int >& indice : indices ) { rows [ indice [ 0 ]] ^= 1 ; cols [ indice [ 1 ]] ^= 1 ; } for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < m ; ++ j ) ans += rows [ i ] ^ cols [ j ]; return ans ; } };","title":"1252. Cells with Odd Values in a Matrix $\\star$"},{"location":"golang/1201-1300/1251-1260/#1253-reconstruct-a-2-row-binary-matrix-starstar","text":"","title":"1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$"},{"location":"golang/1201-1300/1251-1260/#1254-number-of-closed-islands-starstar","text":"","title":"1254. Number of Closed Islands $\\star\\star$"},{"location":"golang/1201-1300/1251-1260/#1255-maximum-score-words-formed-by-letters-starstarstar","text":"","title":"1255. Maximum Score Words Formed by Letters $\\star\\star\\star$"},{"location":"golang/1201-1300/1251-1260/#1256-encode-number-starstar","text":"","title":"1256. Encode Number $\\star\\star$"},{"location":"golang/1201-1300/1251-1260/#1257-smallest-common-region-starstar","text":"","title":"1257. Smallest Common Region $\\star\\star$"},{"location":"golang/1201-1300/1251-1260/#1258-synonymous-sentences-starstar","text":"","title":"1258. Synonymous Sentences $\\star\\star$"},{"location":"golang/1201-1300/1251-1260/#1259-handshakes-that-dont-cross-starstarstar","text":"","title":"1259. Handshakes That Don't Cross $\\star\\star\\star$"},{"location":"golang/1201-1300/1251-1260/#1260-shift-2d-grid-star","text":"","title":"1260. Shift 2D Grid $\\star$"},{"location":"golang/1201-1300/1261-1270/","text":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$ 1262. Greatest Sum Divisible by Three $\\star\\star$ 1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$ 1264. Page Recommendations $\\star\\star$ 1265. Print Immutable Linked List in Reverse $\\star\\star$ 1266. Minimum Time Visiting All Points $\\star$ 1267. Count Servers that Communicate $\\star\\star$ 1268. Search Suggestions System $\\star\\star$ 1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$ 1270. All People Report to the Given Manager $\\star\\star$","title":"1261-1270"},{"location":"golang/1201-1300/1261-1270/#1261-find-elements-in-a-contaminated-binary-tree-starstar","text":"","title":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$"},{"location":"golang/1201-1300/1261-1270/#1262-greatest-sum-divisible-by-three-starstar","text":"","title":"1262. Greatest Sum Divisible by Three $\\star\\star$"},{"location":"golang/1201-1300/1261-1270/#1263-minimum-moves-to-move-a-box-to-their-target-location-starstarstar","text":"","title":"1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$"},{"location":"golang/1201-1300/1261-1270/#1264-page-recommendations-starstar","text":"","title":"1264. Page Recommendations $\\star\\star$"},{"location":"golang/1201-1300/1261-1270/#1265-print-immutable-linked-list-in-reverse-starstar","text":"","title":"1265. Print Immutable Linked List in Reverse $\\star\\star$"},{"location":"golang/1201-1300/1261-1270/#1266-minimum-time-visiting-all-points-star","text":"","title":"1266. Minimum Time Visiting All Points $\\star$"},{"location":"golang/1201-1300/1261-1270/#1267-count-servers-that-communicate-starstar","text":"","title":"1267. Count Servers that Communicate $\\star\\star$"},{"location":"golang/1201-1300/1261-1270/#1268-search-suggestions-system-starstar","text":"","title":"1268. Search Suggestions System $\\star\\star$"},{"location":"golang/1201-1300/1261-1270/#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps-starstarstar","text":"","title":"1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$"},{"location":"golang/1201-1300/1261-1270/#1270-all-people-report-to-the-given-manager-starstar","text":"","title":"1270. All People Report to the Given Manager $\\star\\star$"},{"location":"golang/1201-1300/1271-1280/","text":"1271. Hexspeak $\\star$ 1272. Remove Interval $\\star\\star$ 1273. Delete Tree Nodes $\\star\\star$ 1274. Number of Ships in a Rectangle $\\star\\star\\star$ 1275. Find Winner on a Tic Tac Toe Game $\\star$ 1276. Number of Burgers with No Waste of Ingredients $\\star\\star$ 1277. Count Square Submatrices with All Ones $\\star\\star$ 1278. Palindrome Partitioning III $\\star\\star\\star$ 1279. Traffic Light Controlled Intersection $\\star$ 1280. Students and Examinations $\\star$","title":"1271-1280"},{"location":"golang/1201-1300/1271-1280/#1271-hexspeak-star","text":"","title":"1271. Hexspeak $\\star$"},{"location":"golang/1201-1300/1271-1280/#1272-remove-interval-starstar","text":"","title":"1272. Remove Interval $\\star\\star$"},{"location":"golang/1201-1300/1271-1280/#1273-delete-tree-nodes-starstar","text":"","title":"1273. Delete Tree Nodes $\\star\\star$"},{"location":"golang/1201-1300/1271-1280/#1274-number-of-ships-in-a-rectangle-starstarstar","text":"","title":"1274. Number of Ships in a Rectangle $\\star\\star\\star$"},{"location":"golang/1201-1300/1271-1280/#1275-find-winner-on-a-tic-tac-toe-game-star","text":"","title":"1275. Find Winner on a Tic Tac Toe Game $\\star$"},{"location":"golang/1201-1300/1271-1280/#1276-number-of-burgers-with-no-waste-of-ingredients-starstar","text":"","title":"1276. Number of Burgers with No Waste of Ingredients $\\star\\star$"},{"location":"golang/1201-1300/1271-1280/#1277-count-square-submatrices-with-all-ones-starstar","text":"","title":"1277. Count Square Submatrices with All Ones $\\star\\star$"},{"location":"golang/1201-1300/1271-1280/#1278-palindrome-partitioning-iii-starstarstar","text":"","title":"1278. Palindrome Partitioning III $\\star\\star\\star$"},{"location":"golang/1201-1300/1271-1280/#1279-traffic-light-controlled-intersection-star","text":"","title":"1279. Traffic Light Controlled Intersection $\\star$"},{"location":"golang/1201-1300/1271-1280/#1280-students-and-examinations-star","text":"","title":"1280. Students and Examinations $\\star$"},{"location":"golang/1201-1300/1281-1290/","text":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$ 1282. Group the People Given the Group Size They Belong To $\\star\\star$ 1283. Find the Smallest Divisor Given a Threshold $\\star\\star$ 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$ 1285. Find the Start and End Number of Continuous Ranges $\\star\\star$ 1286. Iterator for Combination $\\star\\star$ 1287. Element Appearing More Than 25% In Sorted Array $\\star$ 1288. Remove Covered Intervals $\\star\\star$ 1289. Minimum Falling Path Sum II $\\star\\star\\star$ 1290. Convert Binary Number in a Linked List to Integer $\\star$","title":"1281-1290"},{"location":"golang/1201-1300/1281-1290/#1281-subtract-the-product-and-sum-of-digits-of-an-integer-star","text":"","title":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$"},{"location":"golang/1201-1300/1281-1290/#1282-group-the-people-given-the-group-size-they-belong-to-starstar","text":"","title":"1282. Group the People Given the Group Size They Belong To $\\star\\star$"},{"location":"golang/1201-1300/1281-1290/#1283-find-the-smallest-divisor-given-a-threshold-starstar","text":"","title":"1283. Find the Smallest Divisor Given a Threshold $\\star\\star$"},{"location":"golang/1201-1300/1281-1290/#1284-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix-starstarstar","text":"","title":"1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$"},{"location":"golang/1201-1300/1281-1290/#1285-find-the-start-and-end-number-of-continuous-ranges-starstar","text":"","title":"1285. Find the Start and End Number of Continuous Ranges $\\star\\star$"},{"location":"golang/1201-1300/1281-1290/#1286-iterator-for-combination-starstar","text":"","title":"1286. Iterator for Combination $\\star\\star$"},{"location":"golang/1201-1300/1281-1290/#1287-element-appearing-more-than-25-in-sorted-array-star","text":"","title":"1287. Element Appearing More Than 25% In Sorted Array $\\star$"},{"location":"golang/1201-1300/1281-1290/#1288-remove-covered-intervals-starstar","text":"","title":"1288. Remove Covered Intervals $\\star\\star$"},{"location":"golang/1201-1300/1281-1290/#1289-minimum-falling-path-sum-ii-starstarstar","text":"","title":"1289. Minimum Falling Path Sum II $\\star\\star\\star$"},{"location":"golang/1201-1300/1281-1290/#1290-convert-binary-number-in-a-linked-list-to-integer-star","text":"","title":"1290. Convert Binary Number in a Linked List to Integer $\\star$"},{"location":"golang/1201-1300/1291-1300/","text":"1291. Sequential Digits $\\star\\star$ 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$ 1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$ 1294. Weather Type in Each Country $\\star$ 1295. Find Numbers with Even Number of Digits $\\star$ 1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$ 1297. Maximum Number of Occurrences of a Substring $\\star\\star$ 1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$ 1299. Replace Elements with Greatest Element on Right Side $\\star$ 1300. Sum of Mutated Array Closest to Target $\\star\\star$","title":"1291-1300"},{"location":"golang/1201-1300/1291-1300/#1291-sequential-digits-starstar","text":"","title":"1291. Sequential Digits $\\star\\star$"},{"location":"golang/1201-1300/1291-1300/#1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold-starstar","text":"","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$"},{"location":"golang/1201-1300/1291-1300/#1293-shortest-path-in-a-grid-with-obstacles-elimination-starstarstar","text":"","title":"1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$"},{"location":"golang/1201-1300/1291-1300/#1294-weather-type-in-each-country-star","text":"","title":"1294. Weather Type in Each Country $\\star$"},{"location":"golang/1201-1300/1291-1300/#1295-find-numbers-with-even-number-of-digits-star","text":"","title":"1295. Find Numbers with Even Number of Digits $\\star$"},{"location":"golang/1201-1300/1291-1300/#1296-divide-array-in-sets-of-k-consecutive-numbers-starstar","text":"","title":"1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$"},{"location":"golang/1201-1300/1291-1300/#1297-maximum-number-of-occurrences-of-a-substring-starstar","text":"","title":"1297. Maximum Number of Occurrences of a Substring $\\star\\star$"},{"location":"golang/1201-1300/1291-1300/#1298-maximum-candies-you-can-get-from-boxes-starstarstar","text":"","title":"1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$"},{"location":"golang/1201-1300/1291-1300/#1299-replace-elements-with-greatest-element-on-right-side-star","text":"","title":"1299. Replace Elements with Greatest Element on Right Side $\\star$"},{"location":"golang/1201-1300/1291-1300/#1300-sum-of-mutated-array-closest-to-target-starstar","text":"","title":"1300. Sum of Mutated Array Closest to Target $\\star\\star$"},{"location":"golang/1301-1400/1301-1310/","text":"1301. Number of Paths with Max Score $\\star\\star\\star$ 1302. Deepest Leaves Sum $\\star\\star$ 1303. Find the Team Size $\\star$ 1304. Find N Unique Integers Sum up to Zero $\\star$ 1305. All Elements in Two Binary Search Trees $\\star\\star$ 1306. Jump Game III $\\star\\star$ 1307. Verbal Arithmetic Puzzle $\\star\\star\\star$ 1308. Running Total for Different Genders $\\star\\star$ 1309. Decrypt String from Alphabet to Integer Mapping $\\star$ 1310. XOR Queries of a Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > xorQueries ( vector < int >& arr , vector < vector < int >>& queries ) { vector < int > ans ; vector < int > xors ( arr . size () + 1 ); for ( int i = 0 ; i < arr . size (); ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ]; for ( vector < int >& query : queries ) ans . push_back ( xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ]); return ans ; } };","title":"1301-1310"},{"location":"golang/1301-1400/1301-1310/#1301-number-of-paths-with-max-score-starstarstar","text":"","title":"1301. Number of Paths with Max Score $\\star\\star\\star$"},{"location":"golang/1301-1400/1301-1310/#1302-deepest-leaves-sum-starstar","text":"","title":"1302. Deepest Leaves Sum $\\star\\star$"},{"location":"golang/1301-1400/1301-1310/#1303-find-the-team-size-star","text":"","title":"1303. Find the Team Size $\\star$"},{"location":"golang/1301-1400/1301-1310/#1304-find-n-unique-integers-sum-up-to-zero-star","text":"","title":"1304. Find N Unique Integers Sum up to Zero $\\star$"},{"location":"golang/1301-1400/1301-1310/#1305-all-elements-in-two-binary-search-trees-starstar","text":"","title":"1305. All Elements in Two Binary Search Trees $\\star\\star$"},{"location":"golang/1301-1400/1301-1310/#1306-jump-game-iii-starstar","text":"","title":"1306. Jump Game III $\\star\\star$"},{"location":"golang/1301-1400/1301-1310/#1307-verbal-arithmetic-puzzle-starstarstar","text":"","title":"1307. Verbal Arithmetic Puzzle $\\star\\star\\star$"},{"location":"golang/1301-1400/1301-1310/#1308-running-total-for-different-genders-starstar","text":"","title":"1308. Running Total for Different Genders $\\star\\star$"},{"location":"golang/1301-1400/1301-1310/#1309-decrypt-string-from-alphabet-to-integer-mapping-star","text":"","title":"1309. Decrypt String from Alphabet to Integer Mapping $\\star$"},{"location":"golang/1301-1400/1301-1310/#1310-xor-queries-of-a-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > xorQueries ( vector < int >& arr , vector < vector < int >>& queries ) { vector < int > ans ; vector < int > xors ( arr . size () + 1 ); for ( int i = 0 ; i < arr . size (); ++ i ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ]; for ( vector < int >& query : queries ) ans . push_back ( xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ]); return ans ; } };","title":"1310. XOR Queries of a Subarray $\\star\\star$"},{"location":"golang/1301-1400/1311-1320/","text":"1311. Get Watched Videos by Your Friends $\\star\\star$ 1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$ 1313. Decompress Run-Length Encoded List $\\star$ 1314. Matrix Block Sum $\\star\\star$ 1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$ 1316. Distinct Echo Substrings $\\star\\star\\star$ 1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$ 1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$ 1319. Number of Operations to Make Network Connected $\\star\\star$ 1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$","title":"1311-1320"},{"location":"golang/1301-1400/1311-1320/#1311-get-watched-videos-by-your-friends-starstar","text":"","title":"1311. Get Watched Videos by Your Friends $\\star\\star$"},{"location":"golang/1301-1400/1311-1320/#1312-minimum-insertion-steps-to-make-a-string-palindrome-starstarstar","text":"","title":"1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$"},{"location":"golang/1301-1400/1311-1320/#1313-decompress-run-length-encoded-list-star","text":"","title":"1313. Decompress Run-Length Encoded List $\\star$"},{"location":"golang/1301-1400/1311-1320/#1314-matrix-block-sum-starstar","text":"","title":"1314. Matrix Block Sum $\\star\\star$"},{"location":"golang/1301-1400/1311-1320/#1315-sum-of-nodes-with-even-valued-grandparent-starstar","text":"","title":"1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$"},{"location":"golang/1301-1400/1311-1320/#1316-distinct-echo-substrings-starstarstar","text":"","title":"1316. Distinct Echo Substrings $\\star\\star\\star$"},{"location":"golang/1301-1400/1311-1320/#1317-convert-integer-to-the-sum-of-two-no-zero-integers-star","text":"","title":"1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$"},{"location":"golang/1301-1400/1311-1320/#1318-minimum-flips-to-make-a-or-b-equal-to-c-starstar","text":"","title":"1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$"},{"location":"golang/1301-1400/1311-1320/#1319-number-of-operations-to-make-network-connected-starstar","text":"","title":"1319. Number of Operations to Make Network Connected $\\star\\star$"},{"location":"golang/1301-1400/1311-1320/#1320-minimum-distance-to-type-a-word-using-two-fingers-starstarstar","text":"","title":"1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$"},{"location":"golang/1301-1400/1321-1330/","text":"1321. Restaurant Growth $\\star\\star$ 1322. Ads Performance $\\star$ 1323. Maximum 69 Number $\\star$ 1324. Print Words Vertically $\\star\\star$ 1325. Delete Leaves With a Given Value $\\star\\star$ 1326. Minimum Number of Taps to Open to Water a Garden $\\star\\star\\star$","title":"1321-1321"},{"location":"golang/1301-1400/1321-1330/#1321-restaurant-growth-starstar","text":"","title":"1321. Restaurant Growth $\\star\\star$"},{"location":"golang/1301-1400/1321-1330/#1322-ads-performance-star","text":"","title":"1322. Ads Performance $\\star$"},{"location":"golang/1301-1400/1321-1330/#1323-maximum-69-number-star","text":"","title":"1323. Maximum 69 Number $\\star$"},{"location":"golang/1301-1400/1321-1330/#1324-print-words-vertically-starstar","text":"","title":"1324. Print Words Vertically $\\star\\star$"},{"location":"golang/1301-1400/1321-1330/#1325-delete-leaves-with-a-given-value-starstar","text":"","title":"1325. Delete Leaves With a Given Value $\\star\\star$"},{"location":"golang/1301-1400/1321-1330/#1326-minimum-number-of-taps-to-open-to-water-a-garden-starstarstar","text":"","title":"1326. Minimum Number of Taps to Open to Water a Garden $\\star\\star\\star$"},{"location":"notes/buy-sell-stock/","text":"Best Time to Buy and Sell Stock \u7cfb\u5217DP\u95ee\u9898 2019-01 \u6574\u7406 \u53c2\u8003\u81ea LeetCode dicsuss \uff0c\u8fd9\u91cc\u505a\u4e00\u4e2a\u5907\u4efd\u548c\u81ea\u5df1\u6807\u6ce8\u7684\u7406\u89e3\uff0c\u539f\u6587\u5982\u4e0b\uff1a Most consistent ways of dealing with the series of stock problems Note: this is a repost of my original post here with updated solutions for this problem 714. Best Time to Buy and Sell Stock with Transaction Fee . If you are only looking for solutions, you can go directly to each section in part II -- Applications to specific cases . Up to this point, I believe you have finished the following series of stock problems: 121. Best Time to Buy and Sell Stock 122. Best Time to Buy and Sell Stock II 123. Best Time to Buy and Sell Stock III 188. Best Time to Buy and Sell Stock IV 309. Best Time to Buy and Sell Stock with Cooldown 714. Best Time to Buy and Sell Stock with Transaction Fee For each problem, we've got a couple of excellent posts explaining how to approach it. However, most of the posts failed to identify the connections among these problems and made it hard to develop a consistent way of dealing with this series of problems. Here I will introduce the most generalized solution applicable to all of these problems, and its specialization to each of the six problems above. I -- General cases The idea begins with the following question: Given an array representing the price of stocks on each day, what determines the maximum profit we can obtain? Most of you can quickly come up with answers like \"it depends on which day we are and how many transactions we are allowed to complete\". Sure, those are important factors as they manifest themselves in the problem descriptions. However, there is a hidden factor that is not so obvious but vital in determining the maximum profit, which is elaborated below. First let's spell out the notations to streamline our analyses. Let prices be the stock price array with length n , i denote the i-th day ( i will go from 0 to n-1), k denote the maximum number of transactions allowed to complete, T[i][k] be the maximum profit that could be gained at the end of the i-th day with at most k transactions. Apparently we have base cases: T[-1][k] = T[i][0] = 0 , that is, no stock or no transaction yield no profit (note the first day has i = 0 so i = -1 means no stock). Now if we can somehow relate T[i][k] to its subproblems like T[i-1][k] , T[i][k-1] , T[i-1][k-1] , ..., we will have a working recurrence relation and the problem can be solved recursively. So how do we achieve that? The most straightforward way would be looking at actions taken on the i-th day. How many options do we have? The answer is three: buy , sell , rest . Which one should we take? The answer is: we don't really know, but to find out which one is easy. We can try each option and then choose the one that maximizes our profit, provided there are no other restrictions. However, we do have an extra restriction saying no multiple transactions are allowed at the same time, meaning if we decide to buy on the i-th day, there should be 0 stock held in our hand before we buy; if we decide to sell on the i-th day, there should be exactly 1 stock held in our hand before we sell. The number of stocks held in our hand is the hidden factor mentioned above that will affect the action on the i-th day and thus affect the maximum profit. Therefore our definition of T[i][k] should really be split into two: T[i][k][0] and T[i][k][1] , where the former denotes the maximum profit at the end of the i-th day with at most k transactions and with 0 stock in our hand AFTER taking the action , while the latter denotes the maximum profit at the end of the i-th day with at most k transactions and with 1 stock in our hand AFTER taking the action. Now the base cases and the recurrence relations can be written as: Base cases: T[-1][k][0] = 0, T[-1][k][1] = -Infinity T[i][0][0] = 0, T[i][0][1] = -Infinity Recurrence relations: T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i]) For the base cases, T[-1][k][0] = T[i][0][0] = 0 has the same meaning as before while T[-1][k][1] = T[i][0][1] = -Infinity emphasizes the fact that it is impossible for us to have 1 stock in hand if there is no stock available or no transactions are allowed. For T[i][k][0] in the recurrence relations, the actions taken on the i-th day can only be rest and sell , since we have 0 stock in our hand at the end of the day. T[i-1][k][0] is the maximum profit if action rest is taken, while T[i-1][k][1] + prices[i] is the maximum profit if action sell is taken. Note that the maximum number of allowable transactions remains the same , due to the fact that a transaction consists of two actions coming as a pair -- buy and sell . Only action buy will change the maximum number of transactions allowed (well, there is actually an alternative interpretation, see my comment below). For T[i][k][1] in the recurrence relations, the actions taken on the i-th day can only be rest and buy, since we have 1 stock in our hand at the end of the day. T[i-1][k][1] is the maximum profit if action rest is taken, while T[i-1][k-1][0] - prices[i] is the maximum profit if action buy is taken. Note that the maximum number of allowable transactions decreases by one , since buying on the i-th day will use one transaction, as explained above. To find the maximum profit at the end of the last day, we can simply loop through the prices array and update T[i][k][0] and T[i][k][1] according to the recurrence relations above. The final answer will be T[i][k][0] (we always have larger profit if we end up with 0 stock in hand). II -- Applications to specific cases The aforementioned six stock problems are classified by the value of k , which is the maximum number of allowable transactions (the last two also have additional requirements such as \"cooldown\" or \"transaction fee\"). I will apply the general solution to each of them one by one. Case I: k = 1 For this case, we really have two unknown variables on each day: T[i][1][0] and T[i][1][1] , and the recurrence relations say: T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i]) T[i][1][1] = max(T[i-1][1][1], T[i-1][0][0] - prices[i]) = max(T[i-1][1][1], -prices[i]) where we have taken advantage of the base case T[i][0][0] = 0 for the second equation. It is straightforward to write the O(n) time and O(n) space solution, based on the two equations above. However, if you notice that the maximum profits on the i-th day actually only depend on those on the (i-1)-th day, the space can be cut down to O(1). Here is the space-optimized solution: 1 2 3 4 5 6 7 8 9 10 public int maxProfit ( int [] prices ) { int T_i10 = 0 , T_i11 = Integer . MIN_VALUE ; for ( int price : prices ) { T_i10 = Math . max ( T_i10 , T_i11 + price ); T_i11 = Math . max ( T_i11 , - price ); } return T_i10 ; } Now let's try to gain some insight of the solution above. If we examine the part inside the loop more carefully, T_i11 really just represents the maximum value of the negative of all stock prices up to the i-th day, or equivalently the minimum value of all the stock prices. As for T_i10 , we just need to decide which action yields a higher profit, sell or rest. And if action sell is taken, the price at which we bought the stock is T_i11 , i.e., the minimum value before the i-th day. This is exactly what we would do in reality if we want to gain maximum profit. I should point out that this is not the only way of solving the problem for this case. You may find some other nice solutions here . Case II: k = +Infinity If k is positive infinity, then there isn't really any difference between k and k - 1 (wonder why? see my comment below), which implies T[i-1][k-1][0] = T[i-1][k][0] and T[i-1][k-1][1] = T[i-1][k][1] . Therefore, we still have two unknown variables on each day: T[i][k][0] and T[i][k][1] with k = +Infinity , and the recurrence relations say: T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i]) = max(T[i-1][k][1], T[i-1][k][0] - prices[i]) where we have taken advantage of the fact that T[i-1][k-1][0] = T[i-1][k][0] for the second equation. The O(n) time and O(1) space solution is as follows: 1 2 3 4 5 6 7 8 9 10 11 public int maxProfit ( int [] prices ) { int T_ik0 = 0 , T_ik1 = Integer . MIN_VALUE ; for ( int price : prices ) { int T_ik0_old = T_ik0 ; T_ik0 = Math . max ( T_ik0 , T_ik1 + price ); T_ik1 = Math . max ( T_ik1 , T_ik0_old - price ); } return T_ik0 ; } (Note: The caching of the old values of T_ik0 , that is, the variable T_ik0_old , is unnecessary. Special thanks to 0x0101 and elvina for clarifying this.) This solution suggests a greedy strategy of gaining maximum profit: as long as possible, buy stock at each local minimum and sell at the immediately followed local maximum. This is equivalent to finding increasing subarrays in prices (the stock price array), and buying at the beginning price of each subarray while selling at its end price. It's easy to show that this is the same as accumulating profits as long as it is profitable to do so, as demonstrated in this post. Case III: k = 2 Similar to the case where k = 1 , except now we have four variables instead of two on each day: T[i][1][0] , T[i][1][1] , T[i][2][0] , T[i][2][1] , and the recurrence relations are: T[i][2][0] = max(T[i-1][2][0], T[i-1][2][1] + prices[i]) T[i][2][1] = max(T[i-1][2][1], T[i-1][1][0] - prices[i]) T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i]) T[i][1][1] = max(T[i-1][1][1], -prices[i]) where again we have taken advantage of the base case T[i][0][0] = 0 for the last equation. The O(n) time and O(1) space solution is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 public int maxProfit ( int [] prices ) { int T_i10 = 0 , T_i11 = Integer . MIN_VALUE ; int T_i20 = 0 , T_i21 = Integer . MIN_VALUE ; for ( int price : prices ) { T_i20 = Math . max ( T_i20 , T_i21 + price ); T_i21 = Math . max ( T_i21 , T_i10 - price ); T_i10 = Math . max ( T_i10 , T_i11 + price ); T_i11 = Math . max ( T_i11 , - price ); } return T_i20 ; } which is essentially the same as the one given here . Case IV: k is arbitrary This is the most general case so on each day we need to update all the maximum profits with different k values corresponding to 0 or 1 stocks in hand at the end of the day. However, there is a minor optimization we can do if k exceeds some critical value , beyond which the maximum profit will no long depend on the number of allowable transactions but instead will be bound by the number of available stocks (length of the prices array). Let's figure out what this critical value will be. A profitable transaction takes at least two days (buy at one day and sell at the other, provided the buying price is less than the selling price). If the length of the prices array is n , the maximum number of profitable transactions is n/2 (integer division). After that no profitable transaction is possible, which implies the maximum profit will stay the same. Therefore the critical value of k is n/2 . If the given k is no less than this value, i.e., k >= n/2 , we can extend k to positive infinity and the problem is equivalent to Case II . The following is the O(kn) time and O(k) space solution. Without the optimization, the code will be met with TLE for large k values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public int maxProfit ( int k , int [] prices ) { if ( k >= prices . length >>> 1 ) { int T_ik0 = 0 , T_ik1 = Integer . MIN_VALUE ; for ( int price : prices ) { int T_ik0_old = T_ik0 ; T_ik0 = Math . max ( T_ik0 , T_ik1 + price ); T_ik1 = Math . max ( T_ik1 , T_ik0_old - price ); } return T_ik0 ; } int [] T_ik0 = new int [ k + 1 ] ; int [] T_ik1 = new int [ k + 1 ] ; Arrays . fill ( T_ik1 , Integer . MIN_VALUE ); for ( int price : prices ) { for ( int j = k ; j > 0 ; j -- ) { T_ik0 [ j ] = Math . max ( T_ik0 [ j ] , T_ik1 [ j ] + price ); T_ik1 [ j ] = Math . max ( T_ik1 [ j ] , T_ik0 [ j - 1 ] - price ); } } return T_ik0 [ k ] ; } The solution is similar to the one found in this post. Here I used backward looping for the T array to avoid using temporary variables. It turns out that it is possible to do forward looping without temporary variables, too. Case V: k = +Infinity but with cooldown This case resembles Case II very much due to the fact that they have the same k value, except now the recurrence relations have to be modified slightly to account for the \"cooldown\" requirement. The original recurrence relations for Case II are given by T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i]) But with \"cooldown\", we cannot buy on the i-th day if a stock is sold on the (i-1)-th day . Therefore, in the second equation above, instead of T[i-1][k][0] , we should actually use T[i-2][k][0] if we intend to buy on the i-th day. Everything else remains the same and the new recurrence relations are T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i]) And here is the O(n) time and O(1) space solution: 1 2 3 4 5 6 7 8 9 10 11 12 public int maxProfit ( int [] prices ) { int T_ik0_pre = 0 , T_ik0 = 0 , T_ik1 = Integer . MIN_VALUE ; for ( int price : prices ) { int T_ik0_old = T_ik0 ; T_ik0 = Math . max ( T_ik0 , T_ik1 + price ); T_ik1 = Math . max ( T_ik1 , T_ik0_pre - price ); T_ik0_pre = T_ik0_old ; } return T_ik0 ; } dietpepsi shared a very nice solution here with thinking process, which turns out to be the same as the one above. Case VI: k = +Infinity but with transaction fee Again this case resembles Case II very much as they have the same k value, except now the recurrence relations need to be modified slightly to account for the \"transaction fee\" requirement. The original recurrence relations for Case II are given by T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i]) Since now we need to pay some fee (denoted as fee) for each transaction made, the profit after buying or selling the stock on the i-th day should be subtracted by this amount, therefore the new recurrence relations will be either T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i] - fee) or T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i] - fee) T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i]) Note we have two options as for when to subtract the fee. This is because (as I mentioned above) each transaction is characterized by two actions coming as a pair - - buy and sell. The fee can be paid either when we buy the stock (corresponds to the first set of equations) or when we sell it (corresponds to the second set of equations). The following are the O(n) time and O(1) space solutions corresponding to these two options, where for the second solution we need to pay attention to possible overflows. Solution I -- pay the fee when buying the stock: 1 2 3 4 5 6 7 8 9 10 11 public int maxProfit ( int [] prices , int fee ) { int T_ik0 = 0 , T_ik1 = Integer . MIN_VALUE ; for ( int price : prices ) { int T_ik0_old = T_ik0 ; T_ik0 = Math . max ( T_ik0 , T_ik1 + price ); T_ik1 = Math . max ( T_ik1 , T_ik0_old - price - fee ); } return T_ik0 ; } Solution II -- pay the fee when selling the stock: 1 2 3 4 5 6 7 8 9 10 11 public int maxProfit ( int [] prices , int fee ) { long T_ik0 = 0 , T_ik1 = Integer . MIN_VALUE ; for ( int price : prices ) { long T_ik0_old = T_ik0 ; T_ik0 = Math . max ( T_ik0 , T_ik1 + price - fee ); T_ik1 = Math . max ( T_ik1 , T_ik0_old - price ); } return ( int ) T_ik0 ; } III -- Summary In summary, the most general case of the stock problem can be characterized by three factors, the ordinal of the day i , the maximum number of allowable transactions k , and the number of stocks in our hand at the end of the day. I have shown the recurrence relations for the maximum profits and their termination conditions, which leads to the O(nk) time and O(k) space solution. The results are then applied to each of the six cases, with the last two using slightly modified recurrence relations due to the additional requirements. I should mention that peterleetcode also introduced a nice solution here which generalizes to arbitrary k values. If you have a taste, take a look. Hope this helps and happy coding! Comments T_ik0_old , is unnecessary, why? (Note: The caching of the old values of T_ik0, that is, the variable T_ik0_old, is unnecessary. Special thanks to 0x0101 and elvina for clarifying this.) why the old is unnecessary? I dont get it TAT we can look at these 3 equations. \u2460T[i][0] = max(T[i-1][0], T[i-1][1] + prices[i]) \u2461T[i][1] = max(T[i-1][1], T[i-1][0] - prices[i]) \u2462T[i][1] = max(T[i-1][1], T[i][0] - prices[i]) condition 1:If T[i-1][0] >= T[i-1][1] + prices[i],we can get T[i][0] = T[i-1][0] in \u2460, then \u2462 is the same with \u2461. condition 2:If T[i-1][0] < T[i-1][1] + prices[i], then T[i][0] = T[i-1][1] + prices[i] in \u2460, we replace T[i][0] with T[i-1][1] + prices[i] in \u2462, then we get T[i][1] = T[i-1][1]. As T[i-1][1] > T[i-1][0] - prices[i] ,so we can get T[i][1] = T[i-1][1] from \u2461. the result of \u2461 and \u2462 is the same. From condition 1 and 2, we can find that \u2461 is the same with \u2462. we don't need to cache the old values(T[i-1][0]). Confused about the case when k = Infinity I am confused about the case when k = Infinity. In your paper, there comes: \"If k is positive infinity, then there is not really any difference between k and k - 1\", Why? Really confused about it. elvina : I personally don't quite get the idea of infinity since for practical cases, k must be finite. The way I think about it is that when you can make as many transactions as you want, k is no longer a constraint here, therefore you can just take [k] and [k-1] out of the equation and let it be constrained by the size of the prices array. In this case, the maximum number of transactions you can make is determined by the size of the prices array just like what was described in Case IV. Given a prices array, assume the maximum number of complete transactions you can make is M. Then for the part of the price array before the last transaction, you can only make as many as M-1 transactions. Therefore, writing [k] instead of [k-1] or any number larger than k won't make a difference since you cannot achieve more than [k-1] complete transaction anyway if you don't include the last transaction. Hope this helps. fun4LeetCode (author): Sorry for the confusion. So there are two interpretations here. First from a mathematical point of view, limit(k) is the same as limit(k-1) when k approaches +infinity. Second, more relevant to this problem, as I said for the case of arbitrary k, when k is sufficiently large, the maximum profits will on longer depend on k but be bound by the number of available stocks. This means if k goes to +infinity, the profits won't change if you increase or decrease the value of k, that is, T[i][k][0] will be the same as T[i][k-1][0] and T[i][k][1] the same as T[i][k-1][1]. Hope this clarifies things a little bit. \u6211\u7684\u8865\u5145 \u4e0d\u53ef\u907f\u514d\u7684\u4f7f\u7528INT_MIN\uff0cgolang: 1 2 const INT_MAX = int(^uint(0) >> 1); const INT_MIN = ^INT_MAX; \u81ea\u5df1\u521d\u59cb\u5316 i=-1 \u65f6 T[i][k][0 or 1] \u6570\u7ec4\u7684\u503c\uff0c\u8fd9\u6837\u4e0d\u7528\u80cc\u521d\u59cb\u5316\u516c\u5f0f\uff0c\u53ea\u9700\u8981\u7406\u89e3T\u6570\u7ec4\u7684\u542b\u4e49\u5373\u53ef \u5199\u591a\u4e86\uff0c\u5c31\u77e5\u9053\u600e\u4e48\u628a\u6570\u7ec4\u6362\u6210\u53d8\u91cf\u4e86\uff0c\u4f46\u662f\u90a3\u662f \u6280 \uff0c\u6570\u7ec4\u7684\u9012\u5f52\u8868\u793a\u624d\u662f \u9053 \u3002 \u539f\u6587\u4e2d T_ik0_old \u662f\u591a\u4f59\u7684\u8bba\u8ff0\u5728 Comments \u4e2d\u6709\u56de\u7b54\uff0c\u81ea\u5df1\u7eb8\u4e0a\u8ba1\u7b97\u4e00\u4e0b\u5c31\u80fd\u7406\u89e3","title":"Buy Sell Stock"},{"location":"notes/buy-sell-stock/#best-time-to-buy-and-sell-stock-dp","text":"","title":"Best Time to Buy and Sell Stock \u7cfb\u5217DP\u95ee\u9898"},{"location":"notes/buy-sell-stock/#2019-01","text":"\u53c2\u8003\u81ea LeetCode dicsuss \uff0c\u8fd9\u91cc\u505a\u4e00\u4e2a\u5907\u4efd\u548c\u81ea\u5df1\u6807\u6ce8\u7684\u7406\u89e3\uff0c\u539f\u6587\u5982\u4e0b\uff1a","title":"2019-01 \u6574\u7406"},{"location":"notes/buy-sell-stock/#most-consistent-ways-of-dealing-with-the-series-of-stock-problems","text":"Note: this is a repost of my original post here with updated solutions for this problem 714. Best Time to Buy and Sell Stock with Transaction Fee . If you are only looking for solutions, you can go directly to each section in part II -- Applications to specific cases . Up to this point, I believe you have finished the following series of stock problems: 121. Best Time to Buy and Sell Stock 122. Best Time to Buy and Sell Stock II 123. Best Time to Buy and Sell Stock III 188. Best Time to Buy and Sell Stock IV 309. Best Time to Buy and Sell Stock with Cooldown 714. Best Time to Buy and Sell Stock with Transaction Fee For each problem, we've got a couple of excellent posts explaining how to approach it. However, most of the posts failed to identify the connections among these problems and made it hard to develop a consistent way of dealing with this series of problems. Here I will introduce the most generalized solution applicable to all of these problems, and its specialization to each of the six problems above.","title":"Most consistent ways of dealing with the series of stock problems"},{"location":"notes/buy-sell-stock/#i-general-cases","text":"The idea begins with the following question: Given an array representing the price of stocks on each day, what determines the maximum profit we can obtain? Most of you can quickly come up with answers like \"it depends on which day we are and how many transactions we are allowed to complete\". Sure, those are important factors as they manifest themselves in the problem descriptions. However, there is a hidden factor that is not so obvious but vital in determining the maximum profit, which is elaborated below. First let's spell out the notations to streamline our analyses. Let prices be the stock price array with length n , i denote the i-th day ( i will go from 0 to n-1), k denote the maximum number of transactions allowed to complete, T[i][k] be the maximum profit that could be gained at the end of the i-th day with at most k transactions. Apparently we have base cases: T[-1][k] = T[i][0] = 0 , that is, no stock or no transaction yield no profit (note the first day has i = 0 so i = -1 means no stock). Now if we can somehow relate T[i][k] to its subproblems like T[i-1][k] , T[i][k-1] , T[i-1][k-1] , ..., we will have a working recurrence relation and the problem can be solved recursively. So how do we achieve that? The most straightforward way would be looking at actions taken on the i-th day. How many options do we have? The answer is three: buy , sell , rest . Which one should we take? The answer is: we don't really know, but to find out which one is easy. We can try each option and then choose the one that maximizes our profit, provided there are no other restrictions. However, we do have an extra restriction saying no multiple transactions are allowed at the same time, meaning if we decide to buy on the i-th day, there should be 0 stock held in our hand before we buy; if we decide to sell on the i-th day, there should be exactly 1 stock held in our hand before we sell. The number of stocks held in our hand is the hidden factor mentioned above that will affect the action on the i-th day and thus affect the maximum profit. Therefore our definition of T[i][k] should really be split into two: T[i][k][0] and T[i][k][1] , where the former denotes the maximum profit at the end of the i-th day with at most k transactions and with 0 stock in our hand AFTER taking the action , while the latter denotes the maximum profit at the end of the i-th day with at most k transactions and with 1 stock in our hand AFTER taking the action. Now the base cases and the recurrence relations can be written as: Base cases: T[-1][k][0] = 0, T[-1][k][1] = -Infinity T[i][0][0] = 0, T[i][0][1] = -Infinity Recurrence relations: T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i]) For the base cases, T[-1][k][0] = T[i][0][0] = 0 has the same meaning as before while T[-1][k][1] = T[i][0][1] = -Infinity emphasizes the fact that it is impossible for us to have 1 stock in hand if there is no stock available or no transactions are allowed. For T[i][k][0] in the recurrence relations, the actions taken on the i-th day can only be rest and sell , since we have 0 stock in our hand at the end of the day. T[i-1][k][0] is the maximum profit if action rest is taken, while T[i-1][k][1] + prices[i] is the maximum profit if action sell is taken. Note that the maximum number of allowable transactions remains the same , due to the fact that a transaction consists of two actions coming as a pair -- buy and sell . Only action buy will change the maximum number of transactions allowed (well, there is actually an alternative interpretation, see my comment below). For T[i][k][1] in the recurrence relations, the actions taken on the i-th day can only be rest and buy, since we have 1 stock in our hand at the end of the day. T[i-1][k][1] is the maximum profit if action rest is taken, while T[i-1][k-1][0] - prices[i] is the maximum profit if action buy is taken. Note that the maximum number of allowable transactions decreases by one , since buying on the i-th day will use one transaction, as explained above. To find the maximum profit at the end of the last day, we can simply loop through the prices array and update T[i][k][0] and T[i][k][1] according to the recurrence relations above. The final answer will be T[i][k][0] (we always have larger profit if we end up with 0 stock in hand).","title":"I -- General cases"},{"location":"notes/buy-sell-stock/#ii-applications-to-specific-cases","text":"The aforementioned six stock problems are classified by the value of k , which is the maximum number of allowable transactions (the last two also have additional requirements such as \"cooldown\" or \"transaction fee\"). I will apply the general solution to each of them one by one.","title":"II -- Applications to specific cases"},{"location":"notes/buy-sell-stock/#case-i-k-1","text":"For this case, we really have two unknown variables on each day: T[i][1][0] and T[i][1][1] , and the recurrence relations say: T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i]) T[i][1][1] = max(T[i-1][1][1], T[i-1][0][0] - prices[i]) = max(T[i-1][1][1], -prices[i]) where we have taken advantage of the base case T[i][0][0] = 0 for the second equation. It is straightforward to write the O(n) time and O(n) space solution, based on the two equations above. However, if you notice that the maximum profits on the i-th day actually only depend on those on the (i-1)-th day, the space can be cut down to O(1). Here is the space-optimized solution: 1 2 3 4 5 6 7 8 9 10 public int maxProfit ( int [] prices ) { int T_i10 = 0 , T_i11 = Integer . MIN_VALUE ; for ( int price : prices ) { T_i10 = Math . max ( T_i10 , T_i11 + price ); T_i11 = Math . max ( T_i11 , - price ); } return T_i10 ; } Now let's try to gain some insight of the solution above. If we examine the part inside the loop more carefully, T_i11 really just represents the maximum value of the negative of all stock prices up to the i-th day, or equivalently the minimum value of all the stock prices. As for T_i10 , we just need to decide which action yields a higher profit, sell or rest. And if action sell is taken, the price at which we bought the stock is T_i11 , i.e., the minimum value before the i-th day. This is exactly what we would do in reality if we want to gain maximum profit. I should point out that this is not the only way of solving the problem for this case. You may find some other nice solutions here .","title":"Case I: k = 1"},{"location":"notes/buy-sell-stock/#case-ii-k-infinity","text":"If k is positive infinity, then there isn't really any difference between k and k - 1 (wonder why? see my comment below), which implies T[i-1][k-1][0] = T[i-1][k][0] and T[i-1][k-1][1] = T[i-1][k][1] . Therefore, we still have two unknown variables on each day: T[i][k][0] and T[i][k][1] with k = +Infinity , and the recurrence relations say: T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) T[i][k][1] = max(T[i-1][k][1], T[i-1][k-1][0] - prices[i]) = max(T[i-1][k][1], T[i-1][k][0] - prices[i]) where we have taken advantage of the fact that T[i-1][k-1][0] = T[i-1][k][0] for the second equation. The O(n) time and O(1) space solution is as follows: 1 2 3 4 5 6 7 8 9 10 11 public int maxProfit ( int [] prices ) { int T_ik0 = 0 , T_ik1 = Integer . MIN_VALUE ; for ( int price : prices ) { int T_ik0_old = T_ik0 ; T_ik0 = Math . max ( T_ik0 , T_ik1 + price ); T_ik1 = Math . max ( T_ik1 , T_ik0_old - price ); } return T_ik0 ; } (Note: The caching of the old values of T_ik0 , that is, the variable T_ik0_old , is unnecessary. Special thanks to 0x0101 and elvina for clarifying this.) This solution suggests a greedy strategy of gaining maximum profit: as long as possible, buy stock at each local minimum and sell at the immediately followed local maximum. This is equivalent to finding increasing subarrays in prices (the stock price array), and buying at the beginning price of each subarray while selling at its end price. It's easy to show that this is the same as accumulating profits as long as it is profitable to do so, as demonstrated in this post.","title":"Case II: k = +Infinity"},{"location":"notes/buy-sell-stock/#case-iii-k-2","text":"Similar to the case where k = 1 , except now we have four variables instead of two on each day: T[i][1][0] , T[i][1][1] , T[i][2][0] , T[i][2][1] , and the recurrence relations are: T[i][2][0] = max(T[i-1][2][0], T[i-1][2][1] + prices[i]) T[i][2][1] = max(T[i-1][2][1], T[i-1][1][0] - prices[i]) T[i][1][0] = max(T[i-1][1][0], T[i-1][1][1] + prices[i]) T[i][1][1] = max(T[i-1][1][1], -prices[i]) where again we have taken advantage of the base case T[i][0][0] = 0 for the last equation. The O(n) time and O(1) space solution is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 public int maxProfit ( int [] prices ) { int T_i10 = 0 , T_i11 = Integer . MIN_VALUE ; int T_i20 = 0 , T_i21 = Integer . MIN_VALUE ; for ( int price : prices ) { T_i20 = Math . max ( T_i20 , T_i21 + price ); T_i21 = Math . max ( T_i21 , T_i10 - price ); T_i10 = Math . max ( T_i10 , T_i11 + price ); T_i11 = Math . max ( T_i11 , - price ); } return T_i20 ; } which is essentially the same as the one given here .","title":"Case III: k = 2"},{"location":"notes/buy-sell-stock/#case-iv-k-is-arbitrary","text":"This is the most general case so on each day we need to update all the maximum profits with different k values corresponding to 0 or 1 stocks in hand at the end of the day. However, there is a minor optimization we can do if k exceeds some critical value , beyond which the maximum profit will no long depend on the number of allowable transactions but instead will be bound by the number of available stocks (length of the prices array). Let's figure out what this critical value will be. A profitable transaction takes at least two days (buy at one day and sell at the other, provided the buying price is less than the selling price). If the length of the prices array is n , the maximum number of profitable transactions is n/2 (integer division). After that no profitable transaction is possible, which implies the maximum profit will stay the same. Therefore the critical value of k is n/2 . If the given k is no less than this value, i.e., k >= n/2 , we can extend k to positive infinity and the problem is equivalent to Case II . The following is the O(kn) time and O(k) space solution. Without the optimization, the code will be met with TLE for large k values. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public int maxProfit ( int k , int [] prices ) { if ( k >= prices . length >>> 1 ) { int T_ik0 = 0 , T_ik1 = Integer . MIN_VALUE ; for ( int price : prices ) { int T_ik0_old = T_ik0 ; T_ik0 = Math . max ( T_ik0 , T_ik1 + price ); T_ik1 = Math . max ( T_ik1 , T_ik0_old - price ); } return T_ik0 ; } int [] T_ik0 = new int [ k + 1 ] ; int [] T_ik1 = new int [ k + 1 ] ; Arrays . fill ( T_ik1 , Integer . MIN_VALUE ); for ( int price : prices ) { for ( int j = k ; j > 0 ; j -- ) { T_ik0 [ j ] = Math . max ( T_ik0 [ j ] , T_ik1 [ j ] + price ); T_ik1 [ j ] = Math . max ( T_ik1 [ j ] , T_ik0 [ j - 1 ] - price ); } } return T_ik0 [ k ] ; } The solution is similar to the one found in this post. Here I used backward looping for the T array to avoid using temporary variables. It turns out that it is possible to do forward looping without temporary variables, too.","title":"Case IV: k is arbitrary"},{"location":"notes/buy-sell-stock/#case-v-k-infinity-but-with-cooldown","text":"This case resembles Case II very much due to the fact that they have the same k value, except now the recurrence relations have to be modified slightly to account for the \"cooldown\" requirement. The original recurrence relations for Case II are given by T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i]) But with \"cooldown\", we cannot buy on the i-th day if a stock is sold on the (i-1)-th day . Therefore, in the second equation above, instead of T[i-1][k][0] , we should actually use T[i-2][k][0] if we intend to buy on the i-th day. Everything else remains the same and the new recurrence relations are T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) T[i][k][1] = max(T[i-1][k][1], T[i-2][k][0] - prices[i]) And here is the O(n) time and O(1) space solution: 1 2 3 4 5 6 7 8 9 10 11 12 public int maxProfit ( int [] prices ) { int T_ik0_pre = 0 , T_ik0 = 0 , T_ik1 = Integer . MIN_VALUE ; for ( int price : prices ) { int T_ik0_old = T_ik0 ; T_ik0 = Math . max ( T_ik0 , T_ik1 + price ); T_ik1 = Math . max ( T_ik1 , T_ik0_pre - price ); T_ik0_pre = T_ik0_old ; } return T_ik0 ; } dietpepsi shared a very nice solution here with thinking process, which turns out to be the same as the one above.","title":"Case V: k = +Infinity but with cooldown"},{"location":"notes/buy-sell-stock/#case-vi-k-infinity-but-with-transaction-fee","text":"Again this case resembles Case II very much as they have the same k value, except now the recurrence relations need to be modified slightly to account for the \"transaction fee\" requirement. The original recurrence relations for Case II are given by T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i]) Since now we need to pay some fee (denoted as fee) for each transaction made, the profit after buying or selling the stock on the i-th day should be subtracted by this amount, therefore the new recurrence relations will be either T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i]) T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i] - fee) or T[i][k][0] = max(T[i-1][k][0], T[i-1][k][1] + prices[i] - fee) T[i][k][1] = max(T[i-1][k][1], T[i-1][k][0] - prices[i]) Note we have two options as for when to subtract the fee. This is because (as I mentioned above) each transaction is characterized by two actions coming as a pair - - buy and sell. The fee can be paid either when we buy the stock (corresponds to the first set of equations) or when we sell it (corresponds to the second set of equations). The following are the O(n) time and O(1) space solutions corresponding to these two options, where for the second solution we need to pay attention to possible overflows. Solution I -- pay the fee when buying the stock: 1 2 3 4 5 6 7 8 9 10 11 public int maxProfit ( int [] prices , int fee ) { int T_ik0 = 0 , T_ik1 = Integer . MIN_VALUE ; for ( int price : prices ) { int T_ik0_old = T_ik0 ; T_ik0 = Math . max ( T_ik0 , T_ik1 + price ); T_ik1 = Math . max ( T_ik1 , T_ik0_old - price - fee ); } return T_ik0 ; } Solution II -- pay the fee when selling the stock: 1 2 3 4 5 6 7 8 9 10 11 public int maxProfit ( int [] prices , int fee ) { long T_ik0 = 0 , T_ik1 = Integer . MIN_VALUE ; for ( int price : prices ) { long T_ik0_old = T_ik0 ; T_ik0 = Math . max ( T_ik0 , T_ik1 + price - fee ); T_ik1 = Math . max ( T_ik1 , T_ik0_old - price ); } return ( int ) T_ik0 ; }","title":"Case VI: k = +Infinity but with transaction fee"},{"location":"notes/buy-sell-stock/#iii-summary","text":"In summary, the most general case of the stock problem can be characterized by three factors, the ordinal of the day i , the maximum number of allowable transactions k , and the number of stocks in our hand at the end of the day. I have shown the recurrence relations for the maximum profits and their termination conditions, which leads to the O(nk) time and O(k) space solution. The results are then applied to each of the six cases, with the last two using slightly modified recurrence relations due to the additional requirements. I should mention that peterleetcode also introduced a nice solution here which generalizes to arbitrary k values. If you have a taste, take a look. Hope this helps and happy coding!","title":"III -- Summary"},{"location":"notes/buy-sell-stock/#comments","text":"","title":"Comments"},{"location":"notes/buy-sell-stock/#t_ik0_old-is-unnecessary-why","text":"(Note: The caching of the old values of T_ik0, that is, the variable T_ik0_old, is unnecessary. Special thanks to 0x0101 and elvina for clarifying this.) why the old is unnecessary? I dont get it TAT we can look at these 3 equations. \u2460T[i][0] = max(T[i-1][0], T[i-1][1] + prices[i]) \u2461T[i][1] = max(T[i-1][1], T[i-1][0] - prices[i]) \u2462T[i][1] = max(T[i-1][1], T[i][0] - prices[i]) condition 1:If T[i-1][0] >= T[i-1][1] + prices[i],we can get T[i][0] = T[i-1][0] in \u2460, then \u2462 is the same with \u2461. condition 2:If T[i-1][0] < T[i-1][1] + prices[i], then T[i][0] = T[i-1][1] + prices[i] in \u2460, we replace T[i][0] with T[i-1][1] + prices[i] in \u2462, then we get T[i][1] = T[i-1][1]. As T[i-1][1] > T[i-1][0] - prices[i] ,so we can get T[i][1] = T[i-1][1] from \u2461. the result of \u2461 and \u2462 is the same. From condition 1 and 2, we can find that \u2461 is the same with \u2462. we don't need to cache the old values(T[i-1][0]).","title":"T_ik0_old, is unnecessary, why?"},{"location":"notes/buy-sell-stock/#confused-about-the-case-when-k-infinity","text":"I am confused about the case when k = Infinity. In your paper, there comes: \"If k is positive infinity, then there is not really any difference between k and k - 1\", Why? Really confused about it. elvina : I personally don't quite get the idea of infinity since for practical cases, k must be finite. The way I think about it is that when you can make as many transactions as you want, k is no longer a constraint here, therefore you can just take [k] and [k-1] out of the equation and let it be constrained by the size of the prices array. In this case, the maximum number of transactions you can make is determined by the size of the prices array just like what was described in Case IV. Given a prices array, assume the maximum number of complete transactions you can make is M. Then for the part of the price array before the last transaction, you can only make as many as M-1 transactions. Therefore, writing [k] instead of [k-1] or any number larger than k won't make a difference since you cannot achieve more than [k-1] complete transaction anyway if you don't include the last transaction. Hope this helps. fun4LeetCode (author): Sorry for the confusion. So there are two interpretations here. First from a mathematical point of view, limit(k) is the same as limit(k-1) when k approaches +infinity. Second, more relevant to this problem, as I said for the case of arbitrary k, when k is sufficiently large, the maximum profits will on longer depend on k but be bound by the number of available stocks. This means if k goes to +infinity, the profits won't change if you increase or decrease the value of k, that is, T[i][k][0] will be the same as T[i][k-1][0] and T[i][k][1] the same as T[i][k-1][1]. Hope this clarifies things a little bit.","title":"Confused about the case when k = Infinity"},{"location":"notes/buy-sell-stock/#_1","text":"\u4e0d\u53ef\u907f\u514d\u7684\u4f7f\u7528INT_MIN\uff0cgolang: 1 2 const INT_MAX = int(^uint(0) >> 1); const INT_MIN = ^INT_MAX; \u81ea\u5df1\u521d\u59cb\u5316 i=-1 \u65f6 T[i][k][0 or 1] \u6570\u7ec4\u7684\u503c\uff0c\u8fd9\u6837\u4e0d\u7528\u80cc\u521d\u59cb\u5316\u516c\u5f0f\uff0c\u53ea\u9700\u8981\u7406\u89e3T\u6570\u7ec4\u7684\u542b\u4e49\u5373\u53ef \u5199\u591a\u4e86\uff0c\u5c31\u77e5\u9053\u600e\u4e48\u628a\u6570\u7ec4\u6362\u6210\u53d8\u91cf\u4e86\uff0c\u4f46\u662f\u90a3\u662f \u6280 \uff0c\u6570\u7ec4\u7684\u9012\u5f52\u8868\u793a\u624d\u662f \u9053 \u3002 \u539f\u6587\u4e2d T_ik0_old \u662f\u591a\u4f59\u7684\u8bba\u8ff0\u5728 Comments \u4e2d\u6709\u56de\u7b54\uff0c\u81ea\u5df1\u7eb8\u4e0a\u8ba1\u7b97\u4e00\u4e0b\u5c31\u80fd\u7406\u89e3","title":"\u6211\u7684\u8865\u5145"},{"location":"notes/dp/","text":"Dynamic Programming \u52a8\u6001\u89c4\u5212 2019-01 \u6574\u7406 1. \u52a8\u6001\u89c4\u5212\u7684\u7406\u89e3 \u52a8\u6001\u89c4\u5212\uff0c\u548c\u5206\u6cbb\u6cd5(divide-and-conquer)\u4e00\u6837\uff0c\u90fd\u662f\u5c06\u5927\u95ee\u9898\u62c6\u5206\u6210\u5c0f\u95ee\u9898\uff0c\u901a\u8fc7\u8ba1\u7b97\u66f4\u5bb9\u6613\u5f97\u5230\u7684\u5c0f\u95ee\u9898\u7684\u89e3\uff0c\u518d\u6c47\u96c6\u6210\u5927\u95ee\u9898\u7684\u89e3\u3002 \u5206\u6cbb\u6cd5\u662f\u628a\u95ee\u9898\u62c6\u5206\u6210 \u76f8\u4e92\u72ec\u7acb \u7684\u5b50\u95ee\u9898\uff0c\u9002\u7528\u4e8e\u62c6\u5206\u7684\u5b50\u95ee\u9898\u662f\u4e92\u4e0d\u5f71\u54cd\u7684\u3002\u76f8\u53cd\uff0c\u52a8\u6001\u89c4\u5212\u9002\u7528\u4e8e\u5b50\u95ee\u9898\u662f \u76f8\u4e92\u91cd\u53e0 \u7684\uff0c\u5373\u5b58\u5728\u4e24\u4e2a\u5b50\u95ee\u9898\u53ef\u80fd\u90fd\u5305\u542b\u540c\u4e00\u4e2a\u5b50\u5b50\u95ee\u9898\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4ecd\u7528\u5206\u6cbb\u6cd5\uff0c\u5728\u9012\u5f52\u4e2d\u5bb9\u6613\u53cd\u590d\u8ba1\u7b97\u67d0\u4e00\u4e2a\u5b50\u95ee\u9898\uff0c\u9020\u6210\u4e0d\u5fc5\u8981\u7684\u6d6a\u8d39\u3002 \u6240\u4ee5\uff0c\u52a8\u6001\u89c4\u5212\u53ea\u6c42\u89e3\u5b50\u95ee\u9898\u4e00\u6b21\uff0c\u7136\u540e\u628a\u5f97\u5230\u7684\u7ed3\u679c\u4fdd\u5b58\u5230\u8868\u683c\u4e2d\uff0c\u4ece\u800c\u907f\u514d\u53cd\u590d\u6c42\u89e3\u540c\u4e00\u4e2a\u5b50\u95ee\u9898\u3002 Dynamic Programming\u4e2d\u7684Programming\uff0c\u662f\u6307\u4e00\u79cd \u8868\u683c\u8ba1\u6570\u6cd5 \u7684\u610f\u601d\uff0c\u800c\u4e0d\u662f\u6307\u5199\u4ee3\u7801\u3002\u52a8\u6001\u89c4\u5212\u5e94\u8be5\u7406\u89e3\u6210\uff0c\u5728\u4e00\u5f20\u8868\u683c\u4e0a\uff0c\u52a8\u6001\u7684\u66f4\u65b0\u8868\u683c\u4e2d\u5f97\u5230\u7684\u89e3\u3002\uff08\u8054\u60f3\u505a\u8fc7\u7684\u90a3\u4e9bDP\u9898\uff0c\u5c31\u50cf\u9762\u524d\u6709\u4e00\u4e2aN*N\u7684\u5927\u8868\u683c\uff0c\u4e0d\u65ad\u5730\u5f80\u91cc\u9762\u6dfb\u6570\uff0c\u64e6\u53bb\u65e7\u7ed3\u679c\uff0c\u586b\u5199\u65b0\u7684\u66f4\u4f18\u7ed3\u679c\uff09 \u89e3\u9898\u601d\u8def\u62c6\u62104\u90e8\u5206\uff1a \u63cf\u7ed8\u6c42\u89e3\u6700\u4f18\u95ee\u9898\u7684\u7ed3\u6784 \u9012\u5f52\u7684\u5b9a\u4e49\u6c42\u89e3\u65b9\u7a0b \u4ece\u4e0b\u5230\u4e0a\u7684\uff0c\u4f9d\u636e\u5df2\u7ecf\u5f97\u5230\u7684\u5b50\u95ee\u9898\u7684\u89e3\uff0c\u8fed\u4ee3\u6c42\u89e3\u95ee\u9898 \u901a\u8fc7\u5f97\u5230\u7684\u6bcf\u4e00\u6b65\u7684\u6700\u4f18\u89e3\uff0c\u56de\u6eaf\u51fa\u5f97\u5230\u6700\u7ec8\u6700\u4f18\u89e3\u7684\u8def\u5f84\uff08\u6216\u9009\u62e9\uff0c\u6216\u8fc7\u7a0b\uff09 2. \u52a8\u6001\u89c4\u5212\u7684\u5224\u5b9a \u6c42\uff0c\u6700\u4f18\u95ee\u9898(optimization problems) \u4eba\u8bdd\uff1a\u95ee\u9898\u6709\u5f88\u591a\u4e2a\u89e3\uff0c\u627e\u4e2a\u6700\u597d\u7684\uff0c\u6bd4\u5982\u73b0\u5b9e\u95ee\u9898\u4e2d\uff0c\u64cd\u4f5c\u6b21\u6570\u6700\u5c11\u7684\uff0c\u82b1\u8d39\u91d1\u989d\u6700\u5c11\u7684\u7b49\u7b49 \u6709\uff0c\u6700\u4f18\u5b50\u7ed3\u6784(optimal sunstructure) \u4eba\u8bdd\uff1a\u6c42\u4e00\u4e2a0...N\u7684\u95ee\u9898\uff0c\u5176\u6700\u4f18\u89e3\u7531\u66f4\u5c0f\u89c4\u6a21\u76840...N-1\u5b50\u95ee\u9898\u7684\u67d0\u4e2a\u6bd4\u8f83\u4f18\u79c0\u7684\u89e3\u5f97\u5230\uff0c\u5982\u679c\u7528\u5b50\u95ee\u9898\u7684\u6700\u4f18\u89e3\u4e00\u5b9a\u80fd\u5f97\u5230\u95ee\u9898\u7684\u6700\u4f18\u89e3\uff0c\u90a3\u5c31\u662f\u8d2a\u5fc3\u4e86 \u6709\uff0c\u91cd\u53e0\u5b50\u95ee\u9898(overlapping subproblems) \u4eba\u8bdd\uff1a\u67d0\u4e24\u4e2aN\u89c4\u6a21\u7684\u95ee\u9898\uff0c\u53ef\u80fd\u7528\u5230\u540c\u4e00\u4e2aN-1\u89c4\u6a21\u7684\u5b50\u95ee\u9898\uff0c\u90a3\u5c31\u6c42\u89e3\u8fd9\u4e2a\u5b50\u95ee\u9898\u4e00\u6b21\u5c31OK 3. LeetCode\u89e3\u9898\u6d41\u7a0b \u53c2\u8003\u81eaLeetCode\u4e0a\u4e00\u4e2a\u9898\u89e3 From good to great. How to approach most of DP problems \uff0c\u7b80\u5355\u6765\u8bf4\uff0c\u5c31\u662f\u89e3\u51b3\u5e38\u89c1\u7684DP\u95ee\u9898\uff0c \u52065\u6b65\u8d70 \u60f3\u51fa\u9012\u5f52\u5173\u7cfb\uff0c\u6216\u9012\u5f52\u65b9\u5f0f\u3002 \u8fd9\u4e00\u6b65\u6700\u5173\u952e\uff0c\u51b3\u5b9a\u4e86\u63a5\u4e0b\u6765\u76844\u6b65\uff0c\u8fd9\u6b65\u60f3\u5bf9\u4e86\uff0c\u63a5\u4e0b\u67654\u6b65\u5c31\u662f\u4f53\u529b\u6d3b\uff0c\u60f3\u9519\u4e86\u53ef\u80fd\u5f88\u96be\u5f97\u5230\u6700\u4f18\u89e3 Top-Down\u9012\u5f52\u7684\u65b9\u6cd5 Top-Down\u9012\u5f52 + \u4e2d\u95f4\u7ed3\u679c\u7684\u4fdd\u5b58\uff08\u8bb0\u5fc6\u5316\u9012\u5f52\uff09\uff0c\u4e00\u822c\u662f\u4f20\u5165\u4e00\u4e2a\u5168\u5c40\u7684array\u6216\u8005map\uff0c\u4fdd\u5b58\u5f97\u5230\u7684\u5b50\u95ee\u9898\u7684\u89e3\uff0c\u5f53\u518d\u6b21\u9012\u5f52\u5230\u540c\u4e00\u4e2a\u5b50\u95ee\u9898\u65f6\uff0c\u76f4\u63a5\u8fd4\u56de\u7ed3\u679c Bottom-Up\u8fed\u4ee3\uff0c\u901a\u8fc7\u4e00\u4e2a2\u7ef4\u62161\u7ef4\u6570\u7ec4\uff0c\u4ece\u5b50\u95ee\u98980\u8fed\u4ee3\u6c42\u89e3\u5230\u5b50\u95ee\u9898N\uff0c\u5373\u5f97\u5230\u6700\u7ec8\u95ee\u9898\u7684\u89e3 Bottom-Up\u8fed\u4ee3\uff0c\u901a\u8fc7\u65b9\u6cd54\u53d1\u73b0\u53ef\u80fd\u8fed\u4ee3\u4e2d\u53ea\u7528\u5230\u6700\u8fd1\u7684\u4e00\u4e9b\u6570\u636e\uff0c\u5982\u8fed\u4ee3i\u5c42\uff0c\u53ea\u4f1a\u7528\u5230i-1\u5c42\uff0c\u8fed\u4ee3j\uff0c\u53ef\u80fd\u53ea\u4f1a\u7528\u5230\u6bd4j\u5c0f\u7684\u5217\uff0c\u4ece\u800c \u964d\u7ef4\u6b65\u9aa4#4\u7684\u5b58\u50a8\uff0c\u8fbe\u5230\u8282\u7701\u7a7a\u95f4\u7684\u76ee\u7684 \u5f53\u8db3\u591f\u719f\u7ec3\u65f6\uff0c\u57fa\u672c\u4e0a\u601d\u8003\u51fa\u4e00\u4e2a\u6b65\u9aa4#1\uff0c\u5c31\u80fd\u5f97\u5230\u9012\u5f52\u65b9\u7a0b\u5f0f\uff0c\u5c31\u80fd\u5728\u8111\u6d77\u4e2d\u5f97\u5230\u6b65\u9aa4#2\u548c\u6b65\u9aa4#3\u7684\u4ee3\u7801\uff0c\u5c31\u80fd\u77e5\u9053\u65f6\u7a7a\u590d\u6742\u5ea6\uff0c\u8fdb\u800c\u9a8c\u8bc1\u6b65\u9aa4#1\u7684\u60f3\u6cd5\u53ef\u884c\u4e0e\u5426\uff0c\u7136\u540e\u76f4\u63a5\u53bb\u5199\u6b65\u9aa4#4\u7684\u4ee3\u7801\uff0c\u5728\u5199\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c31\u77e5\u9053\u5982\u4f55\u538b\u7f29\u7528\u5230\u7684\u5b58\u50a8\uff0c\u8fdb\u800c\u53bb\u5199\u6b65\u9aa4#5\u7684\u4ee3\u7801\uff0c\u5f97\u5230\u6700\u597d\u7684\u5b9e\u73b0\u3002 4. LeetCode\u4f8b\u9898\u7b80\u8ff0 2020-01 1143. Longest Common Subsequence cpp \u6807\u51c6LCS 300. Longest Increasing Subsequence cpp , golang \u6807\u51c6LIC\uff0c\u6700\u957f\u9012\u589e\u5b50\u5e8f\u5217\uff0c\u53ef\u4ee5\u5148\u6392\u5e8f\uff0c\u7136\u540e\u6c42\u6392\u5e8f\u597d\u7684\u548c\u521d\u59cb\u7684LCS TODO\uff0c\u6574\u7406\u4e8c\u5206O(nlogn)\u7684\u89e3\u6cd5 673. Number of Longest Increasing Subsequence cpp , golang \u540c\u7406300\uff0c\u65e0\u6cd5\u4e8c\u5206\uff0c\u53ea\u80fd\u7528\u6807\u51c6DP 397. Integer Replacement cpp , golang \u7b80\u5355DP\uff0c\u6ce8\u610fN=int32\u662f\uff0c\u6700\u5927\u503c\u6ea2\u51fa\uff0c\u4f7f\u7528long 139. Word Break cpp , golang \u4e00\u7ef4 dp[i] \u8868\u793astring\u4ece 0...i \u7684\u5b50\u7ed3\u679c \u4e8c\u7ef4 dp[i][j] \u8868\u793astring\u4ece i...j \u7684\u5b50\u7ed3\u679c \u4e8c\u7ef4\u662fO(n^3)\u7684time\uff0c\u4e00\u7ef4\u662fO(n^2)\u7684\uff0c \u4e00\u7ef4\u8981\u597d\u5f88\u591a\uff0c\u8bc1\u660e\u4e86\u60f3\u5bf9\u9012\u5f52\u5173\u7cfb\uff0c\u975e\u5e38\u5173\u952e 2020-02-04\u8865\u5145 \uff1a\u5982\u679c\u4e8c\u7ef4 dp[i][j] \u8868\u793astring\u4ece i...j \u7684\u5b50\u7ed3\u679c\uff0c\u90a3\u4e48\u8fed\u4ee3\u65f6\uff0c\u76f4\u63a5\u628a substring[0...i-1] \u548c substring[j+1...n-1] \u5f53\u6210\u4e00\u4e2aword\u5224\u5b9a\uff0c\u90a3\u4e48\u5176\u5b9e\u4e5f\u662fO(n^2)\u7684Time 2020-02 377. Combination Sum IV cpp , golang \u7b80\u5355DP\uff0c\u5176\u5b9e\u6709Integer\u6ea2\u51fa\u9690\u60a3 474. Ones and Zeroes cpp , golang dp[i][m][n] \u8868\u793a\u6570\u7ec4\u5185\u7b2ci\u4e2a\u6570\uff0cm\u4e2a0\uff0cn\u4e2a1\u7684\u7ed3\u679c\uff0c\u5b9e\u73b0\u4e0a\u76f4\u63a5\u780d\u6389dp[i]\u90a3\u7ef4\uff0c\u7528 dp1 \uff0c dp2 Best Time to Buy and Sell Stock \u7cfb\u5217 887. Super Egg Drop \u8457\u540d\u7684\u9ad8\u697c\u6254\u9e21\u86cb\u95ee\u9898\uff0c\u7ed9K\u4e2a\u9e21\u86cb\u548c\u4e00\u4e2aN\u5c42\u9ad8\u7684\u697c\uff0c\u5982\u4f55\u7528\u6700\u5c11\u7684\u5c1d\u8bd5\u6b21\u6570\uff0c\u6d4b\u8bd5\u51fa\u9e21\u86cb\u4e0d\u4f1a\u6454\u788e\u7684\u697c\u5c42\uff1f dp[m][k] denotes that given k eggs and m moves, what is the maximum number of floors that we can check. And the trick key to understand dp[m-1][k-1] + dp[m-1][k] , the plus, is, no matter egg break or not break, we always can know the other condition in the same time. \u53ea\u8981\u505a\u4e86\u6295\u9e21\u86cb\u7684\u52a8\u4f5c\uff0c\u5373\u4f7f\u9e21\u86cb\u8fd8\u5728\u7a7a\u4e2d\uff0c\u6211\u4eec\u5c31\u5df2\u7ecf\u80fd\u786e\u5b9a\u77e5\u9053\u9e21\u86cb\u788e\u4e86\uff0c\u8fd8\u662f\u6ca1\u788e\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e0b\u7684\u5168\u90e8\u7ed3\u679c\u4e86\u3002 2020-02-08\uff0c\u4e0a\u8ff0\u7684\u8868\u8fbe\u4e0d\u591f\u6e05\u6670\uff0c\u660e\u65e5\u518d\u884c\u89e3\u91ca","title":"Dynamic Programming"},{"location":"notes/dp/#dynamic-programming","text":"","title":"Dynamic Programming \u52a8\u6001\u89c4\u5212"},{"location":"notes/dp/#2019-01","text":"","title":"2019-01 \u6574\u7406"},{"location":"notes/dp/#1","text":"\u52a8\u6001\u89c4\u5212\uff0c\u548c\u5206\u6cbb\u6cd5(divide-and-conquer)\u4e00\u6837\uff0c\u90fd\u662f\u5c06\u5927\u95ee\u9898\u62c6\u5206\u6210\u5c0f\u95ee\u9898\uff0c\u901a\u8fc7\u8ba1\u7b97\u66f4\u5bb9\u6613\u5f97\u5230\u7684\u5c0f\u95ee\u9898\u7684\u89e3\uff0c\u518d\u6c47\u96c6\u6210\u5927\u95ee\u9898\u7684\u89e3\u3002 \u5206\u6cbb\u6cd5\u662f\u628a\u95ee\u9898\u62c6\u5206\u6210 \u76f8\u4e92\u72ec\u7acb \u7684\u5b50\u95ee\u9898\uff0c\u9002\u7528\u4e8e\u62c6\u5206\u7684\u5b50\u95ee\u9898\u662f\u4e92\u4e0d\u5f71\u54cd\u7684\u3002\u76f8\u53cd\uff0c\u52a8\u6001\u89c4\u5212\u9002\u7528\u4e8e\u5b50\u95ee\u9898\u662f \u76f8\u4e92\u91cd\u53e0 \u7684\uff0c\u5373\u5b58\u5728\u4e24\u4e2a\u5b50\u95ee\u9898\u53ef\u80fd\u90fd\u5305\u542b\u540c\u4e00\u4e2a\u5b50\u5b50\u95ee\u9898\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4ecd\u7528\u5206\u6cbb\u6cd5\uff0c\u5728\u9012\u5f52\u4e2d\u5bb9\u6613\u53cd\u590d\u8ba1\u7b97\u67d0\u4e00\u4e2a\u5b50\u95ee\u9898\uff0c\u9020\u6210\u4e0d\u5fc5\u8981\u7684\u6d6a\u8d39\u3002 \u6240\u4ee5\uff0c\u52a8\u6001\u89c4\u5212\u53ea\u6c42\u89e3\u5b50\u95ee\u9898\u4e00\u6b21\uff0c\u7136\u540e\u628a\u5f97\u5230\u7684\u7ed3\u679c\u4fdd\u5b58\u5230\u8868\u683c\u4e2d\uff0c\u4ece\u800c\u907f\u514d\u53cd\u590d\u6c42\u89e3\u540c\u4e00\u4e2a\u5b50\u95ee\u9898\u3002 Dynamic Programming\u4e2d\u7684Programming\uff0c\u662f\u6307\u4e00\u79cd \u8868\u683c\u8ba1\u6570\u6cd5 \u7684\u610f\u601d\uff0c\u800c\u4e0d\u662f\u6307\u5199\u4ee3\u7801\u3002\u52a8\u6001\u89c4\u5212\u5e94\u8be5\u7406\u89e3\u6210\uff0c\u5728\u4e00\u5f20\u8868\u683c\u4e0a\uff0c\u52a8\u6001\u7684\u66f4\u65b0\u8868\u683c\u4e2d\u5f97\u5230\u7684\u89e3\u3002\uff08\u8054\u60f3\u505a\u8fc7\u7684\u90a3\u4e9bDP\u9898\uff0c\u5c31\u50cf\u9762\u524d\u6709\u4e00\u4e2aN*N\u7684\u5927\u8868\u683c\uff0c\u4e0d\u65ad\u5730\u5f80\u91cc\u9762\u6dfb\u6570\uff0c\u64e6\u53bb\u65e7\u7ed3\u679c\uff0c\u586b\u5199\u65b0\u7684\u66f4\u4f18\u7ed3\u679c\uff09 \u89e3\u9898\u601d\u8def\u62c6\u62104\u90e8\u5206\uff1a \u63cf\u7ed8\u6c42\u89e3\u6700\u4f18\u95ee\u9898\u7684\u7ed3\u6784 \u9012\u5f52\u7684\u5b9a\u4e49\u6c42\u89e3\u65b9\u7a0b \u4ece\u4e0b\u5230\u4e0a\u7684\uff0c\u4f9d\u636e\u5df2\u7ecf\u5f97\u5230\u7684\u5b50\u95ee\u9898\u7684\u89e3\uff0c\u8fed\u4ee3\u6c42\u89e3\u95ee\u9898 \u901a\u8fc7\u5f97\u5230\u7684\u6bcf\u4e00\u6b65\u7684\u6700\u4f18\u89e3\uff0c\u56de\u6eaf\u51fa\u5f97\u5230\u6700\u7ec8\u6700\u4f18\u89e3\u7684\u8def\u5f84\uff08\u6216\u9009\u62e9\uff0c\u6216\u8fc7\u7a0b\uff09","title":"1. \u52a8\u6001\u89c4\u5212\u7684\u7406\u89e3"},{"location":"notes/dp/#2","text":"\u6c42\uff0c\u6700\u4f18\u95ee\u9898(optimization problems) \u4eba\u8bdd\uff1a\u95ee\u9898\u6709\u5f88\u591a\u4e2a\u89e3\uff0c\u627e\u4e2a\u6700\u597d\u7684\uff0c\u6bd4\u5982\u73b0\u5b9e\u95ee\u9898\u4e2d\uff0c\u64cd\u4f5c\u6b21\u6570\u6700\u5c11\u7684\uff0c\u82b1\u8d39\u91d1\u989d\u6700\u5c11\u7684\u7b49\u7b49 \u6709\uff0c\u6700\u4f18\u5b50\u7ed3\u6784(optimal sunstructure) \u4eba\u8bdd\uff1a\u6c42\u4e00\u4e2a0...N\u7684\u95ee\u9898\uff0c\u5176\u6700\u4f18\u89e3\u7531\u66f4\u5c0f\u89c4\u6a21\u76840...N-1\u5b50\u95ee\u9898\u7684\u67d0\u4e2a\u6bd4\u8f83\u4f18\u79c0\u7684\u89e3\u5f97\u5230\uff0c\u5982\u679c\u7528\u5b50\u95ee\u9898\u7684\u6700\u4f18\u89e3\u4e00\u5b9a\u80fd\u5f97\u5230\u95ee\u9898\u7684\u6700\u4f18\u89e3\uff0c\u90a3\u5c31\u662f\u8d2a\u5fc3\u4e86 \u6709\uff0c\u91cd\u53e0\u5b50\u95ee\u9898(overlapping subproblems) \u4eba\u8bdd\uff1a\u67d0\u4e24\u4e2aN\u89c4\u6a21\u7684\u95ee\u9898\uff0c\u53ef\u80fd\u7528\u5230\u540c\u4e00\u4e2aN-1\u89c4\u6a21\u7684\u5b50\u95ee\u9898\uff0c\u90a3\u5c31\u6c42\u89e3\u8fd9\u4e2a\u5b50\u95ee\u9898\u4e00\u6b21\u5c31OK","title":"2. \u52a8\u6001\u89c4\u5212\u7684\u5224\u5b9a"},{"location":"notes/dp/#3-leetcode","text":"\u53c2\u8003\u81eaLeetCode\u4e0a\u4e00\u4e2a\u9898\u89e3 From good to great. How to approach most of DP problems \uff0c\u7b80\u5355\u6765\u8bf4\uff0c\u5c31\u662f\u89e3\u51b3\u5e38\u89c1\u7684DP\u95ee\u9898\uff0c \u52065\u6b65\u8d70 \u60f3\u51fa\u9012\u5f52\u5173\u7cfb\uff0c\u6216\u9012\u5f52\u65b9\u5f0f\u3002 \u8fd9\u4e00\u6b65\u6700\u5173\u952e\uff0c\u51b3\u5b9a\u4e86\u63a5\u4e0b\u6765\u76844\u6b65\uff0c\u8fd9\u6b65\u60f3\u5bf9\u4e86\uff0c\u63a5\u4e0b\u67654\u6b65\u5c31\u662f\u4f53\u529b\u6d3b\uff0c\u60f3\u9519\u4e86\u53ef\u80fd\u5f88\u96be\u5f97\u5230\u6700\u4f18\u89e3 Top-Down\u9012\u5f52\u7684\u65b9\u6cd5 Top-Down\u9012\u5f52 + \u4e2d\u95f4\u7ed3\u679c\u7684\u4fdd\u5b58\uff08\u8bb0\u5fc6\u5316\u9012\u5f52\uff09\uff0c\u4e00\u822c\u662f\u4f20\u5165\u4e00\u4e2a\u5168\u5c40\u7684array\u6216\u8005map\uff0c\u4fdd\u5b58\u5f97\u5230\u7684\u5b50\u95ee\u9898\u7684\u89e3\uff0c\u5f53\u518d\u6b21\u9012\u5f52\u5230\u540c\u4e00\u4e2a\u5b50\u95ee\u9898\u65f6\uff0c\u76f4\u63a5\u8fd4\u56de\u7ed3\u679c Bottom-Up\u8fed\u4ee3\uff0c\u901a\u8fc7\u4e00\u4e2a2\u7ef4\u62161\u7ef4\u6570\u7ec4\uff0c\u4ece\u5b50\u95ee\u98980\u8fed\u4ee3\u6c42\u89e3\u5230\u5b50\u95ee\u9898N\uff0c\u5373\u5f97\u5230\u6700\u7ec8\u95ee\u9898\u7684\u89e3 Bottom-Up\u8fed\u4ee3\uff0c\u901a\u8fc7\u65b9\u6cd54\u53d1\u73b0\u53ef\u80fd\u8fed\u4ee3\u4e2d\u53ea\u7528\u5230\u6700\u8fd1\u7684\u4e00\u4e9b\u6570\u636e\uff0c\u5982\u8fed\u4ee3i\u5c42\uff0c\u53ea\u4f1a\u7528\u5230i-1\u5c42\uff0c\u8fed\u4ee3j\uff0c\u53ef\u80fd\u53ea\u4f1a\u7528\u5230\u6bd4j\u5c0f\u7684\u5217\uff0c\u4ece\u800c \u964d\u7ef4\u6b65\u9aa4#4\u7684\u5b58\u50a8\uff0c\u8fbe\u5230\u8282\u7701\u7a7a\u95f4\u7684\u76ee\u7684 \u5f53\u8db3\u591f\u719f\u7ec3\u65f6\uff0c\u57fa\u672c\u4e0a\u601d\u8003\u51fa\u4e00\u4e2a\u6b65\u9aa4#1\uff0c\u5c31\u80fd\u5f97\u5230\u9012\u5f52\u65b9\u7a0b\u5f0f\uff0c\u5c31\u80fd\u5728\u8111\u6d77\u4e2d\u5f97\u5230\u6b65\u9aa4#2\u548c\u6b65\u9aa4#3\u7684\u4ee3\u7801\uff0c\u5c31\u80fd\u77e5\u9053\u65f6\u7a7a\u590d\u6742\u5ea6\uff0c\u8fdb\u800c\u9a8c\u8bc1\u6b65\u9aa4#1\u7684\u60f3\u6cd5\u53ef\u884c\u4e0e\u5426\uff0c\u7136\u540e\u76f4\u63a5\u53bb\u5199\u6b65\u9aa4#4\u7684\u4ee3\u7801\uff0c\u5728\u5199\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c31\u77e5\u9053\u5982\u4f55\u538b\u7f29\u7528\u5230\u7684\u5b58\u50a8\uff0c\u8fdb\u800c\u53bb\u5199\u6b65\u9aa4#5\u7684\u4ee3\u7801\uff0c\u5f97\u5230\u6700\u597d\u7684\u5b9e\u73b0\u3002","title":"3. LeetCode\u89e3\u9898\u6d41\u7a0b"},{"location":"notes/dp/#4-leetcode","text":"","title":"4. LeetCode\u4f8b\u9898\u7b80\u8ff0"},{"location":"notes/dp/#2020-01","text":"","title":"2020-01"},{"location":"notes/dp/#1143-longest-common-subsequence","text":"cpp \u6807\u51c6LCS","title":"1143. Longest Common Subsequence"},{"location":"notes/dp/#300-longest-increasing-subsequence","text":"cpp , golang \u6807\u51c6LIC\uff0c\u6700\u957f\u9012\u589e\u5b50\u5e8f\u5217\uff0c\u53ef\u4ee5\u5148\u6392\u5e8f\uff0c\u7136\u540e\u6c42\u6392\u5e8f\u597d\u7684\u548c\u521d\u59cb\u7684LCS TODO\uff0c\u6574\u7406\u4e8c\u5206O(nlogn)\u7684\u89e3\u6cd5","title":"300. Longest Increasing Subsequence"},{"location":"notes/dp/#673-number-of-longest-increasing-subsequence","text":"cpp , golang \u540c\u7406300\uff0c\u65e0\u6cd5\u4e8c\u5206\uff0c\u53ea\u80fd\u7528\u6807\u51c6DP","title":"673. Number of Longest Increasing Subsequence"},{"location":"notes/dp/#397-integer-replacement","text":"cpp , golang \u7b80\u5355DP\uff0c\u6ce8\u610fN=int32\u662f\uff0c\u6700\u5927\u503c\u6ea2\u51fa\uff0c\u4f7f\u7528long","title":"397. Integer Replacement"},{"location":"notes/dp/#139-word-break","text":"cpp , golang \u4e00\u7ef4 dp[i] \u8868\u793astring\u4ece 0...i \u7684\u5b50\u7ed3\u679c \u4e8c\u7ef4 dp[i][j] \u8868\u793astring\u4ece i...j \u7684\u5b50\u7ed3\u679c \u4e8c\u7ef4\u662fO(n^3)\u7684time\uff0c\u4e00\u7ef4\u662fO(n^2)\u7684\uff0c \u4e00\u7ef4\u8981\u597d\u5f88\u591a\uff0c\u8bc1\u660e\u4e86\u60f3\u5bf9\u9012\u5f52\u5173\u7cfb\uff0c\u975e\u5e38\u5173\u952e 2020-02-04\u8865\u5145 \uff1a\u5982\u679c\u4e8c\u7ef4 dp[i][j] \u8868\u793astring\u4ece i...j \u7684\u5b50\u7ed3\u679c\uff0c\u90a3\u4e48\u8fed\u4ee3\u65f6\uff0c\u76f4\u63a5\u628a substring[0...i-1] \u548c substring[j+1...n-1] \u5f53\u6210\u4e00\u4e2aword\u5224\u5b9a\uff0c\u90a3\u4e48\u5176\u5b9e\u4e5f\u662fO(n^2)\u7684Time","title":"139. Word Break"},{"location":"notes/dp/#2020-02","text":"","title":"2020-02"},{"location":"notes/dp/#377-combination-sum-iv","text":"cpp , golang \u7b80\u5355DP\uff0c\u5176\u5b9e\u6709Integer\u6ea2\u51fa\u9690\u60a3","title":"377. Combination Sum IV"},{"location":"notes/dp/#474-ones-and-zeroes","text":"cpp , golang dp[i][m][n] \u8868\u793a\u6570\u7ec4\u5185\u7b2ci\u4e2a\u6570\uff0cm\u4e2a0\uff0cn\u4e2a1\u7684\u7ed3\u679c\uff0c\u5b9e\u73b0\u4e0a\u76f4\u63a5\u780d\u6389dp[i]\u90a3\u7ef4\uff0c\u7528 dp1 \uff0c dp2","title":"474. Ones and Zeroes"},{"location":"notes/dp/#best-time-to-buy-and-sell-stock","text":"","title":"Best Time to Buy and Sell Stock \u7cfb\u5217"},{"location":"notes/dp/#887-super-egg-drop","text":"\u8457\u540d\u7684\u9ad8\u697c\u6254\u9e21\u86cb\u95ee\u9898\uff0c\u7ed9K\u4e2a\u9e21\u86cb\u548c\u4e00\u4e2aN\u5c42\u9ad8\u7684\u697c\uff0c\u5982\u4f55\u7528\u6700\u5c11\u7684\u5c1d\u8bd5\u6b21\u6570\uff0c\u6d4b\u8bd5\u51fa\u9e21\u86cb\u4e0d\u4f1a\u6454\u788e\u7684\u697c\u5c42\uff1f dp[m][k] denotes that given k eggs and m moves, what is the maximum number of floors that we can check. And the trick key to understand dp[m-1][k-1] + dp[m-1][k] , the plus, is, no matter egg break or not break, we always can know the other condition in the same time. \u53ea\u8981\u505a\u4e86\u6295\u9e21\u86cb\u7684\u52a8\u4f5c\uff0c\u5373\u4f7f\u9e21\u86cb\u8fd8\u5728\u7a7a\u4e2d\uff0c\u6211\u4eec\u5c31\u5df2\u7ecf\u80fd\u786e\u5b9a\u77e5\u9053\u9e21\u86cb\u788e\u4e86\uff0c\u8fd8\u662f\u6ca1\u788e\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e0b\u7684\u5168\u90e8\u7ed3\u679c\u4e86\u3002 2020-02-08\uff0c\u4e0a\u8ff0\u7684\u8868\u8fbe\u4e0d\u591f\u6e05\u6670\uff0c\u660e\u65e5\u518d\u884c\u89e3\u91ca","title":"887. Super Egg Drop"},{"location":"notes/kp/","text":"Knapsack Problem \u80cc\u5305\u95ee\u9898 2019-02 \u6574\u7406 \u4e3b\u8981\u53c2\u8003\u81ea \u80cc\u53059\u8bb2 \uff0c\u8fd9\u91cc\u505a\u4e2a\u5907\u4efd 1. 01\u80cc\u5305(ZeroOnePack) 1.1 \u9898\u76ee\u8bf4\u660e \u6709N\u4ef6\u7269\u54c1\uff0c\u548c\u4e00\u4e2a\u5bb9\u91cf\u4e3aV\u7684\u80cc\u5305\uff0c\u6c42\u89e3\u5c06\u54ea\u4e9b\u7269\u54c1\u653e\u5230\u80cc\u5305\u4e2d\u80fd\u83b7\u5f97\u6700\u5927\u7684\u4ef7\u503c\u3002 \u6bcf\u4ef6\u7269\u54c1\u53ea\u80fd\u653e\u4e00\u6b21\uff0c\u5373 \u653e \u6216\u8005 \u4e0d\u653e \u3002 \u7b2ci\u4ef6\u7269\u54c1\u7684\u8d39\u7528\uff08\u91cd\u91cf\u7b49\uff0c\u4ed8\u51fa\uff09\u662fc[i]\uff0c\u7b2ci\u4ef6\u7269\u54c1\u7684\u4ef7\u503c\uff08\u5f97\u5230\uff09\u662fw[i]\u3002 1.2 \u57fa\u672c\u601d\u8def \u6700\u57fa\u7840\u7684\u80cc\u5305\u95ee\u9898\uff0c\u7279\u70b9\u662f\u7269\u54c1\u53ea\u80fd\u653e\u5230\u80cc\u5305\u4e00\u6b21\uff0c\u81ea\u6709\u653e\u8fd8\u662f\u4e0d\u653e\u7684\u72b6\u6001\u3002\u52a8\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a f[i][v] = max(f[i-1][v], f[i-1][v-c[i]] + w[i]) \u6700\u91cd\u8981\u7684\u65b9\u7a0b\uff0c\u5148\u8bf4\u660e\u4e0b\u5404\u4e2a\u53d8\u91cf\uff1af[i][v]\u8868\u793a\uff0c\u7b2c0...i\u4e2a\u7269\u54c1\uff0c\u653e\u5230\u4e00\u4e2a\u5bb9\u91cf\u4e3av\u7684\u80cc\u5305\u4e2d\uff0c\u80fd\u83b7\u5f97\u7684\u6700\u5927\u6536\u76ca\u3002v\u8868\u793a\u80cc\u5305\u5bb9\u91cf\uff0cc[i]\u8868\u793a\u7b2ci\u4e2a\u7269\u54c1\u7684\u6d88\u8017\uff0cw[i]\u8868\u793a\u7b2ci\u4e2a\u7269\u54c1\u7684\u83b7\u5f97\u3002 \u8fed\u4ee3\u65f6\uff0c\u9762\u5bf9\u4e00\u4e2a\u7269\u54c1i\uff0c\u53ea\u6709\u4e24\u4e2d\u64cd\u4f5c\uff0c\u53d6\u6216\u8005\u4e0d\u53d6\u3002\u6240\u4ee5\uff0c\u5728\u9762\u5bf9\u7b2ci\u4e2a\u7269\u54c1\uff0c\u80cc\u5305\u5bb9\u91cf\u4e3av\u65f6\uff0c\u4e0d\u53d6\u4fbf\u662ff[i-1][v]\uff0c\u53d6\u4fbf\u662ff[i-1][v-c[i]] + w[i] 1.3 \u4f18\u5316\u7a7a\u95f4 \u6ce8\u610f\uff0c\u8f6c\u79fb\u65b9\u7a0b\u4e2d\uff0c\u53d6\u65f6\uff0c\u7528\u7684\u662f f[i-1][v-c[i]] + w[i] \uff0c\u9700\u8981\u4e4b\u524d\u4e00\u4e2a\u5bb9\u91cf\u66f4\u5c0f\u80cc\u5305\u7684\u503c\u3002 \u6240\u4ee5\u5f53\u6211\u4eec\u4ece V...0 \u8ba1\u7b97\u65f6\uff0c\u5c31\u53ef\u4ee5\u4f18\u5316\u6389f[i]\u8fd9\u7ef4\uff0c\u8fd9\u662f\u7406\u89e3\u6240\u6709\u80cc\u5305\u95ee\u9898\u7684\u5173\u952e\uff0c\u9700\u8981\u65f6\u95f4\u6d88\u5316\u3002 \u4f18\u5316\u540e\u6709\u5982\u4e0b\u4f2a\u4ee3\u7801\uff1a 1 2 3 for i = 1. .. N for v = V .. 0 f [ v ] = max { f [ v ], f [ v - c [ i ]] + w [ i ]} \u4f7f\u7528\u4e00\u7ef4\u80cc\u5305\u7684\u4ee3\u7801\u8fc7\u7a0b\u4ee5\u540e\u4f1a\u88ab\u591a\u6b21\u7528\u5230\uff0c\u62bd\u8c61\u51fa\u6765\uff1a 1 2 3 4 procedure ZeroOnePack ( cost , weight ) { for V ... cost f [ v ] = max ( f [ v ], f [ v - cost ] + weight ) } \u8fd9\u6837\uff0c01\u80cc\u5305\u4fbf\u6210\u4e3a\uff1a 1 2 for 1. .. N ZeroOnePack ( c [ i ], w [ i ]) 1.4 \u521d\u59cb\u5316\u7ec6\u8282 \u6211\u4eec\u770b\u5230\u7684\u6c42\u6700\u4f18\u89e3\u7684\u80cc\u5305\u95ee\u9898\u9898\u76ee\u4e2d\uff0c\u4e8b\u5b9e\u4e0a\u6709\u4e24\u79cd\u4e0d\u592a\u76f8\u540c\u7684\u95ee\u6cd5\u3002 \u6709\u7684\u9898\u76ee\u8981\u6c42\u201c\u6070\u597d\u88c5\u6ee1\u80cc\u5305\u201d\u65f6\u7684\u6700\u4f18\u89e3\uff0c\u6709\u7684\u9898\u76ee\u5219\u5e76\u6ca1\u6709\u8981\u6c42\u5fc5\u987b\u628a\u80cc\u5305\u88c5\u6ee1\u3002 \u4e00\u79cd\u533a\u522b\u8fd9\u4e24\u79cd\u95ee\u6cd5\u7684\u5b9e\u73b0\u65b9\u6cd5\u662f\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u6709\u6240\u4e0d\u540c\u3002 \u5982\u679c\u662f\u7b2c\u4e00\u79cd\u95ee\u6cd5\uff0c\u8981\u6c42\u6070\u597d\u88c5\u6ee1\u80cc\u5305\uff0c\u90a3\u4e48\u5728\u521d\u59cb\u5316\u65f6\u9664\u4e86f[0]\u4e3a0\u5176\u5b83f[1..V]\u5747\u8bbe\u4e3a-INF\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4fdd\u8bc1\u6700\u7ec8\u5f97\u5230\u7684f[N]\u662f\u4e00\u79cd\u6070\u597d\u88c5\u6ee1\u80cc\u5305\u7684\u6700\u4f18\u89e3\uff0c-INF\u8868\u793a\u65e0\u6cd5\u6070\u597d\u88c5\u6ee1\u3002 \u5982\u679c\u5e76\u6ca1\u6709\u8981\u6c42\u5fc5\u987b\u628a\u80cc\u5305\u88c5\u6ee1\uff0c\u800c\u662f\u53ea\u5e0c\u671b\u4ef7\u683c\u5c3d\u91cf\u5927\uff0c\u521d\u59cb\u5316\u65f6\u5e94\u8be5\u5c06f[0..V]\u5168\u90e8\u8bbe\u4e3a0\u3002 2. \u5b8c\u5168\u80cc\u5305(CompletePack) 2.1 \u9898\u76ee\u8bf4\u660e \u6709N\u4ef6\u7269\u54c1\uff0c\u548c\u4e00\u4e2a\u5bb9\u91cf\u4e3aV\u7684\u80cc\u5305\uff0c\u6c42\u89e3\u5c06\u54ea\u4e9b\u7269\u54c1\u653e\u5230\u80cc\u5305\u4e2d\u80fd\u83b7\u5f97\u6700\u5927\u7684\u4ef7\u503c\u3002 \u6bcf\u4ef6\u7269\u54c1\u53ef\u4ee5\u653e\u65e0\u9650\u6b21\uff0c\u5373 \u653e0...+INF \u6b21\u3002 \u7b2ci\u4ef6\u7269\u54c1\u7684\u8d39\u7528\uff08\u91cd\u91cf\u7b49\uff0c\u4ed8\u51fa\uff09\u662fc[i]\uff0c\u7b2ci\u4ef6\u7269\u54c1\u7684\u4ef7\u503c\uff08\u5f97\u5230\uff09\u662fw[i]\u3002 2.2 \u57fa\u672c\u601d\u8def \u4eff\u716701\u80cc\u5305\u95ee\u9898\uff0c\u9012\u5f52\u65b9\u7a0b\u5e94\u8be5\u662f: f[i][v] = f[i-1][v-k*c[i]]+k*w[i]), 0 <= k*c[i] <= v \u4f46\u662f\u7528\u4e0a\u9762\u9012\u5f52\u65b9\u7a0b\u590d\u6742\u5ea6\u57fa\u672c\u5c31\u662fGG\u4e86\uff0c\u90a3\u4e48\u6700trick\u7684\u6765\u5566\uff0c\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u53ef\u4ee5\u76f4\u63a5\u8f6c\u6362\u4e3a01\u80cc\u5305\u95ee\u9898\u5f97\u5230O(VN)\u7684\u7b97\u6cd5\uff1a 1 2 3 for i = 1. . N for v = 0. . V f [ v ] = max { f [ v ], f [ v - c [ i ]] + w [ i ]} \u5b8c\u5168\u80cc\u5305\u7684\u5b9e\u73b0\u53ea\u548c01\u80cc\u5305\u5728V\u7684\u8fed\u4ee3\u6b21\u5e8f\u4e0a\u4e0d\u540c\uff0c01\u80cc\u5305\u662f\u4ece V...0 \uff0c\u800c\u5b8c\u5168\u80cc\u5305\u662f\u4ece 0...V \uff0c\u5177\u4f53\u7406\u89e3\u53ef\u4ee5\u53c2\u8003\u80cc\u53059\u8bb2\u7684\u539f\u6587\u3002\u76ee\u524d\u6211\u89c9\u5f97\u6211\u80fd\u7406\u89e3\uff0c\u4f46\u662f\u8fd8\u8bf4\u4e0d\u660e\u767d\u3002 \u6240\u4ee5\u5b8c\u5168\u80cc\u5305\u7684\u9012\u5f52\u65b9\u7a0b\u4e3a\uff1a f[i][v] = max(f[i-1][v], f[i][v-c[i]] + w[i]) \u4f2a\u4ee3\u7801\u4e3a\uff1a 1 2 3 procedure CompletePack ( cost , weight ) for v = cost ... V f [ v ] = max { f [ v ], f [ v - c [ i ]] + w [ i ]} 3. \u591a\u91cd\u80cc\u5305\u95ee\u9898(MultiplePack) 2020-02-04\uff0c\u6682\u65f6\u6574\u7406\u5230\u8fd9\uff0cLeetCode\u4e0a\u8fd8\u53ea\u670901\u548c\u5b8c\u5168\u80cc\u5305\u95ee\u9898 3.1 \u9898\u76ee\u8bf4\u660e \u6709N\u4ef6\u7269\u54c1\uff0c\u548c\u4e00\u4e2a\u5bb9\u91cf\u4e3aV\u7684\u80cc\u5305\uff0c\u6c42\u89e3\u5c06\u54ea\u4e9b\u7269\u54c1\u653e\u5230\u80cc\u5305\u4e2d\u80fd\u83b7\u5f97\u6700\u5927\u7684\u4ef7\u503c\u3002 \u6bcf\u4ef6\u7269\u54c1\u6700\u591a\u6709n[i]\u4ef6\u53ef\u7528 \u7b2ci\u4ef6\u7269\u54c1\u7684\u8d39\u7528\uff08\u91cd\u91cf\u7b49\uff0c\u4ed8\u51fa\uff09\u662fc[i]\uff0c\u7b2ci\u4ef6\u7269\u54c1\u7684\u4ef7\u503c\uff08\u5f97\u5230\uff09\u662fw[i]\u3002 3.2 \u57fa\u672c\u601d\u8def \u5982\u679c\u6bcf\u4e2a\u7269\u54c1i\uff0c\u6709 c[i] * n[i] >= V \uff0c\u90a3\u4e48\u8fd9\u4e2a\u9898\u548c\u5b8c\u5168\u80cc\u5305\u5c31\u4e00\u6837\uff0c\u96be\u53d7\u7684\u5c31\u662f\u5b58\u5728\u5c0f\u4e8e\u7684\u60c5\u51b5\u3002\u7b80\u8ff0\u4e3a\uff0c\u501f\u7528\u4e8c\u8fdb\u5236\u8868\u793a\u7684\u65b9\u6cd5\uff0c\u91c7\u75282^n\u6307\u6570\u9012\u589e\u7684\u65b9\u5f0f\u6a21\u62df01\u80cc\u5305\u7684\u5904\u7406\u8fc7\u7a0b\uff0c\u4f2a\u4ee3\u7801\u5982\u4e0b\uff1a 1 2 3 4 5 6 7 8 9 10 procedure MultiplePack ( cost , weight , amount ) if cost * amount >= V CompletePack ( cost , weight ) return integer k = 1 while k < amount ZeroOnePack ( k * cost , k * weight ) amount = amount - k k = k * 2 ZeroOnePack ( amount * cost , amount * weight ) 3.3 O(VN)\u7b97\u6cd5 \u697c\u5929\u6210\u7684\u201c\u7537\u4eba\u516b\u9898\u201d\u5e7b\u706f\u7247\u91cc\u9762\u6700\u7b80\u5355\u7684\u90a3\u4e2a\u9898\uff0c0.0 4. \u6df7\u5408\u4e09\u79cd\u80cc\u5305\u95ee\u9898(MixedPack) 4.1 \u9898\u76ee\u8bf4\u660e \u6709N\u4ef6\u7269\u54c1\uff0c\u548c\u4e00\u4e2a\u5bb9\u91cf\u4e3aV\u7684\u80cc\u5305\uff0c\u6c42\u89e3\u5c06\u54ea\u4e9b\u7269\u54c1\u653e\u5230\u80cc\u5305\u4e2d\u80fd\u83b7\u5f97\u6700\u5927\u7684\u4ef7\u503c\u3002 \u6709\u7684\u7269\u54c1\u53ea\u53ef\u4ee5\u53d6\u4e00\u6b21\uff0801\u80cc\u5305\uff09\uff0c\u6709\u7684\u7269\u54c1\u53ef\u4ee5\u53d6\u65e0\u9650\u6b21\uff08\u5b8c\u5168\u80cc\u5305\uff09\uff0c\u6709\u7684\u7269\u54c1\u53ef\u4ee5\u53d6\u7684\u6b21\u6570\u6709\u4e00\u4e2a\u4e0a\u9650\uff08\u591a\u91cd\u80cc\u5305\uff09 \uff0c\u7b2ci\u4ef6\u7269\u54c1\u7684\u8d39\u7528\uff08\u91cd\u91cf\u7b49\uff0c\u4ed8\u51fa\uff09\u662fc[i]\uff0c\u7269\u54c1\u83b7\u53d6\u7684\u4e0a\u9650\u662fn[i]\uff0c\u7b2ci\u4ef6\u7269\u54c1\u7684\u4ef7\u503c\uff08\u5f97\u5230\uff09\u662fw[i]\u3002 5.2 \u57fa\u672c\u601d\u8def \u8fd9\u5c31\u4f53\u4f1a\u5230\u7f16\u7a0b\u62bd\u8c61\u7684\u529b\u91cf\u4e86\uff1a 1 2 3 4 5 6 7 for i = 1. .. N if \u7b2ci\u4ef6\u7269\u54c1\u5c5e\u4e8e01\u80cc\u5305 ZeroOnePack ( c [ i ], w [ i ]) else if \u7b2ci\u4ef6\u7269\u54c1\u5c5e\u4e8e\u5b8c\u5168\u80cc\u5305 CompletePack ( c [ i ], w [ i ]) else if \u7b2ci\u4ef6\u7269\u54c1\u5c5e\u4e8e\u591a\u91cd\u80cc\u5305 MultiplePack ( c [ i ], w [ i ], n [ i ]) 5. \u4e8c\u7ef4\u8d39\u7528\u80cc\u5305\u95ee\u9898(TwoDimensionPack) 5.1 \u9898\u76ee\u8bf4\u660e \u6709N\u4ef6\u7269\u54c1\uff0c\u548c\u4e00\u4e2a\u5bb9\u91cf\u4e3aV\u7684\u80cc\u5305\uff0c\u6c42\u89e3\u5c06\u54ea\u4e9b\u7269\u54c1\u653e\u5230\u80cc\u5305\u4e2d\u80fd\u83b7\u5f97\u6700\u5927\u7684\u4ef7\u503c\u3002 \u6bcf\u4ef6\u7269\u54c1\u67092\u79cd\u8d39\u7528\u9700\u8981\u82b1\u8d39 \u7b2ci\u4ef6\u7269\u54c1\u7684\u8d39\u7528\uff08\u91cd\u91cf\u7b49\uff0c\u4ed8\u51fa\uff09\u662f a[i] \uff0c b[i] \uff0c\u7b2ci\u4ef6\u7269\u54c1\u7684\u4ef7\u503c\uff08\u5f97\u5230\uff09\u662fw[i]\u3002 5.2 \u57fa\u672c\u601d\u8def \u8d39\u7528\u52a0\u4e86\u4e00\u7ef4\uff0c\u72b6\u6001\u7684\u5b58\u50a8\u4e5f\u52a0\u4e00\u7ef4\u5373\u53ef\uff0c\u4e0e01\u80cc\u5305\u95ee\u9898\u76f8\u4f3c\u3002\u52a8\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a f[i][v][u] = max(f[i-1][v][u], f[i-1][v-a[i]][u-b[i]] + w[i]) \u6240\u4ee5\u4f2a\u4ee3\u7801\u4e3a\uff1a 1 2 3 4 5 procedure TwoDimensionPack ( cost1 , cost2 , weight ) { for V ... cost1 for U ... cost2 f [ v ][ u ] = max ( f [ v ][ u ], f [ v - cost1 ][ u - cost2 ] + weight ) } 5.3 \u9690\u5f0f\u8bf4\u660e \u6709\u65f6\u5019\uff0c\u201c\u4e8c\u4f4d\u8d39\u7528\u201d\u7684\u6761\u4ef6\u662f\u4ee5\u4e00\u79cd\u9690\u542b\u7684\u65b9\u5f0f\u7ed9\u51fa\uff1a \u6700\u591a\u53ea\u80fd\u53d6M\u4ef6\u7269\u54c1 \u3002\u8fd9\u4e8b\u5b9e\u4e0a\u76f8\u5f53\u4e8e\u6ca1\u4ef6\u7269\u54c1\u591a\u4e86\u4e00\u4e2a\u201c\u4ef6\u6570\u201d\u7684\u8d39\u7528\uff0c\u6bcf\u4e2a\u7269\u54c1\u7684\u4ef6\u6570\u8d39\u7528\u5747\u4e3a1\uff0c\u53ef\u4ee5\u4ed8\u51fa\u7684\u6700\u5927\u4e3aM\u3002\u7c7b\u6bd4\u5176\u4ed6\u80cc\u5305\u95ee\u9898\uff0c\u8fd9\u91cc\u5c31\u4e0d\u8d58\u8ff0\u4e86\u3002 \u9644\u5f551\uff1aLeetCode\u4e0a\u7684\u80cc\u5305\u95ee\u9898 416. Partition Equal Subset Sum \uff0c\u6807\u51c6 01\u80cc\u5305 \uff0c\u5165\u95e8\u9898\u76ee\uff0c cpp 322. Coin Change \uff0c\u6807\u51c6 \u5b8c\u5168\u80cc\u5305 \uff0c\u5165\u95e8\u9898\u76ee\uff0c cpp 518. Coin Change 2 \uff0c \u5b8c\u5168\u80cc\u5305 \uff0c\u6c42\u89e3\u7ec4\u6210\u7684\u53ef\u80fd\u6570\uff0c cpp 474. Ones and Zeroes \uff0c\u6807\u51c6 \u4e8c\u7ef401\u80cc\u5305 \uff0c f[i][m][n]=xxx \uff0c cpp","title":"Knapsack Problem"},{"location":"notes/kp/#knapsack-problem","text":"","title":"Knapsack Problem \u80cc\u5305\u95ee\u9898"},{"location":"notes/kp/#2019-02","text":"\u4e3b\u8981\u53c2\u8003\u81ea \u80cc\u53059\u8bb2 \uff0c\u8fd9\u91cc\u505a\u4e2a\u5907\u4efd","title":"2019-02 \u6574\u7406"},{"location":"notes/kp/#1-01zeroonepack","text":"","title":"1. 01\u80cc\u5305(ZeroOnePack)"},{"location":"notes/kp/#11","text":"\u6709N\u4ef6\u7269\u54c1\uff0c\u548c\u4e00\u4e2a\u5bb9\u91cf\u4e3aV\u7684\u80cc\u5305\uff0c\u6c42\u89e3\u5c06\u54ea\u4e9b\u7269\u54c1\u653e\u5230\u80cc\u5305\u4e2d\u80fd\u83b7\u5f97\u6700\u5927\u7684\u4ef7\u503c\u3002 \u6bcf\u4ef6\u7269\u54c1\u53ea\u80fd\u653e\u4e00\u6b21\uff0c\u5373 \u653e \u6216\u8005 \u4e0d\u653e \u3002 \u7b2ci\u4ef6\u7269\u54c1\u7684\u8d39\u7528\uff08\u91cd\u91cf\u7b49\uff0c\u4ed8\u51fa\uff09\u662fc[i]\uff0c\u7b2ci\u4ef6\u7269\u54c1\u7684\u4ef7\u503c\uff08\u5f97\u5230\uff09\u662fw[i]\u3002","title":"1.1 \u9898\u76ee\u8bf4\u660e"},{"location":"notes/kp/#12","text":"\u6700\u57fa\u7840\u7684\u80cc\u5305\u95ee\u9898\uff0c\u7279\u70b9\u662f\u7269\u54c1\u53ea\u80fd\u653e\u5230\u80cc\u5305\u4e00\u6b21\uff0c\u81ea\u6709\u653e\u8fd8\u662f\u4e0d\u653e\u7684\u72b6\u6001\u3002\u52a8\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a f[i][v] = max(f[i-1][v], f[i-1][v-c[i]] + w[i]) \u6700\u91cd\u8981\u7684\u65b9\u7a0b\uff0c\u5148\u8bf4\u660e\u4e0b\u5404\u4e2a\u53d8\u91cf\uff1af[i][v]\u8868\u793a\uff0c\u7b2c0...i\u4e2a\u7269\u54c1\uff0c\u653e\u5230\u4e00\u4e2a\u5bb9\u91cf\u4e3av\u7684\u80cc\u5305\u4e2d\uff0c\u80fd\u83b7\u5f97\u7684\u6700\u5927\u6536\u76ca\u3002v\u8868\u793a\u80cc\u5305\u5bb9\u91cf\uff0cc[i]\u8868\u793a\u7b2ci\u4e2a\u7269\u54c1\u7684\u6d88\u8017\uff0cw[i]\u8868\u793a\u7b2ci\u4e2a\u7269\u54c1\u7684\u83b7\u5f97\u3002 \u8fed\u4ee3\u65f6\uff0c\u9762\u5bf9\u4e00\u4e2a\u7269\u54c1i\uff0c\u53ea\u6709\u4e24\u4e2d\u64cd\u4f5c\uff0c\u53d6\u6216\u8005\u4e0d\u53d6\u3002\u6240\u4ee5\uff0c\u5728\u9762\u5bf9\u7b2ci\u4e2a\u7269\u54c1\uff0c\u80cc\u5305\u5bb9\u91cf\u4e3av\u65f6\uff0c\u4e0d\u53d6\u4fbf\u662ff[i-1][v]\uff0c\u53d6\u4fbf\u662ff[i-1][v-c[i]] + w[i]","title":"1.2 \u57fa\u672c\u601d\u8def"},{"location":"notes/kp/#13","text":"\u6ce8\u610f\uff0c\u8f6c\u79fb\u65b9\u7a0b\u4e2d\uff0c\u53d6\u65f6\uff0c\u7528\u7684\u662f f[i-1][v-c[i]] + w[i] \uff0c\u9700\u8981\u4e4b\u524d\u4e00\u4e2a\u5bb9\u91cf\u66f4\u5c0f\u80cc\u5305\u7684\u503c\u3002 \u6240\u4ee5\u5f53\u6211\u4eec\u4ece V...0 \u8ba1\u7b97\u65f6\uff0c\u5c31\u53ef\u4ee5\u4f18\u5316\u6389f[i]\u8fd9\u7ef4\uff0c\u8fd9\u662f\u7406\u89e3\u6240\u6709\u80cc\u5305\u95ee\u9898\u7684\u5173\u952e\uff0c\u9700\u8981\u65f6\u95f4\u6d88\u5316\u3002 \u4f18\u5316\u540e\u6709\u5982\u4e0b\u4f2a\u4ee3\u7801\uff1a 1 2 3 for i = 1. .. N for v = V .. 0 f [ v ] = max { f [ v ], f [ v - c [ i ]] + w [ i ]} \u4f7f\u7528\u4e00\u7ef4\u80cc\u5305\u7684\u4ee3\u7801\u8fc7\u7a0b\u4ee5\u540e\u4f1a\u88ab\u591a\u6b21\u7528\u5230\uff0c\u62bd\u8c61\u51fa\u6765\uff1a 1 2 3 4 procedure ZeroOnePack ( cost , weight ) { for V ... cost f [ v ] = max ( f [ v ], f [ v - cost ] + weight ) } \u8fd9\u6837\uff0c01\u80cc\u5305\u4fbf\u6210\u4e3a\uff1a 1 2 for 1. .. N ZeroOnePack ( c [ i ], w [ i ])","title":"1.3 \u4f18\u5316\u7a7a\u95f4"},{"location":"notes/kp/#14","text":"\u6211\u4eec\u770b\u5230\u7684\u6c42\u6700\u4f18\u89e3\u7684\u80cc\u5305\u95ee\u9898\u9898\u76ee\u4e2d\uff0c\u4e8b\u5b9e\u4e0a\u6709\u4e24\u79cd\u4e0d\u592a\u76f8\u540c\u7684\u95ee\u6cd5\u3002 \u6709\u7684\u9898\u76ee\u8981\u6c42\u201c\u6070\u597d\u88c5\u6ee1\u80cc\u5305\u201d\u65f6\u7684\u6700\u4f18\u89e3\uff0c\u6709\u7684\u9898\u76ee\u5219\u5e76\u6ca1\u6709\u8981\u6c42\u5fc5\u987b\u628a\u80cc\u5305\u88c5\u6ee1\u3002 \u4e00\u79cd\u533a\u522b\u8fd9\u4e24\u79cd\u95ee\u6cd5\u7684\u5b9e\u73b0\u65b9\u6cd5\u662f\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u6709\u6240\u4e0d\u540c\u3002 \u5982\u679c\u662f\u7b2c\u4e00\u79cd\u95ee\u6cd5\uff0c\u8981\u6c42\u6070\u597d\u88c5\u6ee1\u80cc\u5305\uff0c\u90a3\u4e48\u5728\u521d\u59cb\u5316\u65f6\u9664\u4e86f[0]\u4e3a0\u5176\u5b83f[1..V]\u5747\u8bbe\u4e3a-INF\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4fdd\u8bc1\u6700\u7ec8\u5f97\u5230\u7684f[N]\u662f\u4e00\u79cd\u6070\u597d\u88c5\u6ee1\u80cc\u5305\u7684\u6700\u4f18\u89e3\uff0c-INF\u8868\u793a\u65e0\u6cd5\u6070\u597d\u88c5\u6ee1\u3002 \u5982\u679c\u5e76\u6ca1\u6709\u8981\u6c42\u5fc5\u987b\u628a\u80cc\u5305\u88c5\u6ee1\uff0c\u800c\u662f\u53ea\u5e0c\u671b\u4ef7\u683c\u5c3d\u91cf\u5927\uff0c\u521d\u59cb\u5316\u65f6\u5e94\u8be5\u5c06f[0..V]\u5168\u90e8\u8bbe\u4e3a0\u3002","title":"1.4 \u521d\u59cb\u5316\u7ec6\u8282"},{"location":"notes/kp/#2-completepack","text":"","title":"2. \u5b8c\u5168\u80cc\u5305(CompletePack)"},{"location":"notes/kp/#21","text":"\u6709N\u4ef6\u7269\u54c1\uff0c\u548c\u4e00\u4e2a\u5bb9\u91cf\u4e3aV\u7684\u80cc\u5305\uff0c\u6c42\u89e3\u5c06\u54ea\u4e9b\u7269\u54c1\u653e\u5230\u80cc\u5305\u4e2d\u80fd\u83b7\u5f97\u6700\u5927\u7684\u4ef7\u503c\u3002 \u6bcf\u4ef6\u7269\u54c1\u53ef\u4ee5\u653e\u65e0\u9650\u6b21\uff0c\u5373 \u653e0...+INF \u6b21\u3002 \u7b2ci\u4ef6\u7269\u54c1\u7684\u8d39\u7528\uff08\u91cd\u91cf\u7b49\uff0c\u4ed8\u51fa\uff09\u662fc[i]\uff0c\u7b2ci\u4ef6\u7269\u54c1\u7684\u4ef7\u503c\uff08\u5f97\u5230\uff09\u662fw[i]\u3002","title":"2.1 \u9898\u76ee\u8bf4\u660e"},{"location":"notes/kp/#22","text":"\u4eff\u716701\u80cc\u5305\u95ee\u9898\uff0c\u9012\u5f52\u65b9\u7a0b\u5e94\u8be5\u662f: f[i][v] = f[i-1][v-k*c[i]]+k*w[i]), 0 <= k*c[i] <= v \u4f46\u662f\u7528\u4e0a\u9762\u9012\u5f52\u65b9\u7a0b\u590d\u6742\u5ea6\u57fa\u672c\u5c31\u662fGG\u4e86\uff0c\u90a3\u4e48\u6700trick\u7684\u6765\u5566\uff0c\u5b8c\u5168\u80cc\u5305\u95ee\u9898\u53ef\u4ee5\u76f4\u63a5\u8f6c\u6362\u4e3a01\u80cc\u5305\u95ee\u9898\u5f97\u5230O(VN)\u7684\u7b97\u6cd5\uff1a 1 2 3 for i = 1. . N for v = 0. . V f [ v ] = max { f [ v ], f [ v - c [ i ]] + w [ i ]} \u5b8c\u5168\u80cc\u5305\u7684\u5b9e\u73b0\u53ea\u548c01\u80cc\u5305\u5728V\u7684\u8fed\u4ee3\u6b21\u5e8f\u4e0a\u4e0d\u540c\uff0c01\u80cc\u5305\u662f\u4ece V...0 \uff0c\u800c\u5b8c\u5168\u80cc\u5305\u662f\u4ece 0...V \uff0c\u5177\u4f53\u7406\u89e3\u53ef\u4ee5\u53c2\u8003\u80cc\u53059\u8bb2\u7684\u539f\u6587\u3002\u76ee\u524d\u6211\u89c9\u5f97\u6211\u80fd\u7406\u89e3\uff0c\u4f46\u662f\u8fd8\u8bf4\u4e0d\u660e\u767d\u3002 \u6240\u4ee5\u5b8c\u5168\u80cc\u5305\u7684\u9012\u5f52\u65b9\u7a0b\u4e3a\uff1a f[i][v] = max(f[i-1][v], f[i][v-c[i]] + w[i]) \u4f2a\u4ee3\u7801\u4e3a\uff1a 1 2 3 procedure CompletePack ( cost , weight ) for v = cost ... V f [ v ] = max { f [ v ], f [ v - c [ i ]] + w [ i ]}","title":"2.2 \u57fa\u672c\u601d\u8def"},{"location":"notes/kp/#3-multiplepack","text":"2020-02-04\uff0c\u6682\u65f6\u6574\u7406\u5230\u8fd9\uff0cLeetCode\u4e0a\u8fd8\u53ea\u670901\u548c\u5b8c\u5168\u80cc\u5305\u95ee\u9898","title":"3. \u591a\u91cd\u80cc\u5305\u95ee\u9898(MultiplePack)"},{"location":"notes/kp/#31","text":"\u6709N\u4ef6\u7269\u54c1\uff0c\u548c\u4e00\u4e2a\u5bb9\u91cf\u4e3aV\u7684\u80cc\u5305\uff0c\u6c42\u89e3\u5c06\u54ea\u4e9b\u7269\u54c1\u653e\u5230\u80cc\u5305\u4e2d\u80fd\u83b7\u5f97\u6700\u5927\u7684\u4ef7\u503c\u3002 \u6bcf\u4ef6\u7269\u54c1\u6700\u591a\u6709n[i]\u4ef6\u53ef\u7528 \u7b2ci\u4ef6\u7269\u54c1\u7684\u8d39\u7528\uff08\u91cd\u91cf\u7b49\uff0c\u4ed8\u51fa\uff09\u662fc[i]\uff0c\u7b2ci\u4ef6\u7269\u54c1\u7684\u4ef7\u503c\uff08\u5f97\u5230\uff09\u662fw[i]\u3002","title":"3.1 \u9898\u76ee\u8bf4\u660e"},{"location":"notes/kp/#32","text":"\u5982\u679c\u6bcf\u4e2a\u7269\u54c1i\uff0c\u6709 c[i] * n[i] >= V \uff0c\u90a3\u4e48\u8fd9\u4e2a\u9898\u548c\u5b8c\u5168\u80cc\u5305\u5c31\u4e00\u6837\uff0c\u96be\u53d7\u7684\u5c31\u662f\u5b58\u5728\u5c0f\u4e8e\u7684\u60c5\u51b5\u3002\u7b80\u8ff0\u4e3a\uff0c\u501f\u7528\u4e8c\u8fdb\u5236\u8868\u793a\u7684\u65b9\u6cd5\uff0c\u91c7\u75282^n\u6307\u6570\u9012\u589e\u7684\u65b9\u5f0f\u6a21\u62df01\u80cc\u5305\u7684\u5904\u7406\u8fc7\u7a0b\uff0c\u4f2a\u4ee3\u7801\u5982\u4e0b\uff1a 1 2 3 4 5 6 7 8 9 10 procedure MultiplePack ( cost , weight , amount ) if cost * amount >= V CompletePack ( cost , weight ) return integer k = 1 while k < amount ZeroOnePack ( k * cost , k * weight ) amount = amount - k k = k * 2 ZeroOnePack ( amount * cost , amount * weight )","title":"3.2 \u57fa\u672c\u601d\u8def"},{"location":"notes/kp/#33-ovn","text":"\u697c\u5929\u6210\u7684\u201c\u7537\u4eba\u516b\u9898\u201d\u5e7b\u706f\u7247\u91cc\u9762\u6700\u7b80\u5355\u7684\u90a3\u4e2a\u9898\uff0c0.0","title":"3.3 O(VN)\u7b97\u6cd5"},{"location":"notes/kp/#4-mixedpack","text":"","title":"4. \u6df7\u5408\u4e09\u79cd\u80cc\u5305\u95ee\u9898(MixedPack)"},{"location":"notes/kp/#41","text":"\u6709N\u4ef6\u7269\u54c1\uff0c\u548c\u4e00\u4e2a\u5bb9\u91cf\u4e3aV\u7684\u80cc\u5305\uff0c\u6c42\u89e3\u5c06\u54ea\u4e9b\u7269\u54c1\u653e\u5230\u80cc\u5305\u4e2d\u80fd\u83b7\u5f97\u6700\u5927\u7684\u4ef7\u503c\u3002 \u6709\u7684\u7269\u54c1\u53ea\u53ef\u4ee5\u53d6\u4e00\u6b21\uff0801\u80cc\u5305\uff09\uff0c\u6709\u7684\u7269\u54c1\u53ef\u4ee5\u53d6\u65e0\u9650\u6b21\uff08\u5b8c\u5168\u80cc\u5305\uff09\uff0c\u6709\u7684\u7269\u54c1\u53ef\u4ee5\u53d6\u7684\u6b21\u6570\u6709\u4e00\u4e2a\u4e0a\u9650\uff08\u591a\u91cd\u80cc\u5305\uff09 \uff0c\u7b2ci\u4ef6\u7269\u54c1\u7684\u8d39\u7528\uff08\u91cd\u91cf\u7b49\uff0c\u4ed8\u51fa\uff09\u662fc[i]\uff0c\u7269\u54c1\u83b7\u53d6\u7684\u4e0a\u9650\u662fn[i]\uff0c\u7b2ci\u4ef6\u7269\u54c1\u7684\u4ef7\u503c\uff08\u5f97\u5230\uff09\u662fw[i]\u3002","title":"4.1 \u9898\u76ee\u8bf4\u660e"},{"location":"notes/kp/#52","text":"\u8fd9\u5c31\u4f53\u4f1a\u5230\u7f16\u7a0b\u62bd\u8c61\u7684\u529b\u91cf\u4e86\uff1a 1 2 3 4 5 6 7 for i = 1. .. N if \u7b2ci\u4ef6\u7269\u54c1\u5c5e\u4e8e01\u80cc\u5305 ZeroOnePack ( c [ i ], w [ i ]) else if \u7b2ci\u4ef6\u7269\u54c1\u5c5e\u4e8e\u5b8c\u5168\u80cc\u5305 CompletePack ( c [ i ], w [ i ]) else if \u7b2ci\u4ef6\u7269\u54c1\u5c5e\u4e8e\u591a\u91cd\u80cc\u5305 MultiplePack ( c [ i ], w [ i ], n [ i ])","title":"5.2 \u57fa\u672c\u601d\u8def"},{"location":"notes/kp/#5-twodimensionpack","text":"","title":"5. \u4e8c\u7ef4\u8d39\u7528\u80cc\u5305\u95ee\u9898(TwoDimensionPack)"},{"location":"notes/kp/#51","text":"\u6709N\u4ef6\u7269\u54c1\uff0c\u548c\u4e00\u4e2a\u5bb9\u91cf\u4e3aV\u7684\u80cc\u5305\uff0c\u6c42\u89e3\u5c06\u54ea\u4e9b\u7269\u54c1\u653e\u5230\u80cc\u5305\u4e2d\u80fd\u83b7\u5f97\u6700\u5927\u7684\u4ef7\u503c\u3002 \u6bcf\u4ef6\u7269\u54c1\u67092\u79cd\u8d39\u7528\u9700\u8981\u82b1\u8d39 \u7b2ci\u4ef6\u7269\u54c1\u7684\u8d39\u7528\uff08\u91cd\u91cf\u7b49\uff0c\u4ed8\u51fa\uff09\u662f a[i] \uff0c b[i] \uff0c\u7b2ci\u4ef6\u7269\u54c1\u7684\u4ef7\u503c\uff08\u5f97\u5230\uff09\u662fw[i]\u3002","title":"5.1 \u9898\u76ee\u8bf4\u660e"},{"location":"notes/kp/#52_1","text":"\u8d39\u7528\u52a0\u4e86\u4e00\u7ef4\uff0c\u72b6\u6001\u7684\u5b58\u50a8\u4e5f\u52a0\u4e00\u7ef4\u5373\u53ef\uff0c\u4e0e01\u80cc\u5305\u95ee\u9898\u76f8\u4f3c\u3002\u52a8\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a f[i][v][u] = max(f[i-1][v][u], f[i-1][v-a[i]][u-b[i]] + w[i]) \u6240\u4ee5\u4f2a\u4ee3\u7801\u4e3a\uff1a 1 2 3 4 5 procedure TwoDimensionPack ( cost1 , cost2 , weight ) { for V ... cost1 for U ... cost2 f [ v ][ u ] = max ( f [ v ][ u ], f [ v - cost1 ][ u - cost2 ] + weight ) }","title":"5.2 \u57fa\u672c\u601d\u8def"},{"location":"notes/kp/#53","text":"\u6709\u65f6\u5019\uff0c\u201c\u4e8c\u4f4d\u8d39\u7528\u201d\u7684\u6761\u4ef6\u662f\u4ee5\u4e00\u79cd\u9690\u542b\u7684\u65b9\u5f0f\u7ed9\u51fa\uff1a \u6700\u591a\u53ea\u80fd\u53d6M\u4ef6\u7269\u54c1 \u3002\u8fd9\u4e8b\u5b9e\u4e0a\u76f8\u5f53\u4e8e\u6ca1\u4ef6\u7269\u54c1\u591a\u4e86\u4e00\u4e2a\u201c\u4ef6\u6570\u201d\u7684\u8d39\u7528\uff0c\u6bcf\u4e2a\u7269\u54c1\u7684\u4ef6\u6570\u8d39\u7528\u5747\u4e3a1\uff0c\u53ef\u4ee5\u4ed8\u51fa\u7684\u6700\u5927\u4e3aM\u3002\u7c7b\u6bd4\u5176\u4ed6\u80cc\u5305\u95ee\u9898\uff0c\u8fd9\u91cc\u5c31\u4e0d\u8d58\u8ff0\u4e86\u3002","title":"5.3 \u9690\u5f0f\u8bf4\u660e"},{"location":"notes/kp/#1leetcode","text":"416. Partition Equal Subset Sum \uff0c\u6807\u51c6 01\u80cc\u5305 \uff0c\u5165\u95e8\u9898\u76ee\uff0c cpp 322. Coin Change \uff0c\u6807\u51c6 \u5b8c\u5168\u80cc\u5305 \uff0c\u5165\u95e8\u9898\u76ee\uff0c cpp 518. Coin Change 2 \uff0c \u5b8c\u5168\u80cc\u5305 \uff0c\u6c42\u89e3\u7ec4\u6210\u7684\u53ef\u80fd\u6570\uff0c cpp 474. Ones and Zeroes \uff0c\u6807\u51c6 \u4e8c\u7ef401\u80cc\u5305 \uff0c f[i][m][n]=xxx \uff0c cpp","title":"\u9644\u5f551\uff1aLeetCode\u4e0a\u7684\u80cc\u5305\u95ee\u9898"},{"location":"notes/linkedlist/","text":"Linkedlist \u76f8\u5173\u9898\u76ee\u9898\u89e3 2020-03 138. Copy List with Random Pointer 143. Reorder List 92. Reorder List 328. Odd Even Linked List 237. Delete Node in a Linked List","title":"Linked List"},{"location":"notes/linkedlist/#linkedlist","text":"","title":"Linkedlist \u76f8\u5173\u9898\u76ee\u9898\u89e3"},{"location":"notes/linkedlist/#2020-03","text":"","title":"2020-03"},{"location":"notes/linkedlist/#138-copy-list-with-random-pointer","text":"","title":"138. Copy List with Random Pointer"},{"location":"notes/linkedlist/#143-reorder-list","text":"","title":"143. Reorder List"},{"location":"notes/linkedlist/#92-reorder-list","text":"","title":"92. Reorder List"},{"location":"notes/linkedlist/#328-odd-even-linked-list","text":"","title":"328. Odd Even Linked List"},{"location":"notes/linkedlist/#237-delete-node-in-a-linked-list","text":"","title":"237. Delete Node in a Linked List"},{"location":"notes/others/","text":"\u9898\u89e3\u7b14\u8bb0 2019-01 4. Madian Sorted Arrays 2\u4e2asorted\u6570\u7ec4\uff0c\u53d6\u7b2cK\u5927\u7684\u6570 \u7528left_k\uff0cright_k\uff08left_k + 1\uff09\u7684trick\u89e3\u51b3\u5947\u5076\u957f\u5ea6\u7684\u95ee\u9898 \u6bcf\u6b21\u53d6\u7b2ck/2\u4f4d\u7f6e\u7684\u5143\u7d20 val1\uff0cval2 \u6bd4\u8f83\uff0c\u5982\u679c val1 < val2 \uff0c\u5219\u6709 k/2 \u53ef\u4ee5\u6392\u9664\u4e86\uff0c arr1 \u8d77\u70b9 + k/2 \uff0c\u9012\u5f52\u67e5\u627e\u7b2c k-k/2 \u5927\u7684\u6570 398. Random Pick Index int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums); pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning. \u968f\u673a\u7d22\u5f15\uff0c\u5176\u5b9e\u60f3\u6a21\u62df\u84c4\u6c34\u6c60\u95ee\u9898\uff08Reservoir Sampling\uff09 \u4e86\u89e3\u84c4\u6c34\u6c60\u95ee\u9898\uff0c\u7406\u89e3\u84c4\u6c34\u6c60\u62bd\u6837\u7b97\u6cd5\u4e2d\u6982\u7387\u5747\u7b49\u7279\u70b9 \u84c4\u6c34\u6c60 https://cloud.tencent.com/developer/news/293271 \u66f4\u597d\u7684\u6a21\u62df\u5e94\u8be5\u662fstream\u6d41\u8f93\u5165\uff0c\u6bcf\u4e00\u4e2aindex\u9020\u4e00\u4e2a\u5927\u5c0f\u4e3a10\u7684\u6c60\u5b50\uff0c\u8fd9\u6837\u65e2\u8282\u7ea6\u7a7a\u95f4\u6709O\uff081\uff09pick \u5176\u5b9e\u53ef\u4ee5\u8fdb\u884c\u6269\u5c55\uff0c\u670d\u52a1\u5316\uff0c\u63d0\u4f9b/stream\u548c/pick\u63a5\u53e3\uff0c\u591a\u7ebf\u7a0b\u8bfb\u5199\u9501\u89e3\u51b3\u540c\u6b65\u95ee\u9898\uff0chub\u6a21\u5f0f\u901a\u8fc7hash\u89e3\u51b3\u591akey\u7684\u5206\u5e03\u5f0f\uff0c\u901a\u8fc7hub\u4e2d\u5bf9\u5404\u5b50\u8282\u70b9val\u503c\u8ba1\u6570\u89e3\u51b3\u5206\u5e03\u5b50\u8282\u70b9\u4e0d\u5747\u5300\u7684\u95ee\u9898 2020-01-02\u8865\u5145\uff0c\u6ca1\u6709\u8282\u70b9\u4e0d\u5747\u5300\u7684\u95ee\u9898\uff0c\u56e0\u4e3a\u6700\u5927\u5c31\u662f\u6c60\u5b50\u7684\u5927\u5c0f 297. Serialize and Deserialize Binary Tree BST\u5e8f\u5217\u5316\u4e0e\u53cd\u5e8f\u5217\u5316\uff0c\u4e2d\u5e8f\u904d\u5386 \u5e8f\u5217\u5316\u903b\u8f91\u62c6\u5206\uff1a1-basic\u60c5\u51b5\u68c0\u6d4b\uff0c2-int->string->char vector\uff0c3-recursive\u5de6\u6811\uff0c\u7136\u540erecursive\u53f3\u5b50\u6811 \u53cd\u5e8f\u5217\u5316\u903b\u8f91\u62c6\u5206\uff1a1-\u5b9a\u4e49\u4e00\u4e2a\u5168\u5c40\u8d77\u59cbposition\uff0c\u4f20\u9012\u4e3a\u6307\u9488\uff0c2-\u672b\u5c3e\u8fb9\u754ccheck\uff0c3-\u53d6\u6574\u6bb5char\u8f6c\u4e3aint\uff0c4-position\u66f4\u65b0\uff0c\u9012\u5f52\u5de6\u53f3 138. Copy List with Random Pointer \u89e3\u6cd51\uff0c\u9020\u4e2a2\u4e2amap\uff0c\u65e7\u7684[pointer, index]\uff0c\u65b0\u7684[index, pointer]\uff0c\u5148\u904d\u5386\u4e00\u6b21create\uff0c\u8bbemap\uff0c\u518d\u904d\u5386\u4e00\u6b21\u901a\u8fc72\u4e2amap\u627e\u5230random \u6ce8\u610frandom=NULL \u89e3\u6cd52\uff0cA -> A'-> B -> B'-> C -> C': \u63d2\u5165copy random=random->next \u5206\u79bb 146. LRU Cache LRU\uff0chashmap + double linked list \u5bf9\u4e8eGET\uff0c2\u79cd\u60c5\u51b5\uff0c\u6ca1\u627e\u5230/\u627e\u5230\uff0c\u627e\u5230\u8c03\u7528PUT\u5237\u65b0last use \u5bf9\u4e8ePUT\uff0c3\u79cd\u60c5\u51b5: key\u5728\uff0cdelete\u5220\u9664\u53cc\u7aef\u94fe\u8868\u8282\u70b9\uff0cadd\u6dfb\u52a0\u65b0\u8282\u70b9 key\u4e0d\u5728\uff0csize < cap\uff0c\u76f4\u63a5add key\u4e0d\u5728\uff0csize = cap\uff0celiminate\u6dd8\u6c70\u6700\u540e\u7684\uff0c\u8fd4\u56de\u6dd8\u6c70\u7684key\uff0c map\u540c\u6b65\u5220\u9664key \uff0c\u6267\u884cadd LRU\u539f\u7406\u548cRedis\u5b9e\u73b0\u2014\u2014\u4e00\u4e2a\u4eca\u65e5\u5934\u6761\u7684\u9762\u8bd5\u9898 221. Maximal Square DP \u5982\u679c matrix[i][j] = '1', [i, j] = min([i+1, j], [i, j+1], [i+1, j+1]) + 1 \u5982\u679c matrix[i][j] = '0', [i, j] = 0 236. Lowest Common Ancestor of a Binary Tree 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // \u5982\u679cp, q\u843d\u5728\u4e0d\u540c\u5b50\u6811\uff0c\u5219LCU\u662f\u5f53\u524d\u7684root // \u5982\u679cp, q\u843d\u5728\u76f8\u540c\u5b50\u6811\uff0c\u9012\u5f52\u5de6\u53f3\u7684\u5b50\u95ee\u9898\uff0c\u76f4\u81f3p,q\u843d\u5728\u4e0d\u540c\u5b50\u6811 TreeNode * func2 ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( root == NULL || root == p || root == q ) { return root ; } TreeNode * left = func2 ( root -> left , p , q ); TreeNode * right = func2 ( root -> right , p , q ); if ( left != NULL && right != NULL ) { return root ; } return left != NULL ? left : right ; } 300. Longest Increasing Subsequence DP, copy+sort+unique\u521d\u59cb\u6570\u7ec4\uff0c\u7136\u540e\u8ba1\u7b97\u4e24\u4e2a\u6570\u7ec4\u7684LCS\u7684\u957f\u5ea6\uff0c\u56e0\u4e3alongest-common-subsequence\u65f6\u95f4\u662fO(n^2)\u7684\uff0c\u6700\u7ec8\u5c31\u662fO(n^2)\u7684\uff0c\u6240\u4ee5\uff1a \u8981\u5f97\u5230o(nlogn)\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u8be5\u600e\u4e48\u505a\u5462\uff1f O(nlogn)\u7684\u89e3\u6cd5\u53c2\u8003 https://blog.csdn.net/sgbfblog/article/details/7798737 \uff0c\u7b80\u8ff0\u4f8b\u5b50\u5982[12, 17, 18, 19, 14, 15, 16]\uff0c\u6784\u7b51\u7684\u9006\u5e8f\u6570\u7ec4\u6d41\u7a0b\u4e3a\uff1a \u521d\u59cb [16] 15\uff0c\u4e8c\u5206\u67e5\u627e=1 > \u6570\u7ec4\u5927\u5c0f\uff0c\u6570\u7ec4append\u4e3a[16, 15] 14\uff0c\u540c\u4e0a[16, 15, 14] 19\uff0c\u4e8c\u5206\u67e5\u627e=0\uff0c\u66ff\u636216\u4e3a19\uff0c\u539f\u56e0\u4e3a19\u5bf9\u5e94\u7684\u957f\u5ea6\u548c16\u4e00\u6837\uff0c\u90fd\u662f1\uff0c\u4f46\u662f19\u6bd416\u5927\uff0c\u5982\u679c16\u5bf9\u4e8e\u67d0\u4e00\u4e2a\u70b9\u662f\u9012\u589e\u7684\uff0c\u90a3\u4e4819\u4e5f\u4e00\u5b9a\u9012\u589e 18\uff0c\u540c\u4e0a\uff0c\u4e4b\u540e\u7684\u7701\u7565 \u6ce8\u610f \uff0c\u4e8c\u5206\u67e5\u627e\uff0c\u4e3a\uff0c\u5728\u4e00\u4e2a\u9006\u5e8f\u6570\u7ec4\u4e2d\uff0c\u627e\u5230\u6bd4target\u5c0f\u7684\u6700\u5927\u7684\u5143\u7d20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // ** O ( nlogn ) binary - search solution , interesting func func3 ( nums [] int ) int { n : = len ( nums ); arr : = make ( [] int , 0 ); for i : = n - 1 ; i >= 0 ; i -- { idx : = findLargestLessOrEqualThanTarget ( arr , nums [ i ] ); if idx >= len ( arr ) { arr = append ( arr , nums [ i ] ) } else { arr [ idx ] = nums [ i ] ; } } return len ( arr ); } /* * nums is inverted order and return the index that nums[index] is the * largest element <= target * eg: [19,18,17,16,10], find target | nums[lo] | nums[hi] | ret: * 20 | nums[0]=19 | nums[-1]= | 0 * 19 | nums[0]=19 | nums[0]=19 | 0 * 12 | nums[4]=10 | nums[3]=16 | 4 * 09 | nums[5]= | nums[4]=10 | 5 */ func findLargestLessOrEqualThanTarget ( nums [] int , target int ) int { lo : = 0 ; hi : = len ( nums ) - 1 ; for ( lo <= hi ) { mid : = ( lo + hi ) / 2 ; if nums [ mid ] == target { return mid ; } else if nums [ mid ] > target { lo = mid + 1 ; } else { hi = mid - 1 ; } } return lo ; } 3. \u6807\u51c6DP\uff0c\u4ece\u5de6\u5230\u53f3\u8fed\u4ee3\uff0cdp[i]\u4e3a\uff0c\u4ece0\u5230i\uff0c\u4ee5i\u4e3a\u7ed3\u675f\uff0c\u6700\u957f\u7684LIS\uff0c\u4ece\u53f3\u5230\u5de6\u8fed\u4ee3\uff0cdp[i]\u4e3a\uff0c\u4ecei\u5230n-1\uff08\u5c3e\uff09\uff0c\u6700\u957f\u7684LIS\uff0c\u65f6\u95f4\u5747\u4e3aO(n^2) 673. Number of Longest Increasing Subsequence DP\uff0c300\u6c42LIS\u7684\u53d8\u79cd\uff0c\u591a\u6bd4\u8f83\u76f8\u7b49\u7684\u60c5\u51b5\uff0c\u8fed\u4ee3\u4e2d\uff0c\u4fdd\u5b58\u6bcf\u4e2a\u70b9\u7684\u6700\u5927\u7684LIS\u7684\u4e2a\u6570\u5373\u53ef\uff0c\u4e4b\u540e\uff0c\u7edf\u4e00\u7528\u5f97\u5230\u7684max_length\u8fed\u4ee3\u6bd4\u8f83\u8fdb\u884c\u7edf\u8ba1 \u901a\u7528\u4e8c\u5206\u67e5\u627e\u6574\u7406 \u65e0\u8bba\u662f\u627e\u6700\u53f3\uff0c\u5927\u4e8etarget\u7684\u6700\u5c0f\uff0c\u5c0f\u4e8etarget\u7684\u6700\u5927\u7b49\u7b49\uff0c \u4e0d\u8981\u80cc\u4ee3\u7801 \uff0c\u5728\u8349\u7eb8\u4e0a\uff0c\u7528\u4e00\u4e2a\u4e09\u5143\u7ec4[3, 5, 7]\uff0cwhile\u6761\u4ef6\u90fd\u662f while (lo <= hi) \u6d4b\u8bd5\u4ee5\u4e0b4\u79cd \u60c5\u51b5\u5373\u53ef\uff1a 0\uff0c\u6bd4\u5168\u90e8\u90fd\u5c0f 9\uff0c\u6bd4\u5168\u90e8\u90fd\u5927 3\uff0c\u5b58\u5728\u503c 4\uff0c\u5728\u5176\u95f4","title":"Others"},{"location":"notes/others/#_1","text":"","title":"\u9898\u89e3\u7b14\u8bb0"},{"location":"notes/others/#2019-01","text":"","title":"2019-01"},{"location":"notes/others/#4-madian-sorted-arrays","text":"2\u4e2asorted\u6570\u7ec4\uff0c\u53d6\u7b2cK\u5927\u7684\u6570 \u7528left_k\uff0cright_k\uff08left_k + 1\uff09\u7684trick\u89e3\u51b3\u5947\u5076\u957f\u5ea6\u7684\u95ee\u9898 \u6bcf\u6b21\u53d6\u7b2ck/2\u4f4d\u7f6e\u7684\u5143\u7d20 val1\uff0cval2 \u6bd4\u8f83\uff0c\u5982\u679c val1 < val2 \uff0c\u5219\u6709 k/2 \u53ef\u4ee5\u6392\u9664\u4e86\uff0c arr1 \u8d77\u70b9 + k/2 \uff0c\u9012\u5f52\u67e5\u627e\u7b2c k-k/2 \u5927\u7684\u6570","title":"4. Madian Sorted Arrays"},{"location":"notes/others/#398-random-pick-index","text":"int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums); pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning. \u968f\u673a\u7d22\u5f15\uff0c\u5176\u5b9e\u60f3\u6a21\u62df\u84c4\u6c34\u6c60\u95ee\u9898\uff08Reservoir Sampling\uff09 \u4e86\u89e3\u84c4\u6c34\u6c60\u95ee\u9898\uff0c\u7406\u89e3\u84c4\u6c34\u6c60\u62bd\u6837\u7b97\u6cd5\u4e2d\u6982\u7387\u5747\u7b49\u7279\u70b9 \u84c4\u6c34\u6c60 https://cloud.tencent.com/developer/news/293271 \u66f4\u597d\u7684\u6a21\u62df\u5e94\u8be5\u662fstream\u6d41\u8f93\u5165\uff0c\u6bcf\u4e00\u4e2aindex\u9020\u4e00\u4e2a\u5927\u5c0f\u4e3a10\u7684\u6c60\u5b50\uff0c\u8fd9\u6837\u65e2\u8282\u7ea6\u7a7a\u95f4\u6709O\uff081\uff09pick \u5176\u5b9e\u53ef\u4ee5\u8fdb\u884c\u6269\u5c55\uff0c\u670d\u52a1\u5316\uff0c\u63d0\u4f9b/stream\u548c/pick\u63a5\u53e3\uff0c\u591a\u7ebf\u7a0b\u8bfb\u5199\u9501\u89e3\u51b3\u540c\u6b65\u95ee\u9898\uff0chub\u6a21\u5f0f\u901a\u8fc7hash\u89e3\u51b3\u591akey\u7684\u5206\u5e03\u5f0f\uff0c\u901a\u8fc7hub\u4e2d\u5bf9\u5404\u5b50\u8282\u70b9val\u503c\u8ba1\u6570\u89e3\u51b3\u5206\u5e03\u5b50\u8282\u70b9\u4e0d\u5747\u5300\u7684\u95ee\u9898 2020-01-02\u8865\u5145\uff0c\u6ca1\u6709\u8282\u70b9\u4e0d\u5747\u5300\u7684\u95ee\u9898\uff0c\u56e0\u4e3a\u6700\u5927\u5c31\u662f\u6c60\u5b50\u7684\u5927\u5c0f","title":"398. Random Pick Index"},{"location":"notes/others/#297-serialize-and-deserialize-binary-tree","text":"BST\u5e8f\u5217\u5316\u4e0e\u53cd\u5e8f\u5217\u5316\uff0c\u4e2d\u5e8f\u904d\u5386 \u5e8f\u5217\u5316\u903b\u8f91\u62c6\u5206\uff1a1-basic\u60c5\u51b5\u68c0\u6d4b\uff0c2-int->string->char vector\uff0c3-recursive\u5de6\u6811\uff0c\u7136\u540erecursive\u53f3\u5b50\u6811 \u53cd\u5e8f\u5217\u5316\u903b\u8f91\u62c6\u5206\uff1a1-\u5b9a\u4e49\u4e00\u4e2a\u5168\u5c40\u8d77\u59cbposition\uff0c\u4f20\u9012\u4e3a\u6307\u9488\uff0c2-\u672b\u5c3e\u8fb9\u754ccheck\uff0c3-\u53d6\u6574\u6bb5char\u8f6c\u4e3aint\uff0c4-position\u66f4\u65b0\uff0c\u9012\u5f52\u5de6\u53f3","title":"297. Serialize and Deserialize Binary Tree"},{"location":"notes/others/#138-copy-list-with-random-pointer","text":"\u89e3\u6cd51\uff0c\u9020\u4e2a2\u4e2amap\uff0c\u65e7\u7684[pointer, index]\uff0c\u65b0\u7684[index, pointer]\uff0c\u5148\u904d\u5386\u4e00\u6b21create\uff0c\u8bbemap\uff0c\u518d\u904d\u5386\u4e00\u6b21\u901a\u8fc72\u4e2amap\u627e\u5230random \u6ce8\u610frandom=NULL \u89e3\u6cd52\uff0cA -> A'-> B -> B'-> C -> C': \u63d2\u5165copy random=random->next \u5206\u79bb","title":"138. Copy List with Random Pointer"},{"location":"notes/others/#146-lru-cache","text":"LRU\uff0chashmap + double linked list \u5bf9\u4e8eGET\uff0c2\u79cd\u60c5\u51b5\uff0c\u6ca1\u627e\u5230/\u627e\u5230\uff0c\u627e\u5230\u8c03\u7528PUT\u5237\u65b0last use \u5bf9\u4e8ePUT\uff0c3\u79cd\u60c5\u51b5: key\u5728\uff0cdelete\u5220\u9664\u53cc\u7aef\u94fe\u8868\u8282\u70b9\uff0cadd\u6dfb\u52a0\u65b0\u8282\u70b9 key\u4e0d\u5728\uff0csize < cap\uff0c\u76f4\u63a5add key\u4e0d\u5728\uff0csize = cap\uff0celiminate\u6dd8\u6c70\u6700\u540e\u7684\uff0c\u8fd4\u56de\u6dd8\u6c70\u7684key\uff0c map\u540c\u6b65\u5220\u9664key \uff0c\u6267\u884cadd LRU\u539f\u7406\u548cRedis\u5b9e\u73b0\u2014\u2014\u4e00\u4e2a\u4eca\u65e5\u5934\u6761\u7684\u9762\u8bd5\u9898","title":"146. LRU Cache"},{"location":"notes/others/#221-maximal-square","text":"DP \u5982\u679c matrix[i][j] = '1', [i, j] = min([i+1, j], [i, j+1], [i+1, j+1]) + 1 \u5982\u679c matrix[i][j] = '0', [i, j] = 0","title":"221. Maximal Square"},{"location":"notes/others/#236-lowest-common-ancestor-of-a-binary-tree","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // \u5982\u679cp, q\u843d\u5728\u4e0d\u540c\u5b50\u6811\uff0c\u5219LCU\u662f\u5f53\u524d\u7684root // \u5982\u679cp, q\u843d\u5728\u76f8\u540c\u5b50\u6811\uff0c\u9012\u5f52\u5de6\u53f3\u7684\u5b50\u95ee\u9898\uff0c\u76f4\u81f3p,q\u843d\u5728\u4e0d\u540c\u5b50\u6811 TreeNode * func2 ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( root == NULL || root == p || root == q ) { return root ; } TreeNode * left = func2 ( root -> left , p , q ); TreeNode * right = func2 ( root -> right , p , q ); if ( left != NULL && right != NULL ) { return root ; } return left != NULL ? left : right ; }","title":"236.\u00a0Lowest Common Ancestor of a Binary Tree"},{"location":"notes/others/#300-longest-increasing-subsequence","text":"DP, copy+sort+unique\u521d\u59cb\u6570\u7ec4\uff0c\u7136\u540e\u8ba1\u7b97\u4e24\u4e2a\u6570\u7ec4\u7684LCS\u7684\u957f\u5ea6\uff0c\u56e0\u4e3alongest-common-subsequence\u65f6\u95f4\u662fO(n^2)\u7684\uff0c\u6700\u7ec8\u5c31\u662fO(n^2)\u7684\uff0c\u6240\u4ee5\uff1a \u8981\u5f97\u5230o(nlogn)\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u8be5\u600e\u4e48\u505a\u5462\uff1f O(nlogn)\u7684\u89e3\u6cd5\u53c2\u8003 https://blog.csdn.net/sgbfblog/article/details/7798737 \uff0c\u7b80\u8ff0\u4f8b\u5b50\u5982[12, 17, 18, 19, 14, 15, 16]\uff0c\u6784\u7b51\u7684\u9006\u5e8f\u6570\u7ec4\u6d41\u7a0b\u4e3a\uff1a \u521d\u59cb [16] 15\uff0c\u4e8c\u5206\u67e5\u627e=1 > \u6570\u7ec4\u5927\u5c0f\uff0c\u6570\u7ec4append\u4e3a[16, 15] 14\uff0c\u540c\u4e0a[16, 15, 14] 19\uff0c\u4e8c\u5206\u67e5\u627e=0\uff0c\u66ff\u636216\u4e3a19\uff0c\u539f\u56e0\u4e3a19\u5bf9\u5e94\u7684\u957f\u5ea6\u548c16\u4e00\u6837\uff0c\u90fd\u662f1\uff0c\u4f46\u662f19\u6bd416\u5927\uff0c\u5982\u679c16\u5bf9\u4e8e\u67d0\u4e00\u4e2a\u70b9\u662f\u9012\u589e\u7684\uff0c\u90a3\u4e4819\u4e5f\u4e00\u5b9a\u9012\u589e 18\uff0c\u540c\u4e0a\uff0c\u4e4b\u540e\u7684\u7701\u7565 \u6ce8\u610f \uff0c\u4e8c\u5206\u67e5\u627e\uff0c\u4e3a\uff0c\u5728\u4e00\u4e2a\u9006\u5e8f\u6570\u7ec4\u4e2d\uff0c\u627e\u5230\u6bd4target\u5c0f\u7684\u6700\u5927\u7684\u5143\u7d20 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // ** O ( nlogn ) binary - search solution , interesting func func3 ( nums [] int ) int { n : = len ( nums ); arr : = make ( [] int , 0 ); for i : = n - 1 ; i >= 0 ; i -- { idx : = findLargestLessOrEqualThanTarget ( arr , nums [ i ] ); if idx >= len ( arr ) { arr = append ( arr , nums [ i ] ) } else { arr [ idx ] = nums [ i ] ; } } return len ( arr ); } /* * nums is inverted order and return the index that nums[index] is the * largest element <= target * eg: [19,18,17,16,10], find target | nums[lo] | nums[hi] | ret: * 20 | nums[0]=19 | nums[-1]= | 0 * 19 | nums[0]=19 | nums[0]=19 | 0 * 12 | nums[4]=10 | nums[3]=16 | 4 * 09 | nums[5]= | nums[4]=10 | 5 */ func findLargestLessOrEqualThanTarget ( nums [] int , target int ) int { lo : = 0 ; hi : = len ( nums ) - 1 ; for ( lo <= hi ) { mid : = ( lo + hi ) / 2 ; if nums [ mid ] == target { return mid ; } else if nums [ mid ] > target { lo = mid + 1 ; } else { hi = mid - 1 ; } } return lo ; } 3. \u6807\u51c6DP\uff0c\u4ece\u5de6\u5230\u53f3\u8fed\u4ee3\uff0cdp[i]\u4e3a\uff0c\u4ece0\u5230i\uff0c\u4ee5i\u4e3a\u7ed3\u675f\uff0c\u6700\u957f\u7684LIS\uff0c\u4ece\u53f3\u5230\u5de6\u8fed\u4ee3\uff0cdp[i]\u4e3a\uff0c\u4ecei\u5230n-1\uff08\u5c3e\uff09\uff0c\u6700\u957f\u7684LIS\uff0c\u65f6\u95f4\u5747\u4e3aO(n^2)","title":"300. Longest Increasing Subsequence"},{"location":"notes/others/#673-number-of-longest-increasing-subsequence","text":"DP\uff0c300\u6c42LIS\u7684\u53d8\u79cd\uff0c\u591a\u6bd4\u8f83\u76f8\u7b49\u7684\u60c5\u51b5\uff0c\u8fed\u4ee3\u4e2d\uff0c\u4fdd\u5b58\u6bcf\u4e2a\u70b9\u7684\u6700\u5927\u7684LIS\u7684\u4e2a\u6570\u5373\u53ef\uff0c\u4e4b\u540e\uff0c\u7edf\u4e00\u7528\u5f97\u5230\u7684max_length\u8fed\u4ee3\u6bd4\u8f83\u8fdb\u884c\u7edf\u8ba1","title":"673. Number of Longest Increasing Subsequence"},{"location":"notes/others/#_2","text":"\u65e0\u8bba\u662f\u627e\u6700\u53f3\uff0c\u5927\u4e8etarget\u7684\u6700\u5c0f\uff0c\u5c0f\u4e8etarget\u7684\u6700\u5927\u7b49\u7b49\uff0c \u4e0d\u8981\u80cc\u4ee3\u7801 \uff0c\u5728\u8349\u7eb8\u4e0a\uff0c\u7528\u4e00\u4e2a\u4e09\u5143\u7ec4[3, 5, 7]\uff0cwhile\u6761\u4ef6\u90fd\u662f while (lo <= hi) \u6d4b\u8bd5\u4ee5\u4e0b4\u79cd \u60c5\u51b5\u5373\u53ef\uff1a 0\uff0c\u6bd4\u5168\u90e8\u90fd\u5c0f 9\uff0c\u6bd4\u5168\u90e8\u90fd\u5927 3\uff0c\u5b58\u5728\u503c 4\uff0c\u5728\u5176\u95f4","title":"\u901a\u7528\u4e8c\u5206\u67e5\u627e\u6574\u7406"},{"location":"notes/uf/","text":"Union Find \u5e76\u67e5\u96c6 2019-01 \u89e3\u51b3leetcode 684 \u7ed3\u5408\u89e3\u9898\u4ee3\u7801\u548c\u300a\u7b97\u6cd54\u300b1.5\uff0c\u603b\u7ed3\u4e00\u4e0b 1. \u5e76\u67e5\u96c6\u76ee\u7684 \u89e3\u51b3 \u52a8\u6001\u8fde\u901a\u6027(Dynamic connectivity) \u7684\u95ee\u9898 2. \u5e94\u7528\u573a\u666f Network\uff0c\u7f51\u7edc\uff0c2\u70b9\u95f4\u5efa\u7acb\u901a\u4fe1 Variable-name equivalence\uff0c\u53d8\u91cf\u540d\u7b49\u4ef7\u6027\uff0c\u7f16\u8bd1\u65f6\uff0c\u5224\u5b9a\u4ee3\u7801\u4e2d\uff0c2\u4e2a\u7ed9\u5b9a\u7684\u53d8\u91cf\u540d\u662f\u5426\u7b49\u4ef7 Mathematical sets\uff0c\u6570\u5b66\u96c6\u5408\uff0c\u5224\u5b9a\u7ed9\u5b9a\u8f93\u5165p\uff0cq\u662f\u5426\u5c5e\u4e8e\u540c\u4e00\u4e2a\u96c6\u5408 3. \u540d\u8bcd\u6982\u5ff5 Equivalence\uff0c\u7b49\u4ef7\u5173\u7cfb\uff0c\u82e5p\u548cq\u662f\u8fde\u63a5\u7684\uff0c\u5047\u8bbe\u8fde\u63a5\u662f\u4e00\u79cd\u7b49\u4ef7\u5173\u7cfb\uff0c\u5219 Reflexive\uff0c\u81ea\u53cd\u6027\uff0cp\u548cp\u662f\u8fde\u63a5\u7684 Symmetric\uff0c\u5bf9\u79f0\u6027\uff0cq\u548cp\u662f\u8fde\u63a5\u7684 Transitive\uff0c\u4f20\u9012\u6027\uff0cq\u548cr\u4e5f\u662f\u8fde\u63a5\u7684\uff0c\u5219p\u548cr\u4e5f\u662f 4. \u7b97\u6cd5\u5b9e\u73b0 \u4ee3\u7801\u5730\u5740\uff1a https://github.com/xfmeng17/leetcode/blob/master/cpp/684_RedundantConnection.cpp \u57fa\u672c\u601d\u60f3\uff0cunion\u65f6\uff0cfor\u4fbf\u5229 union\u662f\u6811\u578b\u5b58\u50a8\uff0c\u6839\u662f\u4e00\u4e2a\u6811\u7684ID 2\u7684\u57fa\u7840\u4e0a\uff0c\u52a0\u5165weight\u3002\u5408\u5e76\u65f6\uff0c\u5c0f\u6811\u5408\u5165\u5927\u6811\uff0cfind\u548cunion\u4e00\u822c\u60c5\u51b5\u4f1a\u964d\u5230O(lgn) 3\u7684\u57fa\u7840\u4e0a\uff0c\u52a0\u5165\u8def\u5f84\u538b\u7f29(path compression)\uff0c\u5728find\u65f6\uff0c\u518d\u5957\u4e00\u5c42while\u5faa\u73af\u5c06ID\u90fd\u6307\u5411\u6839\uff0c\u644a\u8fd8\u662fO(1)\uff0cleetcode\u4e0a\u53ef\u80fd\u56e0\u4e3a\u6d4b\u8bd5\u6837\u4f8b\u4e0d\u8db3\uff0c\u60f3\u8fc7\u4e0d\u59823\u660e\u663e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 // ** 1. Quick-find, O(1) find, 0(n) union class UF1 { private : vector < int > id ; int count ; public : UF1 ( int N ) { count = N ; id . resize ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { id [ i ] = i ; } } ~ UF1 () {} int getCount () { return count ; } bool connected ( int p , int q ) { return find ( p ) == find ( q ); } int find ( int p ) { return id [ p ]; } void doUnion ( int p , int q ) { int pId = find ( p ); int qId = find ( q ); if ( pId == qId ) { return ; } for ( int i = 0 ; i < id . size (); i ++ ) { if ( id [ i ] == pId ) { id [ i ] = qId ; } } count -- ; } }; // ** 2. Quick-union, O(n) find, O(1) union class UF2 { private : vector < int > id ; int count ; public : UF2 ( int N ) { count = N ; id . resize ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { id [ i ] = i ; } } ~ UF2 () {} int getCount () { return count ; } bool connected ( int p , int q ) { return find ( p ) == find ( q ); } int find ( int p ) { while ( p != id [ p ]) { p = id [ p ]; } return p ; } void doUnion ( int p , int q ) { int pRoot = find ( p ); int qRoot = find ( q ); if ( pRoot == qRoot ) { return ; } id [ pRoot ] = qRoot ; count -- ; } }; // ** 3. Weighted-quick-union, O(lgN) find, O(lgN) union class UF3 { private : vector < int > id ; vector < int > sz ; int count ; public : UF3 ( int N ) { count = N ; id . resize ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { id [ i ] = i ; } sz . resize ( N , 1 ); } ~ UF3 () {} int getCount () { return count ; } bool connected ( int p , int q ) { return find ( p ) == find ( q ); } int find ( int p ) { while ( p != id [ p ]) { p = id [ p ]; } return p ; } void doUnion ( int p , int q ) { int pRoot = find ( p ); int qRoot = find ( q ); if ( pRoot == qRoot ) { return ; } if ( sz [ pRoot ] < sz [ qRoot ]) { id [ pRoot ] = qRoot ; sz [ qRoot ] += sz [ pRoot ]; } else { id [ qRoot ] = pRoot ; sz [ qRoot ] += sz [ pRoot ]; } count -- ; } }; // ** 4.Weighted-quick-union-with-path-compression, amoritized O(1) class UF4 { private : vector < int > id ; vector < int > sz ; int count ; public : UF4 ( int N ) { count = N ; id . resize ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { id [ i ] = i ; } sz . resize ( N , 1 ); } ~ UF4 () {} int getCount () { return count ; } bool connected ( int p , int q ) { return find ( p ) == find ( q ); } int find ( int p ) { int root = p ; while ( root != id [ root ]) { root = id [ root ]; } while ( p != root ) { int newp = id [ p ]; id [ p ] = root ; p = newp ; } return root ; } void doUnion ( int p , int q ) { int pRoot = find ( p ); int qRoot = find ( q ); if ( pRoot == qRoot ) { return ; } if ( sz [ pRoot ] < sz [ qRoot ]) { id [ pRoot ] = qRoot ; sz [ qRoot ] += sz [ pRoot ]; } else { id [ qRoot ] = pRoot ; sz [ qRoot ] += sz [ pRoot ]; } count -- ; } }; class Solution { public : vector < int > findRedundantConnection ( vector < vector < int >>& edges ) { // return func1(edges); return union_find ( edges ); } vector < int > union_find ( vector < vector < int >>& edges ) { vector < int > ret ; int N = edges . size () + 1 ; // UF1 uf(N); // UF2 uf(N); // UF3 uf(N); UF4 uf ( N ); for ( int i = 0 ; i < edges . size (); i ++ ) { int p = edges [ i ][ 0 ]; int q = edges [ i ][ 1 ]; if ( uf . connected ( p , q )) { ret . emplace_back ( p ); ret . emplace_back ( q ); return ret ; } uf . doUnion ( p , q ); } return ret ; } };","title":"Union Find"},{"location":"notes/uf/#union-find","text":"","title":"Union Find \u5e76\u67e5\u96c6"},{"location":"notes/uf/#2019-01-leetcode-684","text":"\u7ed3\u5408\u89e3\u9898\u4ee3\u7801\u548c\u300a\u7b97\u6cd54\u300b1.5\uff0c\u603b\u7ed3\u4e00\u4e0b","title":"2019-01 \u89e3\u51b3leetcode 684"},{"location":"notes/uf/#1","text":"\u89e3\u51b3 \u52a8\u6001\u8fde\u901a\u6027(Dynamic connectivity) \u7684\u95ee\u9898","title":"1. \u5e76\u67e5\u96c6\u76ee\u7684"},{"location":"notes/uf/#2","text":"Network\uff0c\u7f51\u7edc\uff0c2\u70b9\u95f4\u5efa\u7acb\u901a\u4fe1 Variable-name equivalence\uff0c\u53d8\u91cf\u540d\u7b49\u4ef7\u6027\uff0c\u7f16\u8bd1\u65f6\uff0c\u5224\u5b9a\u4ee3\u7801\u4e2d\uff0c2\u4e2a\u7ed9\u5b9a\u7684\u53d8\u91cf\u540d\u662f\u5426\u7b49\u4ef7 Mathematical sets\uff0c\u6570\u5b66\u96c6\u5408\uff0c\u5224\u5b9a\u7ed9\u5b9a\u8f93\u5165p\uff0cq\u662f\u5426\u5c5e\u4e8e\u540c\u4e00\u4e2a\u96c6\u5408","title":"2. \u5e94\u7528\u573a\u666f"},{"location":"notes/uf/#3","text":"Equivalence\uff0c\u7b49\u4ef7\u5173\u7cfb\uff0c\u82e5p\u548cq\u662f\u8fde\u63a5\u7684\uff0c\u5047\u8bbe\u8fde\u63a5\u662f\u4e00\u79cd\u7b49\u4ef7\u5173\u7cfb\uff0c\u5219 Reflexive\uff0c\u81ea\u53cd\u6027\uff0cp\u548cp\u662f\u8fde\u63a5\u7684 Symmetric\uff0c\u5bf9\u79f0\u6027\uff0cq\u548cp\u662f\u8fde\u63a5\u7684 Transitive\uff0c\u4f20\u9012\u6027\uff0cq\u548cr\u4e5f\u662f\u8fde\u63a5\u7684\uff0c\u5219p\u548cr\u4e5f\u662f","title":"3. \u540d\u8bcd\u6982\u5ff5"},{"location":"notes/uf/#4","text":"\u4ee3\u7801\u5730\u5740\uff1a https://github.com/xfmeng17/leetcode/blob/master/cpp/684_RedundantConnection.cpp \u57fa\u672c\u601d\u60f3\uff0cunion\u65f6\uff0cfor\u4fbf\u5229 union\u662f\u6811\u578b\u5b58\u50a8\uff0c\u6839\u662f\u4e00\u4e2a\u6811\u7684ID 2\u7684\u57fa\u7840\u4e0a\uff0c\u52a0\u5165weight\u3002\u5408\u5e76\u65f6\uff0c\u5c0f\u6811\u5408\u5165\u5927\u6811\uff0cfind\u548cunion\u4e00\u822c\u60c5\u51b5\u4f1a\u964d\u5230O(lgn) 3\u7684\u57fa\u7840\u4e0a\uff0c\u52a0\u5165\u8def\u5f84\u538b\u7f29(path compression)\uff0c\u5728find\u65f6\uff0c\u518d\u5957\u4e00\u5c42while\u5faa\u73af\u5c06ID\u90fd\u6307\u5411\u6839\uff0c\u644a\u8fd8\u662fO(1)\uff0cleetcode\u4e0a\u53ef\u80fd\u56e0\u4e3a\u6d4b\u8bd5\u6837\u4f8b\u4e0d\u8db3\uff0c\u60f3\u8fc7\u4e0d\u59823\u660e\u663e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 // ** 1. Quick-find, O(1) find, 0(n) union class UF1 { private : vector < int > id ; int count ; public : UF1 ( int N ) { count = N ; id . resize ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { id [ i ] = i ; } } ~ UF1 () {} int getCount () { return count ; } bool connected ( int p , int q ) { return find ( p ) == find ( q ); } int find ( int p ) { return id [ p ]; } void doUnion ( int p , int q ) { int pId = find ( p ); int qId = find ( q ); if ( pId == qId ) { return ; } for ( int i = 0 ; i < id . size (); i ++ ) { if ( id [ i ] == pId ) { id [ i ] = qId ; } } count -- ; } }; // ** 2. Quick-union, O(n) find, O(1) union class UF2 { private : vector < int > id ; int count ; public : UF2 ( int N ) { count = N ; id . resize ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { id [ i ] = i ; } } ~ UF2 () {} int getCount () { return count ; } bool connected ( int p , int q ) { return find ( p ) == find ( q ); } int find ( int p ) { while ( p != id [ p ]) { p = id [ p ]; } return p ; } void doUnion ( int p , int q ) { int pRoot = find ( p ); int qRoot = find ( q ); if ( pRoot == qRoot ) { return ; } id [ pRoot ] = qRoot ; count -- ; } }; // ** 3. Weighted-quick-union, O(lgN) find, O(lgN) union class UF3 { private : vector < int > id ; vector < int > sz ; int count ; public : UF3 ( int N ) { count = N ; id . resize ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { id [ i ] = i ; } sz . resize ( N , 1 ); } ~ UF3 () {} int getCount () { return count ; } bool connected ( int p , int q ) { return find ( p ) == find ( q ); } int find ( int p ) { while ( p != id [ p ]) { p = id [ p ]; } return p ; } void doUnion ( int p , int q ) { int pRoot = find ( p ); int qRoot = find ( q ); if ( pRoot == qRoot ) { return ; } if ( sz [ pRoot ] < sz [ qRoot ]) { id [ pRoot ] = qRoot ; sz [ qRoot ] += sz [ pRoot ]; } else { id [ qRoot ] = pRoot ; sz [ qRoot ] += sz [ pRoot ]; } count -- ; } }; // ** 4.Weighted-quick-union-with-path-compression, amoritized O(1) class UF4 { private : vector < int > id ; vector < int > sz ; int count ; public : UF4 ( int N ) { count = N ; id . resize ( N , 0 ); for ( int i = 0 ; i < N ; i ++ ) { id [ i ] = i ; } sz . resize ( N , 1 ); } ~ UF4 () {} int getCount () { return count ; } bool connected ( int p , int q ) { return find ( p ) == find ( q ); } int find ( int p ) { int root = p ; while ( root != id [ root ]) { root = id [ root ]; } while ( p != root ) { int newp = id [ p ]; id [ p ] = root ; p = newp ; } return root ; } void doUnion ( int p , int q ) { int pRoot = find ( p ); int qRoot = find ( q ); if ( pRoot == qRoot ) { return ; } if ( sz [ pRoot ] < sz [ qRoot ]) { id [ pRoot ] = qRoot ; sz [ qRoot ] += sz [ pRoot ]; } else { id [ qRoot ] = pRoot ; sz [ qRoot ] += sz [ pRoot ]; } count -- ; } }; class Solution { public : vector < int > findRedundantConnection ( vector < vector < int >>& edges ) { // return func1(edges); return union_find ( edges ); } vector < int > union_find ( vector < vector < int >>& edges ) { vector < int > ret ; int N = edges . size () + 1 ; // UF1 uf(N); // UF2 uf(N); // UF3 uf(N); UF4 uf ( N ); for ( int i = 0 ; i < edges . size (); i ++ ) { int p = edges [ i ][ 0 ]; int q = edges [ i ][ 1 ]; if ( uf . connected ( p , q )) { ret . emplace_back ( p ); ret . emplace_back ( q ); return ret ; } uf . doUnion ( p , q ); } return ret ; } };","title":"4. \u7b97\u6cd5\u5b9e\u73b0"},{"location":"notes/biweekly_contest/0016/","text":"Biweekly Contest 16 2020-01-25 Virtual 1299 , 1300 , 1301 , 1302 1299. Replace Elements with Greatest Element on Right Side cpp \u7b80\u5355 1300. Sum of Mutated Array Closest to Target cpp \u6ca1\u505a\u51fa\u6765 \uff0c\u5f88\u597d\u7684Binary-Search\uff0c 1302. Deepest Leaves Sum cpp \u7b80\u5355\uff0ctree+2\u4e2aqueue 1301. Number of Paths with Max Score cpp \u6ca1\u505a\u51fa\u6765 \uff0c\u6807\u51c6DP\uff0c\u540c\u65f6\u6c42\u6700\u4f18\u89e3+\u6700\u4f18\u89e3\u4e2a\u6570\uff0c\u5728\u65f6\u95f4\u538b\u529b\u4e0b\uff0c\u601d\u8003\u529b\uff0c\u7f16\u7a0b\u529b\uff0c\u8fd8\u662f\u6709\u6240\u53d8\u5f62\uff01\uff01 \u603b\u7ed3\uff0c\u867d\u7136\u662f\u505a\u7684 Virtual \uff0c\u4f46\u662f\u5728\u538b\u529b\u4e0b\uff0c\u8fd8\u662f\u5f88\u6709\u6536\u83b7\u7684\uff0c\u7ee7\u7eed\u53c2\u89c1\uff01","title":"Biweekly Contest 16"},{"location":"notes/biweekly_contest/0016/#biweekly-contest-16","text":"","title":"Biweekly Contest 16"},{"location":"notes/biweekly_contest/0016/#2020-01-25-virtual","text":"1299 , 1300 , 1301 , 1302","title":"2020-01-25 Virtual"},{"location":"notes/biweekly_contest/0016/#1299-replace-elements-with-greatest-element-on-right-side","text":"cpp \u7b80\u5355","title":"1299. Replace Elements with Greatest Element on Right Side"},{"location":"notes/biweekly_contest/0016/#1300-sum-of-mutated-array-closest-to-target","text":"cpp \u6ca1\u505a\u51fa\u6765 \uff0c\u5f88\u597d\u7684Binary-Search\uff0c","title":"1300. Sum of Mutated Array Closest to Target"},{"location":"notes/biweekly_contest/0016/#1302-deepest-leaves-sum","text":"cpp \u7b80\u5355\uff0ctree+2\u4e2aqueue","title":"1302. Deepest Leaves Sum"},{"location":"notes/biweekly_contest/0016/#1301-number-of-paths-with-max-score","text":"cpp \u6ca1\u505a\u51fa\u6765 \uff0c\u6807\u51c6DP\uff0c\u540c\u65f6\u6c42\u6700\u4f18\u89e3+\u6700\u4f18\u89e3\u4e2a\u6570\uff0c\u5728\u65f6\u95f4\u538b\u529b\u4e0b\uff0c\u601d\u8003\u529b\uff0c\u7f16\u7a0b\u529b\uff0c\u8fd8\u662f\u6709\u6240\u53d8\u5f62\uff01\uff01 \u603b\u7ed3\uff0c\u867d\u7136\u662f\u505a\u7684 Virtual \uff0c\u4f46\u662f\u5728\u538b\u529b\u4e0b\uff0c\u8fd8\u662f\u5f88\u6709\u6536\u83b7\u7684\uff0c\u7ee7\u7eed\u53c2\u89c1\uff01","title":"1301. Number of Paths with Max Score"},{"location":"notes/biweekly_contest/0017/","text":"Biweekly Contest 17 2020-01-25 Virtual 1313 , 1314 , 1315 , 1316 1313. Decompress Run-Length Encoded List cpp \u7b80\u5355 1314. Matrix Block Sum cpp \u66b4\u529b4\u5c42\u5faa\u73af\u641e\u5b9a\uff0c\u4e0d\u7528\u53bb\u4f18\u5316\uff0c\u8fc7\u4e8e\u590d\u6742 1315. Sum of Nodes with Even-Valued Grandparent cpp map\u8bb0\u5f55\u7236\u8282\u70b9\uff0c\u7136\u540e\u8fed\u4ee3map\u627e\u7237\u7237\uff0c\u5224\u5b9a\u7237\u7237val\u662f\u5076\u6570 1316. Distinct Echo Substrings cpp \u6709\u65f6 Time Limit Exceeded \uff0c\u6709\u65f6 AC func2 \u4e2d\uff0c\u5fc5\u987b\u7f13\u5b58\u5f97\u5230\u7684\u5168\u90e8\u7684\u5b50\u5b57\u7b26\u4e32\uff0c\u5373\u5728\u5faa\u73af\u9876\u90e8\u5c31\u6c42sub\uff1a string s = text.substr(i, len); \uff0c\u4f46\u662f\u540c\u6837\u8fd9\u6837\u64cd\u4f5cstring\u4f1a\u6bd4\u8f83\u6162 ~~\u5c1d\u8bd5\u4e0bDP\u7684\u601d\u60f3\uff0c dp[i][j]=true/false \u4fdd\u5b58\u5b50\u5b57\u7b26\u4e32i...j\u7684\u7ed3\u679c\uff0c\u7136\u540e\u904d\u5386dp\u627e\u5230\u4e3atrue\u7684\uff0c\u5728substr\uff0c\u653e\u5165set\u6392\u91cd~~ ~~Discuss\u91cc\u9762\u5168\u662f\u7528hash\u505a\u5b57\u7b26\u4e32\u6bd4\u8f83\u7684\uff0c\u6211\u611f\u89c9\u4e0d\u662f\u5f88\u597d\u3002~~ \u770b\u5b9e\u73b0\uff0c\u5b9e\u73b0\u4e86Rabin-karp\u5b50\u5b57\u7b26\u4e32\u67e5\u627e\u7b97\u6cd5 \u5bf9\u4e8e\u5b9e\u6218Rabin-karp\u7b97\u6cd5\uff0c\u76ee\u524d\u6211\u9047\u5230\u7684\u6700\u597d\u7684\u9898\uff0c\u7528rk\u5b50\u5b57\u7b26\u4e32\u67e5\u627e\u5c31\u80fdAC \u603b\u7ed3\uff0c\u7b2c\u4e00\u6b21\u505acontest\uff0c\u8fd8\u662f\u5728\u538b\u529b\u4e0b\u7f16\u7a0b\u6bd4\u8f83\u63d0\u5347\u4eba\uff0c\u867d\u7136\u662f\u505a\u7684 Virtual \uff0c\u7ee7\u7eed\u53c2\u52a0\uff01","title":"Biweekly Contest 17"},{"location":"notes/biweekly_contest/0017/#biweekly-contest-17","text":"","title":"Biweekly Contest 17"},{"location":"notes/biweekly_contest/0017/#2020-01-25-virtual","text":"1313 , 1314 , 1315 , 1316","title":"2020-01-25 Virtual"},{"location":"notes/biweekly_contest/0017/#1313-decompress-run-length-encoded-list","text":"cpp \u7b80\u5355","title":"1313. Decompress Run-Length Encoded List"},{"location":"notes/biweekly_contest/0017/#1314-matrix-block-sum","text":"cpp \u66b4\u529b4\u5c42\u5faa\u73af\u641e\u5b9a\uff0c\u4e0d\u7528\u53bb\u4f18\u5316\uff0c\u8fc7\u4e8e\u590d\u6742","title":"1314. Matrix Block Sum"},{"location":"notes/biweekly_contest/0017/#1315-sum-of-nodes-with-even-valued-grandparent","text":"cpp map\u8bb0\u5f55\u7236\u8282\u70b9\uff0c\u7136\u540e\u8fed\u4ee3map\u627e\u7237\u7237\uff0c\u5224\u5b9a\u7237\u7237val\u662f\u5076\u6570","title":"1315. Sum of Nodes with Even-Valued Grandparent"},{"location":"notes/biweekly_contest/0017/#1316-distinct-echo-substrings","text":"cpp \u6709\u65f6 Time Limit Exceeded \uff0c\u6709\u65f6 AC func2 \u4e2d\uff0c\u5fc5\u987b\u7f13\u5b58\u5f97\u5230\u7684\u5168\u90e8\u7684\u5b50\u5b57\u7b26\u4e32\uff0c\u5373\u5728\u5faa\u73af\u9876\u90e8\u5c31\u6c42sub\uff1a string s = text.substr(i, len); \uff0c\u4f46\u662f\u540c\u6837\u8fd9\u6837\u64cd\u4f5cstring\u4f1a\u6bd4\u8f83\u6162 ~~\u5c1d\u8bd5\u4e0bDP\u7684\u601d\u60f3\uff0c dp[i][j]=true/false \u4fdd\u5b58\u5b50\u5b57\u7b26\u4e32i...j\u7684\u7ed3\u679c\uff0c\u7136\u540e\u904d\u5386dp\u627e\u5230\u4e3atrue\u7684\uff0c\u5728substr\uff0c\u653e\u5165set\u6392\u91cd~~ ~~Discuss\u91cc\u9762\u5168\u662f\u7528hash\u505a\u5b57\u7b26\u4e32\u6bd4\u8f83\u7684\uff0c\u6211\u611f\u89c9\u4e0d\u662f\u5f88\u597d\u3002~~ \u770b\u5b9e\u73b0\uff0c\u5b9e\u73b0\u4e86Rabin-karp\u5b50\u5b57\u7b26\u4e32\u67e5\u627e\u7b97\u6cd5 \u5bf9\u4e8e\u5b9e\u6218Rabin-karp\u7b97\u6cd5\uff0c\u76ee\u524d\u6211\u9047\u5230\u7684\u6700\u597d\u7684\u9898\uff0c\u7528rk\u5b50\u5b57\u7b26\u4e32\u67e5\u627e\u5c31\u80fdAC \u603b\u7ed3\uff0c\u7b2c\u4e00\u6b21\u505acontest\uff0c\u8fd8\u662f\u5728\u538b\u529b\u4e0b\u7f16\u7a0b\u6bd4\u8f83\u63d0\u5347\u4eba\uff0c\u867d\u7136\u662f\u505a\u7684 Virtual \uff0c\u7ee7\u7eed\u53c2\u52a0\uff01","title":"1316. Distinct Echo Substrings"},{"location":"notes/biweekly_contest/0018/","text":"Biweekly Contest 18 2020-01-25 22:30 1331 , 1332 , 1333 , 1334 3\u9898\uff0c\u6700\u540e\u4e00\u9898TLE 1331. Rank Transform of an Array cpp \u7b80\u5355 1328. Break a Palindrome cpp \u524d\u534a\u533a\u627ea\uff0c\u76f4\u5230\u627e\u5230\u4e0d\u662fa\uff0c\u66ff\u6362\u4e3aa\uff0c\u82e5\u5bf9\u79f0\u7684\u524d\u534a\u533a\u5168\u662fa\uff0c\u5219\u8868\u793a\u662faaa aaa \u8fd9\u79cd\uff0c\u628a\u6700\u540e\u4e00\u4e2a\u6539\u6210b \u5b9e\u73b0\u4e2d palindrome[N-1] = palindrome[N-1] == 'z' ? 'a' : palindrome[N-1]+1; \u6ca1\u5fc5\u8981 1329. Sort the Matrix Diagonally cpp \u7b80\u5355\u66b4\u529b\u8fed\u4ee3 1330. Reverse Subarray To Maximize Array Value cpp O(N^2)\u4e8c\u7ef4\u67e5\u627e\u6bd4\u8f83\uff0cTLE\uff0c\u5c1a\u672a\u89e3\u51b3 2020-02-06 \uff0c\u53c2\u8003discuss\uff0cAC\uff1a \u53c2\u8003 \u5173\u952e\u70b9\u662f\uff0c\u5728\u65cb\u8f6c\u5b50\u6570\u7ec4\u65f6\uff0c\u5047\u8bbe\u662f[L, R]\uff0c\u5f97\u51fa\u65b0\u7684Value\u516c\u5f0f\u4e3a S - abs(a[L-1]-a[L]) - abs(a[R] - a[R+1]) + abs(a[L-1]-a[R]) + abs(a[L] - a[R+1]) \u4e0d\u8003\u8651\u8fb9\u754c\u60c5\u51b5(L=0\uff0c\u5bfc\u81f4L-1 = -1)\uff0c\u5206\u56db\u4e2a\u60c5\u51b5\uff1a 1. a[L-1] < a[R] and a[L] < a[R+1] 2. a[L-1] > a[R] and a[L] < a[R+1] 3. a[L-1] < a[R] and a[L] > a[R+1] 4. a[L-1] > a[R] and a[L] > a[R+1] \u7136\u540e\u62c6\u5206\u51fa\u6765\uff1a S - abs(a[L] - a[L-1]) - abs(a[R] - a[R+1]) + (a[R] - a[L-1]) + (a[R+1] - a[l]) => S - abs(a[L] - a[L-1]) - a[L-1] - a[L] - abs(a[R] - a[R+1]) + a[R] + a[R+1] \u5728\u7b2c1\u79cd\u60c5\u51b5\u4e0b\uff1a X = 0 - abs(a[L] - a[L-1]) - a[L-1] - a[L] Y = 0 - abs(a[R] - a[R+1]) + a[R] + a[R+1] value = S + X + Y \u8fd9\u6837\uff0c\u53d1\u73b0L\u548cR\u5c31\u6ca1\u5565\u5173\u7cfb\uff0c\u4e0d\u9700\u8981\u7ed1\u5b9a\u5230\u4e00\u8d77\u505a\u4e8c\u7ef4\u7684\u8fed\u4ee3\u8ba1\u7b97\uff0c\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u4e00\u7ef4\u4e2a\u7b97\u4e2a\u7684\uff0c\u7136\u540e\u53d6\u6700\u5927\u7684S+X+Y\u5373\u53ef\u30024\u4e2acase\u4e0bX\uff0cY\u7684\u8868\u793a\u4e0d\u540c\uff0c\u4f46\u662f\u4e5f\u90fd\u53ea\u9700\u89811\u7ef4\u5faa\u73af\u6570\u7ec4\u4e00\u6b21\u5c31\u80fd\u5f97\u5230\u7ed3\u679c\u3002 \u8fd9\u4e2a\u9898\uff0c\u6211\u57282020-02-06\u82b1\u8d39\u4e86\u5c0f\u4e00\u5929\u53bb\u68b3\u7406\uff0c\u4e3b\u8981\u539f\u56e0\u662f\u8fd9\u79cd\u8f6c\u5316\u4e3a \u6570\u5b66\u516c\u5f0f\u540e\uff0c\u5206\u79bb\u53d8\u91cf\uff0c\u964d\u7ef4\u8fed\u4ee3\u7684\u601d\u7ef4 \u662f\u7b2c\u4e00\u6b21\u9047\u5230\uff0c\u8bb0\u5f97\u5230\u6821\u62db\u65f6\u505a\u8fc7\u4e00\u9053TopCoder\u4e0a\u4e00\u4e2a\u597d\u50cf\u53eb \u889c\u5b50\u5339\u914d\u5565\u5565\u7684\u9898 \uff0c\u89e3\u6cd5\u662f\uff0c\u8f6c\u6362\u540e\u5728\u6240\u6709\u53ef\u80fd\u7ed3\u679c\u7684\u8303\u56f4\u5185\uff0c\u5982[0, N]\u91cc\u9762\u901a\u8fc7\u4e8c\u7ef4\u67e5\u627e\u5224\u5b9a\u662f\u4e0d\u662f\u53ef\u884c\u89e3\u7684\u601d\u7ef4\uff0c\u5f53\u65f6\u5982\u679c\u8bb0\u5f97\u6574\u7406\u5c31\u597d\u4e86\uff01 \u8981\u7761\u89c9\u4e86\u505a\u7684\uff0c\u9664\u4e86\u6700\u540e\u4e00\u9898\uff0c\u524d\u4e09\u9898\u5747\u6ca1\u5361\u58f3\uff0c\u5df2\u7ecf\u53ef\u4ee5\u4e86\u3002","title":"Biweekly Contest 18"},{"location":"notes/biweekly_contest/0018/#biweekly-contest-18","text":"","title":"Biweekly Contest 18"},{"location":"notes/biweekly_contest/0018/#2020-01-25-2230","text":"1331 , 1332 , 1333 , 1334 3\u9898\uff0c\u6700\u540e\u4e00\u9898TLE","title":"2020-01-25 22:30"},{"location":"notes/biweekly_contest/0018/#1331-rank-transform-of-an-array","text":"cpp \u7b80\u5355","title":"1331. Rank Transform of an Array"},{"location":"notes/biweekly_contest/0018/#1328-break-a-palindrome","text":"cpp \u524d\u534a\u533a\u627ea\uff0c\u76f4\u5230\u627e\u5230\u4e0d\u662fa\uff0c\u66ff\u6362\u4e3aa\uff0c\u82e5\u5bf9\u79f0\u7684\u524d\u534a\u533a\u5168\u662fa\uff0c\u5219\u8868\u793a\u662faaa aaa \u8fd9\u79cd\uff0c\u628a\u6700\u540e\u4e00\u4e2a\u6539\u6210b \u5b9e\u73b0\u4e2d palindrome[N-1] = palindrome[N-1] == 'z' ? 'a' : palindrome[N-1]+1; \u6ca1\u5fc5\u8981","title":"1328. Break a Palindrome"},{"location":"notes/biweekly_contest/0018/#1329-sort-the-matrix-diagonally","text":"cpp \u7b80\u5355\u66b4\u529b\u8fed\u4ee3","title":"1329. Sort the Matrix Diagonally"},{"location":"notes/biweekly_contest/0018/#1330-reverse-subarray-to-maximize-array-value","text":"cpp O(N^2)\u4e8c\u7ef4\u67e5\u627e\u6bd4\u8f83\uff0cTLE\uff0c\u5c1a\u672a\u89e3\u51b3 2020-02-06 \uff0c\u53c2\u8003discuss\uff0cAC\uff1a \u53c2\u8003 \u5173\u952e\u70b9\u662f\uff0c\u5728\u65cb\u8f6c\u5b50\u6570\u7ec4\u65f6\uff0c\u5047\u8bbe\u662f[L, R]\uff0c\u5f97\u51fa\u65b0\u7684Value\u516c\u5f0f\u4e3a S - abs(a[L-1]-a[L]) - abs(a[R] - a[R+1]) + abs(a[L-1]-a[R]) + abs(a[L] - a[R+1]) \u4e0d\u8003\u8651\u8fb9\u754c\u60c5\u51b5(L=0\uff0c\u5bfc\u81f4L-1 = -1)\uff0c\u5206\u56db\u4e2a\u60c5\u51b5\uff1a 1. a[L-1] < a[R] and a[L] < a[R+1] 2. a[L-1] > a[R] and a[L] < a[R+1] 3. a[L-1] < a[R] and a[L] > a[R+1] 4. a[L-1] > a[R] and a[L] > a[R+1] \u7136\u540e\u62c6\u5206\u51fa\u6765\uff1a S - abs(a[L] - a[L-1]) - abs(a[R] - a[R+1]) + (a[R] - a[L-1]) + (a[R+1] - a[l]) => S - abs(a[L] - a[L-1]) - a[L-1] - a[L] - abs(a[R] - a[R+1]) + a[R] + a[R+1] \u5728\u7b2c1\u79cd\u60c5\u51b5\u4e0b\uff1a X = 0 - abs(a[L] - a[L-1]) - a[L-1] - a[L] Y = 0 - abs(a[R] - a[R+1]) + a[R] + a[R+1] value = S + X + Y \u8fd9\u6837\uff0c\u53d1\u73b0L\u548cR\u5c31\u6ca1\u5565\u5173\u7cfb\uff0c\u4e0d\u9700\u8981\u7ed1\u5b9a\u5230\u4e00\u8d77\u505a\u4e8c\u7ef4\u7684\u8fed\u4ee3\u8ba1\u7b97\uff0c\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u4e00\u7ef4\u4e2a\u7b97\u4e2a\u7684\uff0c\u7136\u540e\u53d6\u6700\u5927\u7684S+X+Y\u5373\u53ef\u30024\u4e2acase\u4e0bX\uff0cY\u7684\u8868\u793a\u4e0d\u540c\uff0c\u4f46\u662f\u4e5f\u90fd\u53ea\u9700\u89811\u7ef4\u5faa\u73af\u6570\u7ec4\u4e00\u6b21\u5c31\u80fd\u5f97\u5230\u7ed3\u679c\u3002 \u8fd9\u4e2a\u9898\uff0c\u6211\u57282020-02-06\u82b1\u8d39\u4e86\u5c0f\u4e00\u5929\u53bb\u68b3\u7406\uff0c\u4e3b\u8981\u539f\u56e0\u662f\u8fd9\u79cd\u8f6c\u5316\u4e3a \u6570\u5b66\u516c\u5f0f\u540e\uff0c\u5206\u79bb\u53d8\u91cf\uff0c\u964d\u7ef4\u8fed\u4ee3\u7684\u601d\u7ef4 \u662f\u7b2c\u4e00\u6b21\u9047\u5230\uff0c\u8bb0\u5f97\u5230\u6821\u62db\u65f6\u505a\u8fc7\u4e00\u9053TopCoder\u4e0a\u4e00\u4e2a\u597d\u50cf\u53eb \u889c\u5b50\u5339\u914d\u5565\u5565\u7684\u9898 \uff0c\u89e3\u6cd5\u662f\uff0c\u8f6c\u6362\u540e\u5728\u6240\u6709\u53ef\u80fd\u7ed3\u679c\u7684\u8303\u56f4\u5185\uff0c\u5982[0, N]\u91cc\u9762\u901a\u8fc7\u4e8c\u7ef4\u67e5\u627e\u5224\u5b9a\u662f\u4e0d\u662f\u53ef\u884c\u89e3\u7684\u601d\u7ef4\uff0c\u5f53\u65f6\u5982\u679c\u8bb0\u5f97\u6574\u7406\u5c31\u597d\u4e86\uff01 \u8981\u7761\u89c9\u4e86\u505a\u7684\uff0c\u9664\u4e86\u6700\u540e\u4e00\u9898\uff0c\u524d\u4e09\u9898\u5747\u6ca1\u5361\u58f3\uff0c\u5df2\u7ecf\u53ef\u4ee5\u4e86\u3002","title":"1330. Reverse Subarray To Maximize Array Value"},{"location":"notes/biweekly_contest/0019/","text":"biweekly-contest-19 2020-02-08 1342 1343 1344 1345 1342. Number of Steps to Reduce a Number to Zero cpp 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold cpp 1344. Angle Between Hands of a Clock cpp 1345. Jump Game IV cpp","title":"Biweekly Contest 19"},{"location":"notes/biweekly_contest/0019/#biweekly-contest-19","text":"","title":"biweekly-contest-19"},{"location":"notes/biweekly_contest/0019/#2020-02-08-1342-1343-1344-1345","text":"","title":"2020-02-08 1342 1343 1344 1345"},{"location":"notes/biweekly_contest/0019/#1342-number-of-steps-to-reduce-a-number-to-zero","text":"cpp","title":"1342. Number of Steps to Reduce a Number to Zero"},{"location":"notes/biweekly_contest/0019/#1343-number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold","text":"cpp","title":"1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold"},{"location":"notes/biweekly_contest/0019/#1344-angle-between-hands-of-a-clock","text":"cpp","title":"1344. Angle Between Hands of a Clock"},{"location":"notes/biweekly_contest/0019/#1345-jump-game-iv","text":"cpp","title":"1345. Jump Game IV"},{"location":"notes/weekly_contest/0173/","text":"Biweekly Contest 17 2020-01-26 10:30 1332 , 1333 , 1334 , 1335 4\u9898\uff0c\u7f5a\u65f6\u8f83\u591a\uff0c\u6700\u540e\u4e00\u9898\u672a\u6309\u65f6\u5b8c\u6210 1332. Remove Palindromic Subsequences cpp \u7b80\u5355\uff0ctrick\u9898\uff0c\u5224\u5b9a\u81ea\u8eab\u662f\u5426\u662f\u56de\u6587\uff0c\u662f\u8fd4\u56de1\uff0c\u4e0d\u662f\u8fd4\u56de2 1333. Filter Restaurants by Vegan-Friendly, Price and Distance cpp \u7b80\u5355\uff0c\u8fc7\u6ee4\u540e\u5199\u4e2asort\u7684comp\u51fd\u6570 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance cpp \u5b9e\u6218\u597d\u9898 \uff0c\u56fe\u8bba\uff0c\u591a\u6e90\u6700\u77ed\u8def\u5f84\uff0cFloyd-Warshall\u7b97\u6cd5 1335. Minimum Difficulty of a Job Schedule cpp \u6807\u51c62\u7ef4DP\uff0c dp[d][lo][hi] \u8868\u793a\u5269\u4f59d\u5929\uff0c\u6570\u7ec4lo...hi\u7684\u7ed3\u679c \u5982\u679c\u4e0d\u5728\u7b2c\u4e00\u9053\u9898\u90a3\u91cc\u5361\u58f3\uff0c\u5219\u662f\u6211\u7b2c\u4e00\u6b21\u72ec\u7acb\u5b8c\u6210\u5168\u90e84\u9898\uff0c\u8fd8\u662f\u4e0d\u9519\u7684\u3002\u56fe\u8bba\u662f\u65f6\u5019\u5feb\u901f\u590d\u4e60\u68b3\u7406\u4e00\u4e0b\u4e86\uff01","title":"Weekly Contest 173"},{"location":"notes/weekly_contest/0173/#biweekly-contest-17","text":"","title":"Biweekly Contest 17"},{"location":"notes/weekly_contest/0173/#2020-01-26-1030","text":"1332 , 1333 , 1334 , 1335 4\u9898\uff0c\u7f5a\u65f6\u8f83\u591a\uff0c\u6700\u540e\u4e00\u9898\u672a\u6309\u65f6\u5b8c\u6210","title":"2020-01-26 10:30"},{"location":"notes/weekly_contest/0173/#1332-remove-palindromic-subsequences","text":"cpp \u7b80\u5355\uff0ctrick\u9898\uff0c\u5224\u5b9a\u81ea\u8eab\u662f\u5426\u662f\u56de\u6587\uff0c\u662f\u8fd4\u56de1\uff0c\u4e0d\u662f\u8fd4\u56de2","title":"1332. Remove Palindromic Subsequences"},{"location":"notes/weekly_contest/0173/#1333-filter-restaurants-by-vegan-friendly-price-and-distance","text":"cpp \u7b80\u5355\uff0c\u8fc7\u6ee4\u540e\u5199\u4e2asort\u7684comp\u51fd\u6570","title":"1333. Filter Restaurants by Vegan-Friendly, Price and Distance"},{"location":"notes/weekly_contest/0173/#1334-find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance","text":"cpp \u5b9e\u6218\u597d\u9898 \uff0c\u56fe\u8bba\uff0c\u591a\u6e90\u6700\u77ed\u8def\u5f84\uff0cFloyd-Warshall\u7b97\u6cd5","title":"1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance"},{"location":"notes/weekly_contest/0173/#1335-minimum-difficulty-of-a-job-schedule","text":"cpp \u6807\u51c62\u7ef4DP\uff0c dp[d][lo][hi] \u8868\u793a\u5269\u4f59d\u5929\uff0c\u6570\u7ec4lo...hi\u7684\u7ed3\u679c \u5982\u679c\u4e0d\u5728\u7b2c\u4e00\u9053\u9898\u90a3\u91cc\u5361\u58f3\uff0c\u5219\u662f\u6211\u7b2c\u4e00\u6b21\u72ec\u7acb\u5b8c\u6210\u5168\u90e84\u9898\uff0c\u8fd8\u662f\u4e0d\u9519\u7684\u3002\u56fe\u8bba\u662f\u65f6\u5019\u5feb\u901f\u590d\u4e60\u68b3\u7406\u4e00\u4e0b\u4e86\uff01","title":"1335. Minimum Difficulty of a Job Schedule"},{"location":"notes/weekly_contest/0174/","text":"Biweekly Contest 17 2020-01-26 10:30 1332 , 1333 , 1334 , 1335","title":"Weekly Contest 174"},{"location":"notes/weekly_contest/0174/#biweekly-contest-17","text":"","title":"Biweekly Contest 17"},{"location":"notes/weekly_contest/0174/#2020-01-26-1030","text":"1332 , 1333 , 1334 , 1335","title":"2020-01-26 10:30"},{"location":"notes/weekly_contest/0175/","text":"weekly-contest-175 2020-02-09 1346 1347 1348 1349 1346. Check If N and Its Double Exist cpp 1347. Minimum Number of Steps to Make Two Strings Anagram cpp 1348. Tweet Counts Per Frequency cpp 1349. Maximum Students Taking Exam cpp","title":"Weekly Contest 175"},{"location":"notes/weekly_contest/0175/#weekly-contest-175","text":"","title":"weekly-contest-175"},{"location":"notes/weekly_contest/0175/#2020-02-09-1346-1347-1348-1349","text":"","title":"2020-02-09 1346 1347 1348 1349"},{"location":"notes/weekly_contest/0175/#1346-check-if-n-and-its-double-exist","text":"cpp","title":"1346. Check If N and Its Double Exist"},{"location":"notes/weekly_contest/0175/#1347-minimum-number-of-steps-to-make-two-strings-anagram","text":"cpp","title":"1347. Minimum Number of Steps to Make Two Strings Anagram"},{"location":"notes/weekly_contest/0175/#1348-tweet-counts-per-frequency","text":"cpp","title":"1348. Tweet Counts Per Frequency"},{"location":"notes/weekly_contest/0175/#1349-maximum-students-taking-exam","text":"cpp","title":"1349. Maximum Students Taking Exam"}]}